/**
 * Template Cache
 *
 * Caches VNode trees generated by component template functions to optimize re-renders.
 * Components execute their template function once and cache the VNode tree structure.
 * On subsequent renders with the same props, the cached VNode is reused and only
 * reactive bindings are updated.
 *
 * @module reconciler/template-cache
 */

import type { VNode } from './vnode.js';

/**
 * Statistics about cache performance
 */
export interface CacheStats {
  /** Total number of cache hits */
  hits: number;
  /** Total number of cache misses */
  misses: number;
  /** Current number of cached entries */
  size: number;
  /** Hit rate as percentage (0-100) */
  hitRate: number;
}

/**
 * Template cache for component VNode trees.
 *
 * Implements an LRU-like cache with configurable maximum size.
 * Tracks cache statistics for performance monitoring.
 *
 * @example
 * ```typescript
 * const cache = new TemplateCache();
 * const key = generateCacheKey(MyComponent, { name: 'John' });
 * const vnode = createVNode(...);
 * cache.set(key, vnode);
 * const cached = cache.get(key); // Returns vnode
 * ```
 */
export class TemplateCache {
  private cache = new Map<string, VNode>();
  private accessOrder = new Map<string, number>();
  private maxSize: number;
  private accessCounter = 0;

  // Statistics tracking
  private stats = {
    hits: 0,
    misses: 0,
  };

  /**
   * Create a new template cache
   *
   * @param maxSize - Maximum number of entries to cache (default: 1000)
   */
  constructor(maxSize = 1000) {
    this.maxSize = maxSize;
  }

  /**
   * Get cached VNode by key
   *
   * @param key - Cache key generated by generateCacheKey()
   * @returns Cached VNode or undefined if not found
   */
  get(key: string): VNode | undefined {
    const vnode = this.cache.get(key);

    if (vnode !== undefined) {
      // Update access order for LRU
      this.accessCounter++;
      this.accessOrder.set(key, this.accessCounter);
      this.stats.hits++;
      return vnode;
    }

    this.stats.misses++;
    return undefined;
  }

  /**
   * Cache a VNode with the given key
   *
   * If cache is at maximum size, removes the least recently used entry.
   *
   * @param key - Cache key generated by generateCacheKey()
   * @param vnode - VNode to cache
   */
  set(key: string, vnode: VNode): void {
    // Check if we need to evict an entry
    if (!this.cache.has(key) && this.cache.size >= this.maxSize) {
      this.evictLRU();
    }

    // Add/update entry
    this.cache.set(key, vnode);
    this.accessCounter++;
    this.accessOrder.set(key, this.accessCounter);
  }

  /**
   * Check if key exists in cache
   *
   * @param key - Cache key to check
   * @returns True if key exists in cache
   */
  has(key: string): boolean {
    return this.cache.has(key);
  }

  /**
   * Delete entry from cache
   *
   * @param key - Cache key to delete
   * @returns True if entry was deleted, false if it didn't exist
   */
  delete(key: string): boolean {
    this.accessOrder.delete(key);
    return this.cache.delete(key);
  }

  /**
   * Clear all cache entries
   */
  clear(): void {
    this.cache.clear();
    this.accessOrder.clear();
    this.accessCounter = 0;
  }

  /**
   * Get current cache statistics
   *
   * @returns Cache statistics including hits, misses, size, and hit rate
   */
  getStats(): CacheStats {
    const total = this.stats.hits + this.stats.misses;
    const hitRate = total === 0 ? 0 : (this.stats.hits / total) * 100;

    return {
      hits: this.stats.hits,
      misses: this.stats.misses,
      size: this.cache.size,
      hitRate: Math.round(hitRate * 100) / 100, // Round to 2 decimal places
    };
  }

  /**
   * Reset statistics counters
   *
   * Clears hit/miss counters but keeps cached entries.
   */
  resetStats(): void {
    this.stats.hits = 0;
    this.stats.misses = 0;
  }

  /**
   * Get current cache size
   *
   * @returns Number of cached entries
   */
  get size(): number {
    return this.cache.size;
  }

  /**
   * Get maximum cache size
   *
   * @returns Maximum number of entries allowed in cache
   */
  get maxCacheSize(): number {
    return this.maxSize;
  }

  /**
   * Set maximum cache size
   *
   * If new size is smaller than current size, evicts LRU entries.
   *
   * @param size - New maximum size
   */
  set maxCacheSize(size: number) {
    this.maxSize = size;
    // Evict entries if we're now over the limit
    while (this.cache.size > this.maxSize) {
      this.evictLRU();
    }
  }

  /**
   * Evict the least recently used entry
   */
  private evictLRU(): void {
    if (this.cache.size === 0) return;

    // Find the key with the lowest access counter
    let oldestKey: string | undefined;
    let oldestAccess = Infinity;

    for (const [key, access] of this.accessOrder.entries()) {
      if (access < oldestAccess) {
        oldestAccess = access;
        oldestKey = key;
      }
    }

    if (oldestKey !== undefined) {
      this.delete(oldestKey);
    }
  }
}

/**
 * Generate a stable cache key from component function and props
 *
 * Creates a deterministic key by combining:
 * 1. Component function name (or toString hash if anonymous)
 * 2. Serialized props (sorted keys for stability)
 *
 * @param component - Component function
 * @param props - Component props
 * @returns Cache key string
 *
 * @example
 * ```typescript
 * const key1 = generateCacheKey(MyComponent, { name: 'John', age: 30 });
 * const key2 = generateCacheKey(MyComponent, { age: 30, name: 'John' });
 * // key1 === key2 (props order doesn't matter)
 * ```
 */
export function generateCacheKey(component: (...args: any[]) => any, props: any): string {
  // Get component identifier
  const componentId = component.name || component.toString().slice(0, 50);

  // Serialize props in stable order
  let propsStr = '';
  if (props && typeof props === 'object') {
    // Sort keys for stable serialization
    const sortedKeys = Object.keys(props).sort();
    const pairs: string[] = [];

    for (const key of sortedKeys) {
      const value = props[key];

      // Skip functions and symbols (not serializable)
      if (typeof value === 'function' || typeof value === 'symbol') {
        continue;
      }

      // Handle different value types
      let valueStr: string;
      if (value === null) {
        valueStr = 'null';
      } else if (value === undefined) {
        valueStr = 'undefined';
      } else if (typeof value === 'object') {
        // For objects/arrays, use JSON.stringify
        try {
          valueStr = JSON.stringify(value);
        } catch {
          // Circular reference or unserializable - use toString
          valueStr = String(value);
        }
      } else {
        valueStr = String(value);
      }

      pairs.push(`${key}:${valueStr}`);
    }

    propsStr = pairs.join('|');
  }

  return `${componentId}#${propsStr}`;
}

/**
 * Singleton template cache instance
 *
 * Shared cache used by the component system for template caching.
 * Can be accessed for monitoring, clearing, or configuration.
 *
 * @example
 * ```typescript
 * // Check cache statistics
 * const stats = templateCache.getStats();
 * console.log(`Hit rate: ${stats.hitRate}%`);
 *
 * // Clear cache if needed
 * templateCache.clear();
 *
 * // Adjust max size
 * templateCache.maxCacheSize = 500;
 * ```
 */
export const templateCache = new TemplateCache();
