/**
 * Integration tests for Netron Middleware with Transports
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { Netron } from '../../../src/netron/netron.js';
import { RemotePeer } from '../../../src/netron/remote-peer.js';
import { createMockLogger } from '../test-utils.js';
import {
  globalMiddleware,
  type NetronMiddlewareContext,
  type MiddlewareFunction
} from '../../../src/netron/middleware/index.js';
import { TitanError, ErrorCode } from '../../../src/errors/index.js';
import { delay } from '@omnitron-dev/common';

describe('Middleware-Transport Integration', () => {
  let netron: Netron;
  let remotePeer: RemotePeer;
  let port = 28080;

  beforeEach(async () => {
    const logger = createMockLogger();
    // Use a different port for each test
    port++;
    netron = await Netron.create(logger, {
      id: 'middleware-test',
      listenHost: 'localhost',
      listenPort: port,
    });
  });

  afterEach(async () => {
    if (remotePeer) await remotePeer.disconnect();
    if (netron) await netron.stop();
    globalMiddleware.clear();
  });

  describe('HTTP Transport with Middleware', () => {
    it('should apply middleware to HTTP transport requests', async () => {
      const executionOrder: string[] = [];

      // Setup middleware
      const loggingMiddleware: MiddlewareFunction = async (ctx, next) => {
        executionOrder.push('logging-before');
        await next();
        executionOrder.push('logging-after');
      };

      const authMiddleware: MiddlewareFunction = async (ctx, next) => {
        executionOrder.push('auth');
        if (!ctx.metadata.get('authorization')) {
          throw new TitanError({ code: ErrorCode.UNAUTHORIZED });
        }
        await next();
      };

      // Add middleware globally
      globalMiddleware.use(loggingMiddleware, { name: 'logging', priority: 10 });
      globalMiddleware.use(authMiddleware, { name: 'auth', priority: 20 });

      // Expose a test service
      class TestService {
        async echo(input: string) {
          executionOrder.push('service-execution');
          return `Echo: ${input}`;
        }
      }

      const service = new TestService();
      // Add service metadata
      (service as any).__meta = { name: 'TestService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      // Add authorization to remote peer requests
      remotePeer.metadata.set('authorization', 'Bearer valid-token');

      // Call the service
      const remoteService = await remotePeer.getService('TestService');
      const result = await remoteService.echo('Hello');

      expect(result).toBe('Echo: Hello');
      expect(executionOrder).toContain('logging-before');
      expect(executionOrder).toContain('auth');
      expect(executionOrder).toContain('service-execution');
      expect(executionOrder).toContain('logging-after');
    });

    it('should handle middleware errors in HTTP transport', async () => {
      // Setup error middleware
      const errorMiddleware: MiddlewareFunction = async (ctx, next) => {
        throw new TitanError({ code: ErrorCode.INTERNAL_ERROR, message: 'Middleware error' });
      };

      globalMiddleware.use(errorMiddleware, { name: 'error', priority: 10 });

      // Expose a test service
      class TestService {
        async echo(input: string) {
          return `Echo: ${input}`;
        }
      }

      const service = new TestService();
      (service as any).__meta = { name: 'TestService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      // Call the service - should fail due to middleware
      const remoteService = await remotePeer.getService('TestService');

      await expect(remoteService.echo('Hello')).rejects.toThrow('Middleware error');
    });

    it('should support HTTP-specific middleware', async () => {
      const executionOrder: string[] = [];

      // HTTP-specific middleware that checks headers
      const httpMiddleware: MiddlewareFunction = async (ctx, next) => {
        executionOrder.push('http-middleware');
        // Check for HTTP-specific metadata
        const contentType = ctx.metadata.get('content-type');
        if (contentType) {
          executionOrder.push(`content-type: ${contentType}`);
        }
        await next();
      };

      globalMiddleware.use(httpMiddleware, {
        name: 'http-specific',
        priority: 10,
        filter: (ctx) => ctx.transport === 'http'
      });

      // Expose a test service
      class TestService {
        async process(data: any) {
          executionOrder.push('service-process');
          return { processed: true, data };
        }
      }

      const service = new TestService();
      (service as any).__meta = { name: 'TestService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      remotePeer.metadata.set('content-type', 'application/json');

      const remoteService = await remotePeer.getService('TestService');
      const result = await remoteService.process({ test: 'data' });

      expect(result).toEqual({ processed: true, data: { test: 'data' } });
      expect(executionOrder).toContain('http-middleware');
      expect(executionOrder).toContain('service-process');
    });
  });

  describe('WebSocket Transport with Middleware', () => {
    it('should apply middleware to WebSocket transport', async () => {
      const executionOrder: string[] = [];

      // Setup middleware for WebSocket
      const wsMiddleware: MiddlewareFunction = async (ctx, next) => {
        executionOrder.push('ws-middleware');
        await next();
      };

      globalMiddleware.use(wsMiddleware, {
        name: 'ws',
        priority: 10,
        filter: (ctx) => ctx.transport === 'websocket'
      });

      // Expose a test service
      class TestService {
        async process(data: any) {
          executionOrder.push('ws-service');
          return { ws: true, data };
        }
      }

      const service = new TestService();
      (service as any).__meta = { name: 'TestService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      // For WebSocket, we would need to connect with ws:// protocol
      // Since we're using HTTP server, we'll simulate this
      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      const remoteService = await remotePeer.getService('TestService');
      const result = await remoteService.process({ test: 'ws-data' });

      expect(result).toEqual({ ws: true, data: { test: 'ws-data' } });
      expect(executionOrder).toContain('ws-service');
    });

    it('should handle streaming with middleware in WebSocket', async () => {
      const chunks: any[] = [];

      // Streaming middleware
      const streamMiddleware: MiddlewareFunction = async (ctx, next) => {
        if (ctx.streaming) {
          chunks.push('stream-start');
        }
        await next();
        if (ctx.streaming) {
          chunks.push('stream-end');
        }
      };

      globalMiddleware.use(streamMiddleware, { name: 'stream', priority: 10 });

      // Expose a streaming service
      class StreamService {
        async *stream(count: number) {
          for (let i = 0; i < count; i++) {
            chunks.push(`yield-${i}`);
            yield i;
          }
        }
      }

      const service = new StreamService();
      (service as any).__meta = { name: 'StreamService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      const remoteService = await remotePeer.getService('StreamService');

      const results = [];
      for await (const value of remoteService.stream(3)) {
        results.push(value);
      }

      expect(results).toEqual([0, 1, 2]);
      expect(chunks).toContain('yield-0');
      expect(chunks).toContain('yield-1');
      expect(chunks).toContain('yield-2');
    });
  });

  describe('TCP Transport with Middleware', () => {
    it('should apply middleware to TCP transport', async () => {
      const executionOrder: string[] = [];

      // TCP-specific middleware
      const tcpMiddleware: MiddlewareFunction = async (ctx, next) => {
        executionOrder.push('tcp-middleware');
        await next();
      };

      globalMiddleware.use(tcpMiddleware, {
        name: 'tcp',
        priority: 10,
        filter: (ctx) => ctx.transport === 'tcp'
      });

      // Expose a test service
      class TcpService {
        async process(data: any) {
          executionOrder.push('tcp-service');
          return { tcp: true, data };
        }
      }

      const service = new TcpService();
      (service as any).__meta = { name: 'TcpService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      const remoteService = await remotePeer.getService('TcpService');
      const result = await remoteService.process({ test: 'tcp-data' });

      expect(result).toEqual({ tcp: true, data: { test: 'tcp-data' } });
      expect(executionOrder).toContain('tcp-service');
    });
  });

  describe('Multi-Stage Middleware', () => {
    it('should execute middleware in correct stages', async () => {
      const stages: string[] = [];

      // Pre-process middleware
      const preMiddleware: MiddlewareFunction = async (ctx, next) => {
        stages.push('pre-process');
        await next();
      };

      // Process middleware
      const processMiddleware: MiddlewareFunction = async (ctx, next) => {
        stages.push('process');
        await next();
      };

      // Post-process middleware
      const postMiddleware: MiddlewareFunction = async (ctx, next) => {
        stages.push('post-start');
        await next();
        stages.push('post-end');
      };

      globalMiddleware.use(preMiddleware, { name: 'pre', priority: 10, stage: 'pre' });
      globalMiddleware.use(processMiddleware, { name: 'process', priority: 20, stage: 'process' });
      globalMiddleware.use(postMiddleware, { name: 'post', priority: 30, stage: 'post' });

      // Expose service
      class StageService {
        async execute() {
          stages.push('service-execute');
          return 'done';
        }
      }

      const service = new StageService();
      (service as any).__meta = { name: 'StageService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      const remoteService = await remotePeer.getService('StageService');
      const result = await remoteService.execute();

      expect(result).toBe('done');
      expect(stages).toEqual([
        'pre-process',
        'process',
        'post-start',
        'service-execute',
        'post-end'
      ]);
    });
  });

  describe('Service-Specific Middleware', () => {
    it('should apply middleware to specific services', async () => {
      const calls: string[] = [];

      // Service-specific middleware
      const serviceMiddleware: MiddlewareFunction = async (ctx, next) => {
        if (ctx.service === 'ProtectedService') {
          calls.push('protected-middleware');
        }
        await next();
      };

      globalMiddleware.use(serviceMiddleware, {
        name: 'service-specific',
        priority: 10
      });

      // Expose multiple services
      class ProtectedService {
        async secure() {
          calls.push('protected-execute');
          return 'secure';
        }
      }

      class PublicService {
        async open() {
          calls.push('public-execute');
          return 'open';
        }
      }

      const protectedService = new ProtectedService();
      (protectedService as any).__meta = { name: 'ProtectedService', version: '1.0.0' };
      await netron.peer.exposeService(protectedService);

      const publicService = new PublicService();
      (publicService as any).__meta = { name: 'PublicService', version: '1.0.0' };
      await netron.peer.exposeService(publicService);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      // Call protected service
      const remoteProtected = await remotePeer.getService('ProtectedService');
      await remoteProtected.secure();

      // Call public service
      const remotePublic = await remotePeer.getService('PublicService');
      await remotePublic.open();

      expect(calls).toContain('protected-middleware');
      expect(calls).toContain('protected-execute');
      expect(calls).toContain('public-execute');
      expect(calls.filter(c => c === 'protected-middleware').length).toBe(1);
    });

    it('should apply middleware to specific methods', async () => {
      const calls: string[] = [];

      // Method-specific middleware
      const methodMiddleware: MiddlewareFunction = async (ctx, next) => {
        if (ctx.method === 'restricted') {
          calls.push('restricted-middleware');
        }
        await next();
      };

      globalMiddleware.use(methodMiddleware, {
        name: 'method-specific',
        priority: 10
      });

      // Expose service with multiple methods
      class MixedService {
        async restricted() {
          calls.push('restricted-execute');
          return 'restricted';
        }

        async unrestricted() {
          calls.push('unrestricted-execute');
          return 'unrestricted';
        }
      }

      const service = new MixedService();
      (service as any).__meta = { name: 'MixedService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      const remoteService = await remotePeer.getService('MixedService');

      await remoteService.restricted();
      await remoteService.unrestricted();

      expect(calls).toEqual([
        'restricted-middleware',
        'restricted-execute',
        'unrestricted-execute'
      ]);
    });
  });

  describe('Error Handling in Middleware', () => {
    it('should handle and transform errors in middleware', async () => {
      // Error transformation middleware
      const errorTransformMiddleware: MiddlewareFunction = async (ctx, next) => {
        try {
          await next();
        } catch (error: any) {
          if (error.code === ErrorCode.NOT_FOUND) {
            throw new TitanError({
              code: ErrorCode.NOT_IMPLEMENTED,
              message: 'Transformed: ' + error.message
            });
          }
          throw error;
        }
      };

      globalMiddleware.use(errorTransformMiddleware, { name: 'error-transform', priority: 10 });

      // Expose service that throws errors
      class ErrorService {
        async throwNotFound() {
          throw new TitanError({
            code: ErrorCode.NOT_FOUND,
            message: 'Original error'
          });
        }
      }

      const service = new ErrorService();
      (service as any).__meta = { name: 'ErrorService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      const remoteService = await remotePeer.getService('ErrorService');

      await expect(remoteService.throwNotFound()).rejects.toThrow('Transformed: Original error');
    });

    it('should use error stage middleware for error handling', async () => {
      const errorLog: string[] = [];

      // Error stage middleware
      const errorStageMiddleware: MiddlewareFunction = async (ctx, next) => {
        try {
          await next();
        } catch (error: any) {
          errorLog.push(`error-stage: ${error.message}`);
          throw error;
        }
      };

      globalMiddleware.use(errorStageMiddleware, {
        name: 'error-stage',
        priority: 10,
        stage: 'error'
      });

      // Expose service that throws
      class FailingService {
        async fail() {
          throw new Error('Service failure');
        }
      }

      const service = new FailingService();
      (service as any).__meta = { name: 'FailingService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      const remoteService = await remotePeer.getService('FailingService');

      await expect(remoteService.fail()).rejects.toThrow('Service failure');
      expect(errorLog).toContain('error-stage: Service failure');
    });
  });

  describe('Performance and Optimization', () => {
    it('should handle high-throughput with middleware efficiently', async () => {
      let callCount = 0;

      // Counting middleware
      const countingMiddleware: MiddlewareFunction = async (ctx, next) => {
        callCount++;
        await next();
      };

      globalMiddleware.use(countingMiddleware, { name: 'counter', priority: 10 });

      // Expose service
      class BenchmarkService {
        async process(index: number) {
          return index * 2;
        }
      }

      const service = new BenchmarkService();
      (service as any).__meta = { name: 'BenchmarkService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      const remoteService = await remotePeer.getService('BenchmarkService');

      const start = Date.now();
      const promises = [];
      const iterations = 100;

      for (let i = 0; i < iterations; i++) {
        promises.push(remoteService.process(i));
      }

      const results = await Promise.all(promises);
      const duration = Date.now() - start;

      expect(results.length).toBe(iterations);
      expect(callCount).toBe(iterations);
      expect(duration).toBeLessThan(5000); // Should complete within 5 seconds
    });

    it('should cache middleware results when appropriate', async () => {
      const cacheHits = { count: 0 };
      const cache = new Map();

      // Caching middleware
      const cacheMiddleware: MiddlewareFunction = async (ctx, next) => {
        const cacheKey = `${ctx.service}:${ctx.method}:${JSON.stringify(ctx.args)}`;

        if (cache.has(cacheKey)) {
          cacheHits.count++;
          ctx.result = cache.get(cacheKey);
          return; // Skip execution
        }

        await next();

        // Cache the result
        if (ctx.result !== undefined) {
          cache.set(cacheKey, ctx.result);
        }
      };

      globalMiddleware.use(cacheMiddleware, { name: 'cache', priority: 10 });

      // Expose service
      class CacheableService {
        async compute(n: number) {
          // Expensive computation
          await delay(10);
          return n * n;
        }
      }

      const service = new CacheableService();
      (service as any).__meta = { name: 'CacheableService', version: '1.0.0' };
      await netron.peer.exposeService(service);

      remotePeer = new RemotePeer(netron, `http://localhost:${port}`);
      await remotePeer.connect();

      const remoteService = await remotePeer.getService('CacheableService');

      // First call - should cache
      const result1 = await remoteService.compute(5);
      expect(result1).toBe(25);
      expect(cacheHits.count).toBe(0);

      // Second call - should hit cache
      const result2 = await remoteService.compute(5);
      expect(result2).toBe(25);
      expect(cacheHits.count).toBe(1);

      // Different argument - should not hit cache
      const result3 = await remoteService.compute(10);
      expect(result3).toBe(100);
      expect(cacheHits.count).toBe(1);

      // Repeat - should hit cache
      const result4 = await remoteService.compute(10);
      expect(result4).toBe(100);
      expect(cacheHits.count).toBe(2);
    });
  });
});