/**
 * Patching Engine - Applies VNode Diffs to DOM
 *
 * Takes patches generated by the diff algorithm and applies them
 * to the actual DOM efficiently. Handles all patch types:
 * - CREATE: Create new DOM nodes
 * - REMOVE: Remove existing nodes
 * - REPLACE: Replace nodes with new ones
 * - UPDATE: Update props/text content
 * - REORDER: Reorder children
 *
 * Part of the reconciliation engine - Phase 3 Diffing & Patching.
 */

import { VNode } from './vnode.js';
import { createDOMFromVNode } from './create-dom.js';
import { PatchType, type Patch, type PropPatch } from './diff.js';

/**
 * Patcher - Applies patches to DOM
 *
 * Central class for patch application. Maintains state during
 * patching and provides specialized methods for each patch type.
 */
export class Patcher {
  /**
   * Apply a single patch to the DOM
   *
   * Dispatches to specialized methods based on patch type.
   *
   * @param patchItem - Patch to apply
   */
  applyPatch(patchItem: Patch): void {
    switch (patchItem.type) {
      case PatchType.CREATE:
        this.patchCreate(patchItem);
        break;
      case PatchType.REMOVE:
        this.patchRemove(patchItem);
        break;
      case PatchType.REPLACE:
        this.patchReplace(patchItem);
        break;
      case PatchType.UPDATE:
        this.patchUpdate(patchItem);
        break;
      case PatchType.TEXT:
        this.patchText(patchItem);
        break;
      case PatchType.REORDER:
        this.patchReorder(patchItem);
        break;
      default:
        console.warn('Unknown patch type:', (patchItem as any).type);
    }
  }

  /**
   * Create new DOM node from VNode
   *
   * Creates DOM node and inserts it at the specified index
   * in the parent element.
   *
   * @param patchItem - CREATE patch
   */
  patchCreate(patchItem: Patch): void {
    if (!patchItem.newVNode) {
      console.warn('CREATE patch missing newVNode');
      return;
    }

    // Create DOM from VNode
    const dom = createDOMFromVNode(patchItem.newVNode);

    // Store DOM reference in VNode
    patchItem.newVNode.dom = dom;

    // Insert into parent if index specified
    // (Parent insertion is handled by parent's UPDATE patch)
  }

  /**
   * Remove DOM node
   *
   * Removes node from its parent and cleans up references.
   *
   * @param patchItem - REMOVE patch
   */
  patchRemove(patchItem: Patch): void {
    if (!patchItem.vnode || !patchItem.vnode.dom) {
      console.warn('REMOVE patch missing vnode or dom');
      return;
    }

    const dom = patchItem.vnode.dom;
    const parent = dom.parentNode;

    if (parent) {
      parent.removeChild(dom);
    }

    // Clean up VNode reference
    patchItem.vnode.dom = null;

    // Clean up effects
    if (patchItem.vnode.effects) {
      for (const effect of patchItem.vnode.effects) {
        if (effect.cleanup) {
          effect.cleanup();
        }
      }
      patchItem.vnode.effects = [];
    }
  }

  /**
   * Replace DOM node with new one
   *
   * Creates new DOM node and replaces old one in parent.
   *
   * @param patchItem - REPLACE patch
   */
  patchReplace(patchItem: Patch): void {
    if (!patchItem.vnode || !patchItem.newVNode || !patchItem.vnode.dom) {
      console.warn('REPLACE patch missing vnode, newVNode, or dom');
      return;
    }

    const oldDom = patchItem.vnode.dom;
    const parent = oldDom.parentNode;

    if (!parent) {
      console.warn('REPLACE patch: old node has no parent');
      return;
    }

    // Create new DOM
    const newDom = createDOMFromVNode(patchItem.newVNode);
    patchItem.newVNode.dom = newDom;

    // Replace in parent
    parent.replaceChild(newDom, oldDom);

    // Clean up old VNode
    patchItem.vnode.dom = null;
    if (patchItem.vnode.effects) {
      for (const effect of patchItem.vnode.effects) {
        if (effect.cleanup) {
          effect.cleanup();
        }
      }
      patchItem.vnode.effects = [];
    }
  }

  /**
   * Update node props and children
   *
   * Applies prop changes and recursively applies child patches.
   *
   * @param patchItem - UPDATE patch
   */
  patchUpdate(patchItem: Patch): void {
    if (!patchItem.vnode || !patchItem.newVNode) {
      console.warn('UPDATE patch missing vnode or newVNode');
      return;
    }

    const dom = patchItem.vnode.dom;
    if (!dom) {
      console.warn('UPDATE patch: vnode has no dom');
      return;
    }

    // Update props
    if (patchItem.props) {
      this.applyPropPatch(dom as HTMLElement | SVGElement, patchItem.props);
    }

    // Update VNode reference
    patchItem.newVNode.dom = dom;

    // Apply child patches
    if (patchItem.children && patchItem.children.length > 0) {
      this.applyChildPatches(dom as HTMLElement | SVGElement | DocumentFragment, patchItem.children);
    }
  }

  /**
   * Update text content
   *
   * Updates text node's content.
   *
   * @param patchItem - TEXT patch
   */
  patchText(patchItem: Patch): void {
    if (!patchItem.vnode || !patchItem.vnode.dom) {
      console.warn('TEXT patch missing vnode or dom');
      return;
    }

    const textNode = patchItem.vnode.dom as Text;
    if (patchItem.text !== undefined) {
      textNode.textContent = patchItem.text;
    }

    // Update VNode reference
    if (patchItem.newVNode) {
      patchItem.newVNode.dom = textNode;
    }
  }

  /**
   * Reorder children
   *
   * Moves child nodes to new positions without recreating them.
   *
   * @param patchItem - REORDER patch
   */
  patchReorder(patchItem: Patch): void {
    if (!patchItem.vnode || !patchItem.vnode.dom) {
      console.warn('REORDER patch missing vnode or dom');
      return;
    }

    const node = patchItem.vnode.dom;
    const parent = node.parentNode;

    if (!parent) {
      console.warn('REORDER patch: node has no parent');
      return;
    }

    // Get target position
    const targetIndex = patchItem.newIndex ?? 0;

    // Get the node currently at target position
    const currentNodes = Array.from(parent.childNodes);
    const referenceNode = currentNodes[targetIndex];

    // Only move if the node isn't already at the right position
    if (referenceNode !== node) {
      // Remove from current position
      parent.removeChild(node);

      // Get updated nodes after removal
      const updatedNodes = Array.from(parent.childNodes);
      const newReferenceNode = updatedNodes[targetIndex];

      // Insert at new position
      if (newReferenceNode) {
        parent.insertBefore(node, newReferenceNode);
      } else {
        parent.appendChild(node);
      }
    }

    // Update VNode reference
    if (patchItem.newVNode) {
      patchItem.newVNode.dom = node;
    }
  }

  /**
   * Apply prop changes to element
   *
   * Adds/updates/removes props based on PropPatch.
   *
   * @param element - Target element
   * @param propPatch - Prop changes to apply
   */
  private applyPropPatch(element: HTMLElement | SVGElement, propPatch: PropPatch): void {
    // Apply remove operations first (before setting new values)
    if (propPatch.remove) {
      for (const key of propPatch.remove) {
        this.removeProp(element, key);
      }
    }

    // Apply set operations (add/update)
    if (propPatch.set) {
      for (const [key, value] of Object.entries(propPatch.set)) {
        this.setProp(element, key, value);
      }
    }
  }

  /**
   * Set a single prop on element
   *
   * Handles special cases like events, style, class.
   *
   * @param element - Target element
   * @param key - Prop name
   * @param value - Prop value
   */
  private setProp(element: HTMLElement | SVGElement, key: string, value: any): void {
    // Skip internal props
    if (key === 'key' || key === 'children' || key === 'ref') {
      return;
    }

    // Handle event listeners
    if (key.startsWith('on') && key.length > 2) {
      const eventName = key.slice(2).toLowerCase();

      // Remove old listener if exists
      const oldListener = (element as any)[`__${key}`];
      if (oldListener) {
        element.removeEventListener(eventName, oldListener);
      }

      // Add new listener
      if (typeof value === 'function') {
        element.addEventListener(eventName, value);
        (element as any)[`__${key}`] = value;
      }
      return;
    }

    // Handle style object
    if (key === 'style' && typeof value === 'object') {
      for (const [styleKey, styleValue] of Object.entries(value)) {
        const cssKey = styleKey.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
        element.style.setProperty(cssKey, String(styleValue));
      }
      return;
    }

    // Handle className/class
    if (key === 'className' || key === 'class') {
      if (typeof value === 'string') {
        element.setAttribute('class', value);
      } else if (Array.isArray(value)) {
        element.setAttribute('class', value.filter(Boolean).join(' '));
      } else if (typeof value === 'object') {
        const classes = Object.entries(value)
          .filter(([, condition]) => condition)
          .map(([className]) => className)
          .join(' ');
        element.setAttribute('class', classes);
      }
      return;
    }

    // Handle boolean attributes
    if (typeof value === 'boolean') {
      if (value) {
        element.setAttribute(key, '');
      } else {
        element.removeAttribute(key);
      }
      return;
    }

    // Handle regular props
    if (key in element) {
      try {
        (element as any)[key] = value;
      } catch {
        element.setAttribute(key, String(value));
      }
    } else {
      element.setAttribute(key, String(value));
    }
  }

  /**
   * Remove a prop from element
   *
   * @param element - Target element
   * @param key - Prop name
   */
  private removeProp(element: HTMLElement | SVGElement, key: string): void {
    // Skip internal props
    if (key === 'key' || key === 'children' || key === 'ref') {
      return;
    }

    // Handle event listeners
    if (key.startsWith('on') && key.length > 2) {
      const eventName = key.slice(2).toLowerCase();
      const oldListener = (element as any)[`__${key}`];
      if (oldListener) {
        element.removeEventListener(eventName, oldListener);
        delete (element as any)[`__${key}`];
      }
      return;
    }

    // Handle style
    if (key === 'style') {
      element.removeAttribute('style');
      return;
    }

    // Handle class
    if (key === 'className' || key === 'class') {
      element.removeAttribute('class');
      return;
    }

    // Remove attribute (this is the key operation)
    element.removeAttribute(key);

    // NOTE: For reflected properties like 'id', removing the attribute
    // should automatically clear the property. In most DOM implementations,
    // the property mirrors the attribute. We don't need to explicitly
    // set element.id = '' because that would re-create an empty attribute.
    // The removeAttribute() call above is sufficient.
  }

  /**
   * Apply child patches
   *
   * Processes CREATE, REMOVE, and recursive patches for children.
   *
   * @param parent - Parent element
   * @param patches - Child patches to apply
   */
  private applyChildPatches(parent: HTMLElement | SVGElement | DocumentFragment, patches: Patch[]): void {
    // Group patches by type for efficient batching
    const creates: Patch[] = [];
    const removes: Patch[] = [];
    const reorders: Patch[] = [];
    const updates: Patch[] = [];

    for (const patchItem of patches) {
      if (patchItem.type === PatchType.CREATE) {
        creates.push(patchItem);
      } else if (patchItem.type === PatchType.REMOVE) {
        removes.push(patchItem);
      } else if (patchItem.type === PatchType.REORDER) {
        reorders.push(patchItem);
      } else {
        updates.push(patchItem);
      }
    }

    // Apply removals first (so indices are correct for creates)
    for (const patchItem of removes) {
      this.applyPatch(patchItem);
    }

    // Apply updates (before reordering)
    for (const patchItem of updates) {
      this.applyPatch(patchItem);
    }

    // Apply creates (before reordering)
    for (const patchItem of creates) {
      this.applyPatch(patchItem);

      // Insert into parent at specified index
      if (patchItem.newVNode && patchItem.newVNode.dom) {
        const index = patchItem.index ?? parent.childNodes.length;
        const referenceNode = parent.childNodes[index];

        if (referenceNode) {
          parent.insertBefore(patchItem.newVNode.dom, referenceNode);
        } else {
          parent.appendChild(patchItem.newVNode.dom);
        }
      }
    }

    // Apply reorders last (after all nodes exist)
    for (const patchItem of reorders) {
      this.patchReorder(patchItem);
    }
  }
}

/**
 * Transfer DOM references from old VNode tree to new VNode tree
 *
 * After patching, ensures all matching VNodes in the new tree have
 * their dom properties set by copying from the old tree. This is critical
 * for maintaining DOM references across patch cycles, especially for
 * key-based list reconciliation where children may not be explicitly patched.
 *
 * @param oldVNode - Old VNode tree (with dom references)
 * @param newVNode - New VNode tree (needs dom references)
 */
function transferDOMReferences(oldVNode: VNode | null, newVNode: VNode | null): void {
  if (!oldVNode || !newVNode) {
    return;
  }

  // Transfer dom reference if not already set
  if (!newVNode.dom && oldVNode.dom) {
    newVNode.dom = oldVNode.dom;
  }

  // Transfer children dom references
  if (oldVNode.children && newVNode.children) {
    // Build key maps for matching
    const oldKeyMap = new Map<string, VNode>();

    for (let i = 0; i < oldVNode.children.length; i++) {
      const child = oldVNode.children[i];
      if (!child) continue;
      const key = child.key !== undefined ? String(child.key) : `__index_${i}`;
      oldKeyMap.set(key, child);
    }

    for (let i = 0; i < newVNode.children.length; i++) {
      const child = newVNode.children[i];
      if (!child) continue;
      const key = child.key !== undefined ? String(child.key) : `__index_${i}`;

      // Transfer dom from matching old child
      const oldChild = oldKeyMap.get(key);
      if (oldChild && oldChild.dom && !child.dom) {
        child.dom = oldChild.dom;
      }

      // Recursively transfer for nested children
      if (oldChild) {
        transferDOMReferences(oldChild, child);
      }
    }
  }
}

/**
 * Main patch function - Apply patches to VNode tree
 *
 * Applies an array of patches to transform oldVNode tree to match
 * newVNode tree. Updates DOM and returns the updated VNode.
 *
 * @param oldVNode - Old VNode tree (current state)
 * @param patches - Patches to apply
 * @returns Updated VNode (newVNode from patches)
 *
 * @example
 * ```typescript
 * const oldTree = createElementVNode('div', { class: 'old' });
 * const newTree = createElementVNode('div', { class: 'new' });
 * const patches = diff(oldTree, newTree);
 * const updated = patch(oldTree, patches);
 * // DOM now reflects newTree state
 * ```
 */
export function patch(oldVNode: VNode | null, patches: Patch[]): VNode | null {
  if (patches.length === 0) {
    return oldVNode;
  }

  const patcher = new Patcher();

  // Apply each patch in order
  for (const p of patches) {
    patcher.applyPatch(p);
  }

  // Get the new VNode (from first patch with newVNode)
  const firstPatch = patches.find((p) => p.newVNode);
  const newVNode = firstPatch?.newVNode ?? oldVNode;

  // Ensure all DOM references are transferred to new tree
  // This is critical for maintaining DOM references across patch cycles,
  // especially for key-based list reconciliation where some children
  // may not have been explicitly patched but still need their dom refs.
  if (oldVNode && newVNode && newVNode !== oldVNode) {
    transferDOMReferences(oldVNode, newVNode);
  }

  return newVNode;
}

/**
 * Batch patch operations for performance
 *
 * Groups similar patches and applies them efficiently using
 * DocumentFragment for bulk inserts.
 *
 * @param patches - Patches to batch
 * @returns Batched patches
 */
export function batchPatches(patches: Patch[]): Patch[] {
  // For now, return patches as-is
  // Future optimization: group consecutive CREATE operations
  // into a single fragment insertion
  return patches;
}
