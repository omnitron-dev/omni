{
  "version": 3,
  "sources": ["../stubs/process-shim.js", "../../../common/src/primitives.ts", "../../../common/src/predicates.ts", "../../../common/src/omit.ts", "../../../common/src/entries.ts", "../../../common/src/promise.ts", "../../../common/src/p-limit.ts", "../../../common/src/timed-map.ts", "../../../common/src/list-buffer.ts", "../../../common/src/index.ts", "../../../../node_modules/long/index.js", "../../../../node_modules/base64-js/index.js", "../../../../node_modules/ieee754/index.js", "../../../../node_modules/buffer/index.js", "../../../smartbuffer/src/index.ts", "../../src/netron/constants.ts", "../../src/netron/uid.ts", "../../src/netron/packet/types.ts", "../../src/netron/packet/packet.ts", "../../../messagepack/src/encoder.ts", "../../../messagepack/src/decoder.ts", "../../../messagepack/src/serializer.ts", "../../../messagepack/src/errors.ts", "../../../messagepack/src/index.ts", "../../src/netron/reference.ts", "../../src/netron/definition.ts", "../stubs/stream.js", "../../src/netron/readable-stream.ts", "../../src/netron/writable-stream.ts", "../../src/netron/stream-reference.ts", "../../src/netron/packet/serializer.ts", "../../src/netron/packet/index.ts", "../../src/netron/client.ts", "../../src/netron/browser-netron-client.ts", "../../../eventemitter/src/index.ts", "../../../eventemitter/dist/types.js", "../../../eventemitter/src/emitter.ts", "../../../eventemitter/src/history.ts", "../../../eventemitter/src/metrics.ts", "../../../eventemitter/src/wildcard.ts", "../../../eventemitter/src/scheduler.ts", "../../../eventemitter/src/predicates.ts", "../../../eventemitter/src/enhanced-emitter.ts", "../../src/netron/clients/websocket-client.ts", "../../src/netron/browser-remote-peer.ts", "../../src/netron/utils.ts"],
  "sourcesContent": ["// Browser shim for Node.js process and setImmediate\nexport const process = {\n  env: { NODE_ENV: 'production' },\n  platform: 'browser',\n  version: 'v22.0.0',\n  cwd: () => '/',\n  nextTick: (fn) => Promise.resolve().then(fn)\n};\n\n// setImmediate shim (use setTimeout with 0 delay)\nexport const setImmediate = (fn, ...args) => {\n  return setTimeout(() => fn(...args), 0);\n};\n\nexport const clearImmediate = (id) => {\n  return clearTimeout(id);\n};\n\n// Inject into globalThis\nglobalThis.process = process;\nglobalThis.setImmediate = setImmediate;\nglobalThis.clearImmediate = clearImmediate;\n", "// A function that does nothing\nexport const noop = (...args: any[]) => {};\n\n// A function that returns the same value that is passed to it\nexport const identity = <T>(x: T): T => x;\n\n// A function that always returns true\nexport const truly = (...args: any[]): boolean => true;\n\n// A function that always returns false\nexport const falsely = (...args: any[]): boolean => false;\n\n// A function that converts a value to an array\n// If the value is null or undefined, it returns an empty array\n// If the value is already an array, it returns the value as is\n// Otherwise, it returns an array containing the value\nexport const arrify = <T>(val: T | T[] | undefined | null): T[] => {\n  if (val === null || val === undefined) {\n    return [];\n  }\n  return Array.isArray(val) ? val : [val];\n};\n", "const objectProto = Object.prototype;\nconst { hasOwnProperty } = objectProto;\nconst { toString } = objectProto;\nconst funcToString = Function.prototype.toString;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst objectCtorString = funcToString.call(Object);\nconst symToStringTag = Symbol.toStringTag;\n\n// Function to get the tag of a value\nexport const getTag = (value: any): string => {\n  if (value == null) {\n    return value === undefined ? '[object Undefined]' : '[object Null]';\n  }\n\n  // If the object has Symbol.toStringTag, use it directly\n  if (symToStringTag && symToStringTag in Object(value)) {\n    return toString.call(value);\n  }\n\n  // Otherwise, use the standard conversion\n  return toString.call(value);\n};\n\n// Function to get a simplified tag of a value\nexport const getTagSimple = (value: any) => {\n  const rawTag = toString.call(value);\n  if (value === null) {\n    return 'null';\n  }\n  return rawTag.substring(8, rawTag.length - 1).toLowerCase();\n};\n\n// Check if the platform is Windows\nexport const isWindows = process.platform === 'win32';\n// Check if the platform is Linux\nexport const linux = process.platform === 'linux';\n// Check if the platform is FreeBSD\nexport const freebsd = process.platform === 'freebsd';\n// Check if the platform is OpenBSD\nexport const openbsd = process.platform === 'openbsd';\n// Check if the platform is macOS\nexport const darwin = process.platform === 'darwin';\n// Check if the platform is SunOS\nexport const sunos = process.platform === 'sunos';\n// Check if the platform is AIX\nexport const aix = process.platform === 'aix';\n\n// Check if the environment is Node.js\nexport const isNodejs =\n  Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\n\n// Check if the value is an array\nexport const { isArray } = Array;\n\n// Check if the value is a function\nexport const isFunction = (value: any): boolean => typeof value === 'function';\n\n// Check if the value is a string\nexport const isString = (value: any): boolean => typeof value === 'string' || value instanceof String;\n\n// Check if the value is a number\nexport const isNumber = (value: any): boolean => typeof value === 'number';\n\n// Check if the value is a buffer\nexport const isBuffer = (obj: any): boolean =>\n  obj != null &&\n  ((Boolean(obj.constructor) && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)) ||\n    Boolean(obj._isBuffer));\n\n// Check if the value is a plain object\nexport const isPlainObject = (value: any): boolean => {\n  // Early return for null/undefined and non-objects\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  // Get the prototype\n  const proto = Object.getPrototypeOf(value);\n\n  // Objects created with Object.create(null) are plain objects\n  if (proto === null) {\n    return true;\n  }\n\n  // Check if it has Object.prototype as its direct prototype or\n  // if its prototype is Object.create(null)\n  const hasObjectPrototype = proto === Object.prototype || Object.getPrototypeOf(proto) === null;\n\n  if (!hasObjectPrototype) {\n    return false;\n  }\n\n  // Use toString to check the internal [[Class]]\n  const stringTag = objectProto.toString.call(value);\n\n  // Return true only if it's tagged as [object Object]\n  // This will exclude Arguments, Arrays, and other built-in types\n  return stringTag === '[object Object]';\n};\n\n// Checks whether `field` is a field owned by `object`.\nexport const isPropertyOwned = (obj: any, field: string) => hasOwnProperty.call(obj, field);\n\n// Checks whether given value is `null`.\nexport const isNull = (value: any) => value === null;\n\n// Checks whether given value is `undefined`.\nexport const isUndefined = (value: any) => value === undefined;\n\n// Checks whether given value is class\nexport const isClass = (value: any) =>\n  isFunction(value) &&\n  isPropertyOwned(value, 'prototype') &&\n  value.prototype &&\n  isPropertyOwned(value.prototype, 'constructor') &&\n  value.prototype.constructor.toString().substring(0, 5) === 'class';\n\n// Checks whether given value is `NaN`.\nexport const isNan = Number.isNaN;\n\n// Checks whether given value is a finite number.\nexport const { isFinite } = Number;\n\n// Checks whether given value is an integer.\nexport const { isInteger } = Number;\n\n// Checks whether given value is a safe integer.\nexport const { isSafeInteger } = Number;\n\n// Checks whether given value exists, i.e, not `null` nor `undefined`\nexport const isExist = (value: any) => value != null;\n\n// Checks whether given value is either `null` or `undefined`\nexport const isNil = (value: any) => value == null;\n\n// Checks whether given value is an empty string, i.e, a string with whitespace characters only.\nexport const isEmptyString = (str: any) => typeof str === 'string' && /^\\s*$/.test(str);\n\n// Checks whether given value is a numeral, i.e:\n// - a genuine finite number\n// - or a string that represents a finite number\nexport const isNumeral = (value: any) => {\n  const tag = getTagSimple(value);\n  if (tag !== 'number' && tag !== 'string') {\n    return false;\n  }\n\n  if (isEmptyString(value)) {\n    return false;\n  }\n\n  try {\n    value = Number(value);\n  } catch {\n    return false;\n  }\n\n  return isFinite(value);\n};\n\n// Checks whether given value is a BigInt\nexport const isBigInt = (value: unknown): value is bigint => typeof value === 'bigint';\n\n// Checks whether given value is a numeral BigInt\nexport const isNumeralBigInt = (value: string) => {\n  if (typeof value !== 'string') return false;\n  return /^-?\\d+n$/.test(value) && value !== 'n' && value !== '-n';\n};\n\n// Checks whether given value is a numeral integer\nexport const isNumeralInteger = (value: any) => {\n  const tag = getTagSimple(value);\n  if (tag !== 'number' && tag !== 'string') {\n    return false;\n  }\n\n  if (isEmptyString(value)) {\n    return false;\n  }\n\n  try {\n    value = Number(value);\n  } catch {\n    return false;\n  }\n\n  return Number.isInteger(value);\n};\n\n// Checks whether given value is an infinite number, i.e: +\u221E or -\u221E.\nexport const isInfinite = (val: any) => val === +1 / 0 || val === -1 / 0;\n\n// Checks whether given value is an odd number.\nexport const isOdd = (val: any) => isInteger(val) && val % 2 === 1;\n\n// Checks whether given value is an even number.\nexport const isEven = (val: any) => isInteger(val) && val % 2 === 0;\n\n// Checks whether given value is a float number.\nexport const isFloat = (val: any) => isNumber(val) && val !== Math.floor(val);\n\n// Checks whether given value is negative zero.\nexport const isNegativeZero = (val: any) => val === 0 && Number.NEGATIVE_INFINITY === 1 / val;\n\n// Checks whether `substr` is a substring of `str` starting from `offset`.\nexport const isSubstring = (substr: string, str: string, offset?: number) => {\n  // Type checking\n  if (typeof substr !== 'string' || typeof str !== 'string') {\n    return false;\n  }\n\n  // Special case for empty strings\n  if (substr === '') {\n    return true;\n  }\n\n  const { length } = str;\n\n  // If the string is empty but the substring is not\n  if (length === 0) {\n    return false;\n  }\n\n  // Convert offset to a number or use 0\n  let normalizedOffset = 0;\n  if (offset !== undefined) {\n    normalizedOffset = Number(offset);\n    // Any NaN or invalid value is converted to 0\n    if (!Number.isFinite(normalizedOffset)) {\n      normalizedOffset = 0;\n    }\n  }\n\n  // Handle negative offset\n  if (normalizedOffset < 0) {\n    normalizedOffset = length + normalizedOffset;\n  }\n\n  // Boundary check\n  if (normalizedOffset < 0) {\n    normalizedOffset = 0;\n  }\n\n  // If the offset is greater than or equal to the string length, search is impossible\n  if (normalizedOffset >= length) {\n    return false;\n  }\n\n  // Search for the substring starting from the correct offset\n  const result = str.indexOf(substr, normalizedOffset);\n  return result !== -1;\n};\n\n// Checks whether `str` starts with `prefix`.\nexport const isPrefix = (prefix: string, str: string) => {\n  if (typeof str !== 'string' || typeof prefix !== 'string') return false;\n  return str.startsWith(prefix);\n};\n\n// Checks whether `str` ends with `suffix`.\nexport const isSuffix = (suffix: string, str: string) => {\n  if (typeof str !== 'string' || typeof suffix !== 'string') return false;\n  return str.endsWith(suffix);\n};\n\n// Checks whether given value is a boolean.\nexport const isBoolean = (value: any) => value === true || value === false;\n\n// Checks whether given value is an ArrayBuffer.\nexport const isArrayBuffer = (x: any) => objectProto.toString.call(x) === '[object ArrayBuffer]';\n\n// Checks whether given value is an ArrayBufferView.\nexport const isArrayBufferView = (x: any) => ArrayBuffer.isView(x);\n\n// Checks whether given value is a Date.\nexport const isDate = (x: any) => getTagSimple(x) === 'date';\n\n// Checks whether given value is an Error.\nexport const isError = (value: any) => getTagSimple(value) === 'error';\n\n// Checks whether given value is a Map.\nexport const isMap = (value: any) => getTagSimple(value) === 'map';\n\n// Checks whether given value is a RegExp.\nexport const isRegexp = (value: any) => getTagSimple(value) === 'regexp';\n\n// Checks whether given value is a Set.\nexport const isSet = (value: any) => getTagSimple(value) === 'set';\n\n// Checks whether given value is a Symbol.\nexport const isSymbol = (value: any) => getTagSimple(value) === 'symbol';\n\n// Checks whether given value is a primitive.\nexport const isPrimitive = (value: any) =>\n  isNil(value) || isNumber(value) || typeof value === 'string' || isBoolean(value) || isSymbol(value);\n\n// Checks whether given value is an object.\nexport const isObject = (value: any) => !isPrimitive(value);\n\n// Checks whether given value is an empty object, i.e, an object without any own, enumerable, string keyed properties.\nexport const isEmptyObject = (obj: any): boolean => isObject(obj) && Object.keys(obj).length === 0;\n\n// Checks whether `path` is a direct or inherited property of `object`.\nexport const isPropertyDefined = (obj: any, path: string) => {\n  if (!path || typeof path !== 'string') return false;\n  if (!isObject(obj)) return false;\n\n  let context = obj;\n  const keys = path.split('.');\n\n  for (const key of keys) {\n    if (!isObject(context) || !(key in context)) {\n      return false;\n    }\n    context = context[key];\n  }\n\n  return true;\n};\n\n// Checks whether given function is an async function.\nexport const isAsyncFunction = (fn: any) => fn && toString.call(fn).slice(8, -1) === 'AsyncFunction';\n\n/**\n * Determines whether the provided object is an AsyncGenerator.\n * This predicate is used to identify async generator functions that can be streamed\n * over the network in the Netron system.\n *\n * @param {any} obj - The object to be evaluated for AsyncGenerator membership\n * @returns {boolean} Returns true if the object is an AsyncGenerator, false otherwise\n * @example\n * async function* generate() { yield 1; }\n * const gen = generate();\n * isAsyncGenerator(gen); // returns true\n */\nexport const isAsyncGenerator = (obj: any): obj is AsyncGenerator =>\n  !!(\n    obj &&\n    typeof obj === 'object' &&\n    typeof obj.next === 'function' &&\n    typeof obj.return === 'function' &&\n    typeof obj.throw === 'function' &&\n    typeof obj[Symbol.asyncIterator] === 'function'\n  );\n\n// Checks whether given value is a Promise.\nexport const isPromise = (obj: any) => !isNil(obj) && isFunction(obj.then);\n", "import { falsely } from './primitives.js';\nimport { isArray, isObject, isString, isFunction } from './predicates.js';\n\n// Define the options for the omit function\ntype OmitOptions = {\n  deep?: boolean; // If true, omit properties deeply\n  pattern?: boolean; // If true, use pattern matching\n  path?: boolean; // If true, interpret strings as paths\n};\n\n// Define the type for the predicate function used in omit\ntype OmitPredicate = (key: string | symbol, value: any, object: any) => boolean;\n\n// Main function to omit properties from an object\nexport const omit = (obj?: any, options?: any, omitOptions?: OmitOptions): Record<string | symbol, any> => {\n  // Return an empty object if the input is not an object\n  if (!isObject(obj)) {\n    return {};\n  }\n\n  let isShouldOmit: OmitPredicate;\n\n  // Determine the predicate function based on the type of options\n  if (isFunction(options)) {\n    // If options is a function, use it directly as the predicate\n    isShouldOmit = (key: string | symbol, value: any, object: any) =>\n      (options as (key: string | symbol, value: any, object: any) => boolean)(key, value, object);\n  } else if (isArray(options)) {\n    // If options is an array, create a set for quick lookup\n    if (omitOptions?.path) {\n      // If path option is true, handle dot notation paths\n      return options.reduce(\n        (acc, path) => {\n          if (isString(path) && path.includes('.')) {\n            return omitByPath(acc, path.split('.'));\n          }\n          const optionsSet = new Set([path]);\n          return omit(acc, (name: string | symbol) => optionsSet.has(name));\n        },\n        { ...obj }\n      );\n    }\n    const optionsSet = new Set(options);\n    isShouldOmit = (name: string | symbol) => optionsSet.has(name);\n  } else if (isString(options)) {\n    // If options is a string, check for dot notation\n    if (options.includes('.') && omitOptions?.path) {\n      const paths = options.split('.');\n      return omitByPath(obj, paths);\n    } else {\n      isShouldOmit = (val: string | symbol) => val.toString() === options;\n    }\n  } else if (options instanceof RegExp) {\n    // If options is a RegExp, use it to test keys\n    isShouldOmit = (key: string | symbol) => options.test(key.toString());\n  } else if (options === true) {\n    // If options is true, omit all properties\n    return {};\n  } else if (!options) {\n    // If no options are provided, use a default predicate\n    isShouldOmit = falsely;\n  } else {\n    // Throw an error for invalid options type\n    throw new Error('Invalid options type');\n  }\n\n  // Get all property names and symbols of the object\n  const list: (string | symbol)[] = [...Object.getOwnPropertyNames(obj), ...Object.getOwnPropertySymbols(obj)];\n\n  const result: Record<string | symbol, any> = {};\n\n  // Iterate over each property\n  for (let i = 0; i < list.length; i += 1) {\n    const key = list[i];\n    if (key === undefined) continue; // Added to fix an error\n\n    const val = obj[key as keyof typeof obj];\n\n    // Check if the property should be omitted\n    if (!isShouldOmit(key, val, obj)) {\n      const descr = Object.getOwnPropertyDescriptor(obj, key as PropertyKey);\n      if (descr) {\n        // If deep option is true and the value is an object, omit deeply\n        if (omitOptions?.deep && isObject(val)) {\n          Object.defineProperty(result, key as PropertyKey, {\n            ...descr,\n            value: omit(val, options, omitOptions),\n          });\n        } else {\n          // Otherwise, copy the property descriptor\n          Object.defineProperty(result, key as PropertyKey, descr);\n        }\n      }\n    }\n  }\n  return result;\n};\n\n// Helper function to handle dot notation paths\nfunction omitByPath(obj: any, paths: string[]): any {\n  if (!isObject(obj)) return obj;\n  if (paths.length === 0) return obj;\n\n  const [current, ...rest] = paths;\n  const result = { ...obj };\n\n  if (rest.length === 0) {\n    // Delete the property if it's the last in the path\n    delete result[current as keyof typeof result];\n  } else if (isObject(obj[current as keyof typeof obj])) {\n    // Recursively handle nested objects\n    result[current as keyof typeof result] = omitByPath(obj[current as keyof typeof obj], rest);\n  }\n\n  return result;\n}\n", "import { isNil } from './predicates.js';\n\n// Cache the own property names of a plain object prototype to filter out later\nconst objectOwnProps = Object.getOwnPropertyNames(Object.getPrototypeOf({}));\n\n/**\n * Retrieves the keys of an object based on the specified options.\n *\n * @param {any} obj - The object from which to retrieve keys.\n * @param {boolean} enumOnly - If true, only enumerable keys are retrieved.\n * @param {boolean} followProto - If true, keys from the prototype chain are included.\n * @returns {string[]} - An array of keys.\n */\nconst _keys = (obj: any, enumOnly: boolean, followProto: boolean): string[] => {\n  // If not following the prototype chain, return keys based on enumOnly flag\n  if (!followProto) {\n    return enumOnly ? Object.keys(obj) : Object.getOwnPropertyNames(obj);\n  }\n\n  const props: string[] = []; // Array to store the keys\n  const seen = new Set<string>(); // Set to track seen keys\n\n  // Collect properties starting from the furthest prototype\n  const protoChain: any[] = [];\n  let current = obj;\n  while (current) {\n    protoChain.unshift(current); // Add current object to the beginning of the chain\n    current = Object.getPrototypeOf(current); // Move up the prototype chain\n  }\n\n  // Process each object in the prototype chain\n  for (const proto of protoChain) {\n    const keys = enumOnly\n      ? Object.keys(proto) // Get enumerable keys\n      : Object.getOwnPropertyNames(proto); // Get all keys\n\n    for (const key of keys) {\n      // Add key if it hasn't been seen and isn't a default object property\n      if (!seen.has(key) && !objectOwnProps.includes(key)) {\n        seen.add(key);\n        props.push(key);\n      }\n    }\n  }\n\n  return props;\n};\n\n/**\n * Retrieves the keys of an object based on the specified options.\n *\n * @param {any} obj - The object from which to retrieve keys.\n * @param {Object} options - Options to modify behavior.\n * @param {boolean} [options.enumOnly=true] - If true, only enumerable keys are retrieved.\n * @param {boolean} [options.followProto=false] - If true, keys from the prototype chain are included.\n * @param {boolean} [options.all=false] - If true, overrides other options to include all keys.\n * @returns {string[]} - An array of keys.\n */\nexport const keys = (obj: any, { enumOnly = true, followProto = false, all = false } = {}): string[] => {\n  // Return empty array if object is null or undefined\n  if (isNil(obj)) {\n    return [];\n  }\n\n  // If 'all' option is true, set flags to include all keys\n  if (all) {\n    enumOnly = false;\n    followProto = true;\n  }\n\n  return _keys(obj, enumOnly, followProto);\n};\n\n/**\n * Retrieves the values of an object based on the specified options.\n *\n * @param {any} obj - The object from which to retrieve values.\n * @param {Object} options - Options to modify behavior.\n * @param {boolean} [options.enumOnly=true] - If true, only values of enumerable keys are retrieved.\n * @param {boolean} [options.followProto=false] - If true, values from the prototype chain are included.\n * @param {boolean} [options.all=false] - If true, overrides other options to include all values.\n * @returns {any[]} - An array of values.\n */\nexport const values = (obj: any, { enumOnly = true, followProto = false, all = false } = {}): any[] => {\n  // Return empty array if object is null or undefined\n  if (isNil(obj)) {\n    return [];\n  }\n\n  // If 'all' option is true, set flags to include all values\n  if (all) {\n    enumOnly = false;\n    followProto = true;\n  }\n\n  // If not following prototype and only enumerable, use Object.values\n  if (!followProto && enumOnly) {\n    return Object.values(obj);\n  }\n\n  // Map keys to their corresponding values\n  return _keys(obj, enumOnly, followProto).map((key) => obj[key]);\n};\n\n/**\n * Retrieves the entries of an object based on the specified options.\n *\n * @param {any} obj - The object from which to retrieve entries.\n * @param {Object} options - Options to modify behavior.\n * @param {boolean} [options.enumOnly=true] - If true, only entries of enumerable keys are retrieved.\n * @param {boolean} [options.followProto=false] - If true, entries from the prototype chain are included.\n * @param {boolean} [options.all=false] - If true, overrides other options to include all entries.\n * @returns {Array<[string, any]>} - An array of key-value pairs.\n */\nexport const entries = (obj: any, { enumOnly = true, followProto = false, all = false } = {}): Array<[string, any]> => {\n  // Return empty array if object is null or undefined\n  if (isNil(obj)) {\n    return [];\n  }\n\n  // If 'all' option is true, set flags to include all entries\n  if (all) {\n    enumOnly = false;\n    followProto = true;\n  }\n\n  // Map keys to key-value pairs\n  return _keys(obj, enumOnly, followProto).map((key) => [key, obj[key]]);\n};\n", "import { entries } from './entries.js';\nimport { noop, truly } from './primitives.js';\nimport { isNumber, isPromise, isFunction } from './predicates.js';\n\n// Define the Deferred type\nexport type Deferred = {\n  resolve?: (value: any) => void;\n  reject?: (reason?: any) => void;\n  promise?: Promise<any>;\n};\n\n/**\n * @typedef Deferred\n * @property {Function} resolve\n * @property {Function} reject\n * @property {Promise} promise\n */\n\n/**\n * Creates a promise and returns an interface to control the state\n *\n * @returns {Deferred} An object containing the promise and methods to resolve or reject it\n */\nexport const defer = (): Deferred => {\n  const deferred: Deferred = {};\n\n  deferred.promise = new Promise((resolve, reject) => {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n\n  return deferred;\n};\n\n/**\n * Returns a promise that will be resolved after given milliseconds\n *\n * @template T\n * @param {number} ms delay in milliseconds\n * @param {T} [value] resolving value\n * @param {object} [options] Additional options\n * @param {boolean} [options.unref] Whether to allow the process to exit if only the timeout remains\n * @returns {Promise<T>} A promise that resolves with the given value after the specified delay\n */\nexport const delay = <T>(ms: number, value?: T, options?: { unref?: boolean }): Promise<T> =>\n  new Promise((resolve) => {\n    const timer = setTimeout(resolve, ms, value);\n    if (options?.unref && typeof (timer as any).unref === 'function') {\n      (timer as any).unref();\n    }\n  });\n\ninterface TimeoutOptions {\n  unref?: boolean;\n  signal?: AbortSignal;\n}\n\n/**\n * Creates a promise that will be rejected after given milliseconds if the given promise is not fulfilled\n *\n * @template T Type of the promise result\n * @param {Promise<T>} promise Promise to wrap\n * @param {number} ms Timeout in milliseconds\n * @param {TimeoutOptions} [options] Additional options\n * @param {boolean} [options.unref] Whether to allow the process to exit if only the timeout remains\n * @param {AbortSignal} [options.signal] AbortSignal to cancel the timeout\n * @returns {Promise<T>} Promise that will be rejected if the timeout is exceeded\n * @throws {TypeError} If the first argument is not a promise or timeout is invalid\n * @example\n * ```typescript\n * // Basic usage\n * const result = await timeout(fetch('https://api.example.com'), 5000);\n *\n * // With unref option\n * const result = await timeout(longOperation(), 1000, { unref: true });\n *\n * // With abort signal\n * const controller = new AbortController();\n * const result = await timeout(fetch('https://api.example.com'), 5000, {\n *   signal: controller.signal\n * });\n * // Later...\n * controller.abort();\n * ```\n */\nexport const timeout = <T>(promise: Promise<T>, ms: number, options: TimeoutOptions = {}): Promise<T> => {\n  if (!isPromise(promise)) {\n    throw new TypeError('The first argument must be a promise');\n  }\n  if (!isNumber(ms) || ms <= 0) {\n    throw new TypeError('Timeout must be a positive number');\n  }\n\n  return new Promise<T>((resolve, reject) => {\n    let timeoutId: ReturnType<typeof setTimeout> | null;\n\n    const cleanup = () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId as any);\n        timeoutId = null;\n      }\n      if (options.signal) {\n        options.signal.removeEventListener('abort', onAbort);\n      }\n    };\n\n    const onAbort = () => {\n      cleanup();\n      reject(new Error('Timeout aborted'));\n    };\n\n    if (options.signal) {\n      if (options.signal.aborted) {\n        onAbort();\n        return;\n      }\n      options.signal.addEventListener('abort', onAbort, { once: true });\n    }\n\n    timeoutId = setTimeout(() => {\n      cleanup();\n      reject(new Error(`Timeout of ${ms}ms exceeded`));\n    }, ms);\n\n    if (options.unref && timeoutId && typeof (timeoutId as any).unref === 'function') {\n      (timeoutId as any).unref();\n    }\n\n    promise.then(\n      (value) => {\n        cleanup();\n        resolve(value);\n      },\n      (error) => {\n        cleanup();\n        reject(error);\n      }\n    );\n  });\n};\n\n/**\n * Converts a promise to node.js style callback\n *\n * @param {Promise} promise The promise to convert\n * @param {Function} cb The callback function\n * @returns {Promise} The original promise\n */\nexport const nodeify = <T>(promise: Promise<T>, cb: (err: any, result?: T) => void): Promise<T> => {\n  if (!isPromise(promise)) {\n    throw new TypeError('The first argument must be a promise');\n  }\n  if (!isFunction(cb)) {\n    return promise;\n  }\n  promise.then(\n    (x) => {\n      cb(null, x);\n    },\n    (y) => {\n      cb(y);\n    }\n  );\n  return promise;\n};\n\n/**\n * Converts a function that returns promises to a node.js style callback function\n *\n * @param {Function} fn Function to convert\n * @returns {Function} The converted function\n */\nexport const callbackify = <T>(fn: (...args: any[]) => Promise<T>): ((...args: any[]) => any) => {\n  if (!isFunction(fn)) {\n    throw new TypeError('The first argument must be a function');\n  }\n  return function _(this: any, ...args: any[]) {\n    if (args.length && isFunction(args[args.length - 1])) {\n      const cb = args.pop();\n      return nodeify(fn.apply(this, args), cb);\n    }\n    return fn.apply(this, args);\n  };\n};\n\n/**\n * Helper function to process a function with a callback\n *\n * @param {Function} fn Function to process\n * @param {any} context Context to bind to the function\n * @param {any[]} args Arguments to pass to the function\n * @param {boolean} multiArgs Whether to handle multiple arguments\n * @param {Function} resolve Resolve function of the promise\n * @param {Function} reject Reject function of the promise\n */\nconst processFn = (\n  fn: (...args: any[]) => void,\n  context: any,\n  args: any[],\n  multiArgs: boolean,\n  resolve: (value?: any) => void,\n  reject: (reason?: any) => void\n) => {\n  if (multiArgs) {\n    args.push((...result: any[]) => {\n      if (result[0]) {\n        reject(result);\n      } else {\n        result.shift();\n        resolve(result);\n      }\n    });\n  } else {\n    args.push((err: any, result: any) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  }\n  fn.apply(context, args);\n};\n\n/**\n * Converts a callback function to a promise-based function\n *\n * @param {Function} fn The function to convert\n * @param {object} [options] Options to configure the promisified function\n * @param {any} [options.context] Context to bind to the function\n * @param {boolean} [options.multiArgs] Whether to handle multiple arguments\n * @returns {Function} The promisified function\n */\nexport const promisify = (\n  fn: (...args: any[]) => void,\n  options?: { context?: any; multiArgs?: boolean }\n): ((...args: any[]) => Promise<any>) => {\n  if (!isFunction(fn)) {\n    throw new TypeError('The first argument must be a function');\n  }\n\n  return options && options.context\n    ? (...args: any[]) =>\n      new Promise((resolve, reject) => {\n        processFn(fn, options.context, args, options && Boolean(options.multiArgs), resolve, reject);\n      })\n    : function _(this: any, ...args: any[]) {\n      return new Promise((resolve, reject) => {\n        processFn(fn, this, args, Boolean(options?.multiArgs), resolve, reject);\n      });\n    };\n};\n\n/**\n * Promisifies entire object\n *\n * @param {object} source The object to promisify\n * @param {object} [options] Options to configure the promisified functions\n * @param {string} [options.suffix] Suffix to append to the promisified function names\n * @param {Function} [options.filter] Filter function to determine which functions to promisify\n * @param {any} [options.context] Context to bind to the functions\n * @returns {object} Object with promisified functions\n */\nexport const promisifyAll = (\n  source: any,\n  options?: { suffix?: string; filter?: (key: string) => boolean; context?: any }\n): any => {\n  const suffix = options && options.suffix ? options.suffix : 'Async';\n  const filter = options && typeof options.filter === 'function' ? options.filter : truly;\n\n  if (isFunction(source)) {\n    return promisify(source, options);\n  }\n\n  const target = Object.create(source);\n\n  for (const [key, value] of entries(source, { all: true })) {\n    if (isFunction(value) && filter(key)) {\n      target[`${key}${suffix}`] = promisify(value, options);\n    }\n  }\n  return target;\n};\n\n/**\n * Executes function after promise fulfillment\n *\n * @param {Promise} promise The promise to wrap\n * @param {Function} onFinally The callback to call\n * @returns {Promise} A promise that will be fulfilled using the original value\n */\nconst _finally = <T>(promise: Promise<T>, onFinally: () => void): Promise<T> => {\n  onFinally = onFinally || noop;\n\n  return promise.then(\n    (val) =>\n      new Promise((resolve) => {\n        resolve(onFinally());\n      }).then(() => val),\n    (err) =>\n      new Promise((resolve) => {\n        resolve(onFinally());\n      }).then(() => {\n        throw err;\n      })\n  );\n};\n\nexport { _finally as finally };\n\nexport interface RetryOptions {\n  max: number;\n  timeout?: number;\n  match?: Array<string | RegExp | (new (...args: any[]) => any)>;\n  backoffBase?: number;\n  backoffExponent?: number;\n  report?: (message: string, options: any, error?: Error) => void;\n  name?: string;\n  $current?: number;\n}\n\n/**\n * Retries a function until it succeeds or the maximum number of attempts is reached\n *\n * @param {Function} callback The function to retry\n * @param {RetryOptions|number} options Options to configure the retry behavior or the maximum number of attempts\n * @returns {Promise} A promise that resolves with the result of the function or rejects with the last error\n * @throws {Error} If the callback or options are not provided\n */\nexport const retry = async <T>(\n  callback: (options: { current: number }) => Promise<T> | T,\n  options: RetryOptions | number\n): Promise<T> => {\n  if (!callback || !options) {\n    throw new Error('requires a callback and an options set or a number');\n  }\n\n  const opts: RetryOptions = isNumber(options) ? { max: options as number } : (options as RetryOptions);\n\n  const config = {\n    $current: opts.$current || 1,\n    max: opts.max,\n    timeout: opts.timeout,\n    match: Array.isArray(opts.match) ? opts.match : opts.match ? [opts.match] : [],\n    backoffBase: opts.backoffBase ?? 100,\n    backoffExponent: opts.backoffExponent || 1.1,\n    report: opts.report || null,\n    name: opts.name || callback.name || 'unknown',\n  };\n\n  const shouldRetry = (error: Error, attempt: number): boolean => {\n    if (attempt >= config.max) return false;\n\n    if (config.match.length === 0) return true;\n\n    return config.match.some(\n      (match) =>\n        match === error.toString() ||\n        match === error.message ||\n        (isFunction(match) && error instanceof (match as new (...args: any[]) => any)) ||\n        (match instanceof RegExp && (match.test(error.message) || match.test(error.toString())))\n    );\n  };\n\n  let lastError: Error | null = null;\n\n  while (true) {\n    try {\n      if (config.report) {\n        config.report(`Attempt ${config.name} #${config.$current}`, config);\n      }\n\n      let result = callback({ current: config.$current });\n\n      if (isPromise(result)) {\n        if (config.timeout) {\n          result = await timeout(result as Promise<T>, config.timeout);\n        } else {\n          result = await result;\n        }\n      }\n\n      if (config.report) {\n        config.report(`Success ${config.name} #${config.$current}`, config);\n      }\n\n      return result;\n    } catch (error: any) {\n      lastError = error;\n\n      if (config.report) {\n        config.report(`Failed ${config.name} #${config.$current}: ${error.toString()}`, config, error);\n      }\n\n      if (!shouldRetry(error, config.$current)) {\n        throw lastError;\n      }\n\n      const retryDelay = Math.floor(config.backoffBase * Math.pow(config.backoffExponent ?? 1.1, config.$current - 1));\n\n      config.$current++;\n\n      if (retryDelay > 0) {\n        if (config.report) {\n          config.report(`Delaying retry of ${config.name} by ${retryDelay}ms`, config);\n        }\n        await delay(retryDelay);\n      }\n    }\n  }\n};\n\n/**\n * Resolves an object of promises\n *\n * @param {object} obj Object with promises\n * @returns {Promise<object>} Object with resolved values\n */\nexport const props = async (obj: any): Promise<any> => {\n  const result: any = {};\n  await Promise.all(\n    Object.keys(obj).map(async (key) => {\n      Object.defineProperty(result, key, {\n        enumerable: true,\n        value: await obj[key],\n      });\n    })\n  );\n  return result;\n};\n\n/**\n * Tries to execute a function and resolves its result\n *\n * @param {Function} fn Function to execute\n * @param {...any} args Arguments to pass to the function\n * @returns {Promise<any>} A promise that resolves with the result of the function\n */\nconst try_ = (fn: (...args: any[]) => any, ...args: any[]): Promise<any> =>\n  new Promise((resolve) => {\n    resolve(fn(...args));\n  });\n\nexport { try_ as try };\n\n/**\n * Universalifies a function to support both callback and promise styles\n *\n * @param {Function} fn Function to universalify\n * @returns {Function} The universalified function\n */\nexport const universalify = (fn: (...args: any[]) => void): ((...args: any[]) => any) =>\n  Object.defineProperties(\n    function _(this: any, ...args: any[]) {\n      if (isFunction(args[args.length - 1])) {\n        return fn.apply(this, args);\n      }\n      return new Promise((resolve, reject) => {\n        args.push((err: any, res: any) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(res);\n          }\n        });\n        fn.apply(this, args);\n      });\n    },\n    {\n      name: {\n        value: fn.name,\n      },\n      ...Object.keys(fn).reduce((props_, k) => {\n        (props_ as any)[k] = {\n          enumerable: true,\n          value: (fn as any)[k],\n        };\n        return props_;\n      }, {}),\n    }\n  );\n\n/**\n * Universalifies a promise-returning function to support both callback and promise styles\n *\n * @param {Function} fn Function to universalify\n * @returns {Function} The universalified function\n */\nexport const universalifyFromPromise = (fn: (...args: any[]) => Promise<any>): ((...args: any[]) => any) =>\n  Object.defineProperty(\n    function _(this: any, ...args: any[]) {\n      const cb = args[args.length - 1];\n      if (!isFunction(cb)) {\n        return fn.apply(this, args);\n      }\n      return fn.apply(this, args).then((r: any) => cb(null, r), cb);\n    },\n    'name',\n    { value: fn.name }\n  );\n", "/**\n * Optimized p-limit implementation for controlling promise concurrency\n * Works in Node.js, Bun, and browser environments\n */\n\n/**\n * Lightweight queue implementation optimized for p-limit usage\n */\nclass Queue<T> {\n  private head?: Node<T>;\n  private tail?: Node<T>;\n  private _size = 0;\n\n  enqueue(value: T): void {\n    const node = { value, next: undefined } as Node<T>;\n    if (this.tail) {\n      this.tail.next = node;\n      this.tail = node;\n    } else {\n      this.head = this.tail = node;\n    }\n    this._size++;\n  }\n\n  dequeue(): T | undefined {\n    const node = this.head;\n    if (!node) return undefined;\n\n    this.head = node.next;\n    if (!this.head) {\n      this.tail = undefined;\n    }\n    this._size--;\n    return node.value;\n  }\n\n  clear(): void {\n    this.head = this.tail = undefined;\n    this._size = 0;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n}\n\ninterface Node<T> {\n  value: T;\n  next?: Node<T>;\n}\n\nexport interface PLimitFunction {\n  /**\n   * The number of promises that are currently running\n   */\n  readonly activeCount: number;\n\n  /**\n   * The number of promises that are waiting to run\n   */\n  readonly pendingCount: number;\n\n  /**\n   * Get or set the concurrency limit\n   */\n  concurrency: number;\n\n  /**\n   * Discard pending promises that are waiting to run\n   */\n  clearQueue: () => void;\n\n  /**\n   * Process an array of inputs with limited concurrency\n   */\n  map: <Input, ReturnType>(\n    array: readonly Input[],\n    mapperFunction: (input: Input, index: number) => PromiseLike<ReturnType> | ReturnType\n  ) => Promise<ReturnType[]>;\n\n  /**\n   * Run a function with limited concurrency\n   */\n  <Arguments extends unknown[], ReturnType>(\n    function_: (...arguments_: Arguments) => PromiseLike<ReturnType> | ReturnType,\n    ...arguments_: Arguments\n  ): Promise<ReturnType>;\n}\n\nexport interface PLimitOptions {\n  /**\n   * Concurrency limit. Minimum: 1\n   */\n  readonly concurrency: number;\n}\n\n/**\n * Run multiple promise-returning & async functions with limited concurrency\n *\n * @param concurrency - Concurrency limit. Minimum: 1\n * @returns A limit function\n */\nexport function pLimit(concurrency: number): PLimitFunction {\n  validateConcurrency(concurrency);\n\n  const queue = new Queue<() => void>();\n  let activeCount = 0;\n  let currentConcurrency = concurrency;\n\n  const resumeNext = (): void => {\n    if (activeCount < currentConcurrency && queue.size > 0) {\n      activeCount++;\n      const resolveFunction = queue.dequeue();\n      if (resolveFunction) {\n        resolveFunction();\n      }\n    }\n  };\n\n  const next = (): void => {\n    activeCount--;\n    resumeNext();\n  };\n\n  const run = async <T>(\n    function_: (...args: any[]) => T | PromiseLike<T>,\n    resolve: (value: T | PromiseLike<T>) => void,\n    arguments_: any[]\n  ): Promise<void> => {\n    // Execute the function and capture the result promise\n    const result = (async () => function_(...arguments_))();\n\n    // Resolve immediately with the promise (don't wait for completion)\n    resolve(result);\n\n    // Wait for the function to complete\n    try {\n      await result;\n    } catch {\n      // Catch errors to prevent unhandled rejections\n      // The original promise rejection is preserved for the caller\n    }\n\n    // Decrement active count and process next queued function\n    next();\n  };\n\n  const enqueue = <T>(\n    function_: (...args: any[]) => T | PromiseLike<T>,\n    resolve: (value: T | PromiseLike<T>) => void,\n    arguments_: any[]\n  ): void => {\n    // Queue the function to run later\n    queue.enqueue(() => {\n      run(function_, resolve, arguments_);\n    });\n\n    // Start processing immediately if under concurrency limit\n    (async () => {\n      // Use microtask to ensure async execution\n      await Promise.resolve();\n      if (activeCount < currentConcurrency && queue.size > 0) {\n        resumeNext();\n      }\n    })();\n  };\n\n  const generator = <Arguments extends unknown[], ReturnType>(\n    function_: (...arguments_: Arguments) => PromiseLike<ReturnType> | ReturnType,\n    ...arguments_: Arguments\n  ): Promise<ReturnType> =>\n    new Promise<ReturnType>((resolve) => {\n      enqueue(function_, resolve, arguments_);\n    });\n\n  // Define properties on the generator function\n  Object.defineProperties(generator, {\n    activeCount: {\n      get: () => activeCount,\n    },\n    pendingCount: {\n      get: () => queue.size,\n    },\n    clearQueue: {\n      value: () => {\n        queue.clear();\n      },\n    },\n    concurrency: {\n      get: () => currentConcurrency,\n      set: (newConcurrency: number) => {\n        validateConcurrency(newConcurrency);\n        currentConcurrency = newConcurrency;\n\n        // Use queueMicrotask for optimal scheduling (works in all environments)\n        const processQueue =\n          typeof queueMicrotask !== 'undefined' ? queueMicrotask : (fn: () => void) => Promise.resolve().then(fn);\n\n        processQueue(() => {\n          while (activeCount < currentConcurrency && queue.size > 0) {\n            resumeNext();\n          }\n        });\n      },\n    },\n    map: {\n      async value<Input, ReturnType>(\n        this: PLimitFunction,\n        array: readonly Input[],\n        mapperFunction: (input: Input, index: number) => PromiseLike<ReturnType> | ReturnType\n      ): Promise<ReturnType[]> {\n        const promises = array.map((value, index) => this(mapperFunction, value, index));\n        return Promise.all(promises);\n      },\n    },\n  });\n\n  return generator as PLimitFunction;\n}\n\n/**\n * Returns a function with limited concurrency\n *\n * @param function_ - Promise-returning/async function\n * @param options - Options including concurrency limit\n * @returns Function with limited concurrency\n */\nexport function limitFunction<Arguments extends unknown[], ReturnType>(\n  function_: (...arguments_: Arguments) => PromiseLike<ReturnType>,\n  options: PLimitOptions\n): (...arguments_: Arguments) => Promise<ReturnType> {\n  const { concurrency } = options;\n  const limit = pLimit(concurrency);\n\n  return (...arguments_: Arguments) => limit(() => function_(...arguments_));\n}\n\n/**\n * Validate concurrency value\n */\nfunction validateConcurrency(concurrency: number): void {\n  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n    throw new TypeError('Expected `concurrency` to be a number from 1 and up');\n  }\n}\n\n// Also export as default for compatibility\nexport default pLimit;\n\n// Export Limit type for compatibility with existing code\nexport type Limit = PLimitFunction;\n", "/**\n * Represents a map that stores keys only for a specified time interval.\n */\nexport class TimedMap<K, V> {\n  // Maximum lifespan of keys in milliseconds\n  public timeout: number;\n  // Callback function invoked for each key after its time expires\n  private timeoutCallback: (key: K) => void;\n  // Internal storage where each key is associated with a value and a timer\n  private map = new Map<K, { value: V; timer: ReturnType<typeof setTimeout> }>();\n\n  /**\n   * Constructor for the TimedMap class.\n   * @param {number} [timeoutMs=1000] - Maximum lifespan of keys in milliseconds, default is 1000.\n   * @param {Function} [callback] - Callback function invoked for each key after its time expires.\n   */\n  constructor(timeoutMs?: number, callback?: (key: K) => void) {\n    this.timeout = timeoutMs ?? 1000; // Set the lifespan of keys\n    this.timeoutCallback = callback ?? ((key: K) => this.map.delete(key)); // Set the callback function\n  }\n\n  /**\n   * Sets a value for the specified key with an optional timeout and callback function.\n   * @param {K} key - The key for which the value is set.\n   * @param {V} value - The value to be set.\n   * @param {Function} [callback] - Callback function invoked after the time expires.\n   * @param {number} [timeout] - Time in milliseconds after which the callback function will be invoked.\n   */\n  set(key: K, value: V, callback?: (key: K) => void, timeout?: number) {\n    this.clearTimeout(key); // Clear existing timer for the key\n    const timer = setTimeout(\n      callback ? callback : this.timeoutCallback,\n      Number.isInteger(timeout) ? timeout : this.timeout,\n      key\n    );\n    this.map.set(key, { value, timer }); // Set the new value and timer\n  }\n\n  /**\n   * Returns the value associated with the specified key.\n   * @param {K} key - The key for which the value is to be retrieved.\n   * @returns {V | undefined} - The value associated with the key, or undefined if the key is not found.\n   */\n  get(key: K): V | undefined {\n    return this.map.get(key)?.value;\n  }\n\n  /**\n   * Executes the specified function for each element in the map.\n   * @param {Function} callback - Function invoked for each element.\n   * @param {any} thisArg - Value used as this when executing the callback function.\n   */\n  forEach(callback: (value: V, key: K, map: TimedMap<K, V>) => void, thisArg: any) {\n    this.map.forEach((obj, key) => {\n      callback.call(thisArg, obj.value, key, this);\n    });\n  }\n\n  /**\n   * Returns an iterator for the [key, value] pairs in the map.\n   * @returns {IterableIterator<[K, V]>} - Iterator for the [key, value] pairs.\n   */\n  *entries() {\n    for (const [key, obj] of this.map.entries()) {\n      yield [key, obj.value];\n    }\n  }\n\n  /**\n   * Returns an iterator for the values in the map.\n   * @returns {IterableIterator<V>} - Iterator for the values.\n   */\n  *values() {\n    for (const obj of this.map.values()) {\n      yield obj.value;\n    }\n  }\n\n  /**\n   * Removes the element with the specified key from the map.\n   * @param {K} key - The key of the element to be removed.\n   * @returns {boolean} - true if the element was successfully removed, otherwise false.\n   */\n  delete(key: K) {\n    this.clearTimeout(key); // Clear the timer for the key being removed\n    return this.map.delete(key);\n  }\n\n  /**\n   * Clears the map, removing all elements and clearing all timers.\n   */\n  clear() {\n    this.map.forEach((obj) => {\n      clearTimeout(obj.timer as any); // Clear each timer\n    });\n    this.map.clear(); // Clear the map\n  }\n\n  /**\n   * Clears the timer for the specified key, if it exists.\n   * @param {K} key - The key for which the timer is to be cleared.\n   */\n  private clearTimeout(key: K) {\n    if (this.map.has(key)) {\n      clearTimeout(this.map.get(key)!.timer as any); // Clear the timer\n    }\n  }\n}\n", "// Start of Selection\n/**\n * A generic ListBuffer class that implements a simple linked list structure.\n * This class allows adding elements to the end of the list and removing elements from the start.\n *\n * @template T - The type of elements stored in the buffer.\n */\nexport class ListBuffer<T> {\n  private head: ListNode<T> | null = null;\n  private tail: ListNode<T> | null = null;\n  private size: number = 0;\n\n  /**\n   * Adds a new element to the end of the list.\n   *\n   * @param {T} value - The value to be added to the list.\n   */\n  push(value: T): void {\n    const node: ListNode<T> = { value, next: null };\n    if (!this.tail) {\n      this.head = this.tail = node;\n    } else {\n      this.tail.next = node;\n      this.tail = node;\n    }\n    this.size++;\n  }\n\n  /**\n   * Removes and returns the first element from the list.\n   *\n   * @returns {T | undefined} - The value of the removed element, or undefined if the list is empty.\n   */\n  shift(): T | undefined {\n    if (!this.head) return undefined;\n    const value = this.head.value;\n    this.head = this.head.next;\n    if (!this.head) this.tail = null;\n    this.size--;\n    return value;\n  }\n\n  /**\n   * Gets the current number of elements in the list.\n   *\n   * @returns {number} - The number of elements in the list.\n   */\n  get length(): number {\n    return this.size;\n  }\n\n  /**\n   * Clears the list.\n   */\n  clear(): void {\n    this.head = this.tail = null;\n    this.size = 0;\n  }\n}\n\n/**\n * A node in the linked list.\n *\n * @template T - The type of the value stored in the node.\n */\ninterface ListNode<T> {\n  value: T;\n  next: ListNode<T> | null;\n}\n", "export * from './omit.js';\nexport * from './entries.js';\nexport * from './promise.js';\nexport * from './p-limit.js';\nexport * from './timed-map.js';\nexport * from './primitives.js';\nexport * from './predicates.js';\nexport * from './list-buffer.js';\n", "/**\n * @license\n * Copyright 2009 The Closure Library Authors\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// WebAssembly optimizations to do native i64 multiplication and divide\nvar wasm = null;\ntry {\n  wasm = new WebAssembly.Instance(\n    new WebAssembly.Module(\n      new Uint8Array([\n        // \\0asm\n        0, 97, 115, 109,\n        // version 1\n        1, 0, 0, 0,\n\n        // section \"type\"\n        1, 13, 2,\n        // 0, () => i32\n        96, 0, 1, 127,\n        // 1, (i32, i32, i32, i32) => i32\n        96, 4, 127, 127, 127, 127, 1, 127,\n\n        // section \"function\"\n        3, 7, 6,\n        // 0, type 0\n        0,\n        // 1, type 1\n        1,\n        // 2, type 1\n        1,\n        // 3, type 1\n        1,\n        // 4, type 1\n        1,\n        // 5, type 1\n        1,\n\n        // section \"global\"\n        6, 6, 1,\n        // 0, \"high\", mutable i32\n        127, 1, 65, 0, 11,\n\n        // section \"export\"\n        7, 50, 6,\n        // 0, \"mul\"\n        3, 109, 117, 108, 0, 1,\n        // 1, \"div_s\"\n        5, 100, 105, 118, 95, 115, 0, 2,\n        // 2, \"div_u\"\n        5, 100, 105, 118, 95, 117, 0, 3,\n        // 3, \"rem_s\"\n        5, 114, 101, 109, 95, 115, 0, 4,\n        // 4, \"rem_u\"\n        5, 114, 101, 109, 95, 117, 0, 5,\n        // 5, \"get_high\"\n        8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0,\n\n        // section \"code\"\n        10, 191, 1, 6,\n        // 0, \"get_high\"\n        4, 0, 35, 0, 11,\n        // 1, \"mul\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n        // 2, \"div_s\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n        // 3, \"div_u\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n        // 4, \"rem_s\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n        // 5, \"rem_u\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n      ]),\n    ),\n    {},\n  ).exports;\n} catch {\n  // no wasm support :(\n}\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nfunction Long(low, high, unsigned) {\n  /**\n   * The low 32 bits as a signed value.\n   * @type {number}\n   */\n  this.low = low | 0;\n\n  /**\n   * The high 32 bits as a signed value.\n   * @type {number}\n   */\n  this.high = high | 0;\n\n  /**\n   * Whether unsigned or not.\n   * @type {boolean}\n   */\n  this.unsigned = !!unsigned;\n}\n\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\n\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nfunction isLong(obj) {\n  return (obj && obj[\"__isLong__\"]) === true;\n}\n\n/**\n * @function\n * @param {*} value number\n * @returns {number}\n * @inner\n */\nfunction ctz32(value) {\n  var c = Math.clz32(value & -value);\n  return value ? 31 - c : c;\n}\n\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\nLong.isLong = isLong;\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromInt(value, unsigned) {\n  var obj, cachedObj, cache;\n  if (unsigned) {\n    value >>>= 0;\n    if ((cache = 0 <= value && value < 256)) {\n      cachedObj = UINT_CACHE[value];\n      if (cachedObj) return cachedObj;\n    }\n    obj = fromBits(value, 0, true);\n    if (cache) UINT_CACHE[value] = obj;\n    return obj;\n  } else {\n    value |= 0;\n    if ((cache = -128 <= value && value < 128)) {\n      cachedObj = INT_CACHE[value];\n      if (cachedObj) return cachedObj;\n    }\n    obj = fromBits(value, value < 0 ? -1 : 0, false);\n    if (cache) INT_CACHE[value] = obj;\n    return obj;\n  }\n}\n\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromInt = fromInt;\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromNumber(value, unsigned) {\n  if (isNaN(value)) return unsigned ? UZERO : ZERO;\n  if (unsigned) {\n    if (value < 0) return UZERO;\n    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n  } else {\n    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n  }\n  if (value < 0) return fromNumber(-value, unsigned).neg();\n  return fromBits(\n    value % TWO_PWR_32_DBL | 0,\n    (value / TWO_PWR_32_DBL) | 0,\n    unsigned,\n  );\n}\n\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromNumber = fromNumber;\n\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromBits(lowBits, highBits, unsigned) {\n  return new Long(lowBits, highBits, unsigned);\n}\n\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromBits = fromBits;\n\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nfunction fromString(str, unsigned, radix) {\n  if (str.length === 0) throw Error(\"empty string\");\n  if (typeof unsigned === \"number\") {\n    // For goog.math.long compatibility\n    radix = unsigned;\n    unsigned = false;\n  } else {\n    unsigned = !!unsigned;\n  }\n  if (\n    str === \"NaN\" ||\n    str === \"Infinity\" ||\n    str === \"+Infinity\" ||\n    str === \"-Infinity\"\n  )\n    return unsigned ? UZERO : ZERO;\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n\n  var p;\n  if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n  else if (p === 0) {\n    return fromString(str.substring(1), unsigned, radix).neg();\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 8));\n\n  var result = ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i),\n      value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = fromNumber(pow_dbl(radix, size));\n      result = result.mul(power).add(fromNumber(value));\n    } else {\n      result = result.mul(radixToPower);\n      result = result.add(fromNumber(value));\n    }\n  }\n  result.unsigned = unsigned;\n  return result;\n}\n\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\nLong.fromString = fromString;\n\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromValue(val, unsigned) {\n  if (typeof val === \"number\") return fromNumber(val, unsigned);\n  if (typeof val === \"string\") return fromString(val, unsigned);\n  // Throws for non-objects, converts non-instanceof Long:\n  return fromBits(\n    val.low,\n    val.high,\n    typeof unsigned === \"boolean\" ? unsigned : val.unsigned,\n  );\n}\n\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\nLong.fromValue = fromValue;\n\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ZERO = fromInt(0);\n\n/**\n * Signed zero.\n * @type {!Long}\n */\nLong.ZERO = ZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UZERO = fromInt(0, true);\n\n/**\n * Unsigned zero.\n * @type {!Long}\n */\nLong.UZERO = UZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ONE = fromInt(1);\n\n/**\n * Signed one.\n * @type {!Long}\n */\nLong.ONE = ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UONE = fromInt(1, true);\n\n/**\n * Unsigned one.\n * @type {!Long}\n */\nLong.UONE = UONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar NEG_ONE = fromInt(-1);\n\n/**\n * Signed negative one.\n * @type {!Long}\n */\nLong.NEG_ONE = NEG_ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_VALUE = fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\n\n/**\n * Maximum signed value.\n * @type {!Long}\n */\nLong.MAX_VALUE = MAX_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_UNSIGNED_VALUE = fromBits(0xffffffff | 0, 0xffffffff | 0, true);\n\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n\n/**\n * Minimum signed value.\n * @type {!Long}\n */\nLong.MIN_VALUE = MIN_VALUE;\n\n/**\n * @alias Long.prototype\n * @inner\n */\nvar LongPrototype = Long.prototype;\n\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toInt = function toInt() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\n\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toNumber = function toNumber() {\n  if (this.unsigned)\n    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\n\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nLongPrototype.toString = function toString(radix) {\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n  if (this.isZero()) return \"0\";\n  if (this.isNegative()) {\n    // Unsigned Longs are never negative\n    if (this.eq(MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = fromNumber(radix),\n        div = this.div(radixLong),\n        rem1 = div.mul(radixLong).sub(this);\n      return div.toString(radix) + rem1.toInt().toString(radix);\n    } else return \"-\" + this.neg().toString(radix);\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n    rem = this;\n  var result = \"\";\n  while (true) {\n    var remDiv = rem.div(radixToPower),\n      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n      digits = intval.toString(radix);\n    rem = remDiv;\n    if (rem.isZero()) return digits + result;\n    else {\n      while (digits.length < 6) digits = \"0\" + digits;\n      result = \"\" + digits + result;\n    }\n  }\n};\n\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nLongPrototype.getHighBits = function getHighBits() {\n  return this.high;\n};\n\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n  return this.high >>> 0;\n};\n\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nLongPrototype.getLowBits = function getLowBits() {\n  return this.low;\n};\n\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n  return this.low >>> 0;\n};\n\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n  if (this.isNegative())\n    // Unsigned Longs are never negative\n    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n  var val = this.high != 0 ? this.high : this.low;\n  for (var bit = 31; bit > 0; bit--) if ((val & (1 << bit)) != 0) break;\n  return this.high != 0 ? bit + 33 : bit + 1;\n};\n\n/**\n * Tests if this Long can be safely represented as a JavaScript number.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isSafeInteger = function isSafeInteger() {\n  // 2^53-1 is the maximum safe value\n  var top11Bits = this.high >> 21;\n  // [0, 2^53-1]\n  if (!top11Bits) return true;\n  // > 2^53-1\n  if (this.unsigned) return false;\n  // [-2^53, -1] except -2^53\n  return top11Bits === -1 && !(this.low === 0 && this.high === -0x200000);\n};\n\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isZero = function isZero() {\n  return this.high === 0 && this.low === 0;\n};\n\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\nLongPrototype.eqz = LongPrototype.isZero;\n\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isNegative = function isNegative() {\n  return !this.unsigned && this.high < 0;\n};\n\n/**\n * Tests if this Long's value is positive or zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isPositive = function isPositive() {\n  return this.unsigned || this.high >= 0;\n};\n\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isOdd = function isOdd() {\n  return (this.low & 1) === 1;\n};\n\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isEven = function isEven() {\n  return (this.low & 1) === 0;\n};\n\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.equals = function equals(other) {\n  if (!isLong(other)) other = fromValue(other);\n  if (\n    this.unsigned !== other.unsigned &&\n    this.high >>> 31 === 1 &&\n    other.high >>> 31 === 1\n  )\n    return false;\n  return this.high === other.high && this.low === other.low;\n};\n\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.eq = LongPrototype.equals;\n\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.notEquals = function notEquals(other) {\n  return !this.eq(/* validates */ other);\n};\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.neq = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ne = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThan = function lessThan(other) {\n  return this.comp(/* validates */ other) < 0;\n};\n\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lt = LongPrototype.lessThan;\n\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n  return this.comp(/* validates */ other) <= 0;\n};\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.le = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThan = function greaterThan(other) {\n  return this.comp(/* validates */ other) > 0;\n};\n\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gt = LongPrototype.greaterThan;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n  return this.comp(/* validates */ other) >= 0;\n};\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\n\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.compare = function compare(other) {\n  if (!isLong(other)) other = fromValue(other);\n  if (this.eq(other)) return 0;\n  var thisNeg = this.isNegative(),\n    otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) return -1;\n  if (!thisNeg && otherNeg) return 1;\n  // At this point the sign bits are the same\n  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n  // Both are positive if at least one is unsigned\n  return other.high >>> 0 > this.high >>> 0 ||\n    (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n    ? -1\n    : 1;\n};\n\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.comp = LongPrototype.compare;\n\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nLongPrototype.negate = function negate() {\n  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n  return this.not().add(ONE);\n};\n\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\nLongPrototype.neg = LongPrototype.negate;\n\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|bigint|string} addend Addend\n * @returns {!Long} Sum\n */\nLongPrototype.add = function add(addend) {\n  if (!isLong(addend)) addend = fromValue(addend);\n\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xffff;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xffff;\n\n  var b48 = addend.high >>> 16;\n  var b32 = addend.high & 0xffff;\n  var b16 = addend.low >>> 16;\n  var b00 = addend.low & 0xffff;\n\n  var c48 = 0,\n    c32 = 0,\n    c16 = 0,\n    c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xffff;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xffff;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c48 += a48 + b48;\n  c48 &= 0xffff;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|bigint|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.subtract = function subtract(subtrahend) {\n  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n  return this.add(subtrahend.neg());\n};\n\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|bigint|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.sub = LongPrototype.subtract;\n\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|bigint|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.multiply = function multiply(multiplier) {\n  if (this.isZero()) return this;\n  if (!isLong(multiplier)) multiplier = fromValue(multiplier);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n\n  if (this.isNegative()) {\n    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n    else return this.neg().mul(multiplier).neg();\n  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n\n  // If both longs are small, use float multiplication\n  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xffff;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xffff;\n\n  var b48 = multiplier.high >>> 16;\n  var b32 = multiplier.high & 0xffff;\n  var b16 = multiplier.low >>> 16;\n  var b00 = multiplier.low & 0xffff;\n\n  var c48 = 0,\n    c32 = 0,\n    c16 = 0,\n    c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xffff;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xffff;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xffff;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xffff;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|bigint|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.mul = LongPrototype.multiply;\n\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.divide = function divide(divisor) {\n  if (!isLong(divisor)) divisor = fromValue(divisor);\n  if (divisor.isZero()) throw Error(\"division by zero\");\n\n  // use wasm support if present\n  if (wasm) {\n    // guard against signed division overflow: the largest\n    // negative number / -1 would be 1 larger than the largest\n    // positive number, due to two's complement.\n    if (\n      !this.unsigned &&\n      this.high === -0x80000000 &&\n      divisor.low === -1 &&\n      divisor.high === -1\n    ) {\n      // be consistent with non-wasm code path\n      return this;\n    }\n    var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high,\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n  var approx, rem, res;\n  if (!this.unsigned) {\n    // This section is only relevant for signed longs and is derived from the\n    // closure library as a whole.\n    if (this.eq(MIN_VALUE)) {\n      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n        return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n      else if (divisor.eq(MIN_VALUE)) return ONE;\n      else {\n        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n        var halfThis = this.shr(1);\n        approx = halfThis.div(divisor).shl(1);\n        if (approx.eq(ZERO)) {\n          return divisor.isNegative() ? ONE : NEG_ONE;\n        } else {\n          rem = this.sub(divisor.mul(approx));\n          res = approx.add(rem.div(divisor));\n          return res;\n        }\n      }\n    } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n    if (this.isNegative()) {\n      if (divisor.isNegative()) return this.neg().div(divisor.neg());\n      return this.neg().div(divisor).neg();\n    } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n    res = ZERO;\n  } else {\n    // The algorithm below has not been made for unsigned longs. It's therefore\n    // required to take special care of the MSB prior to running it.\n    if (!divisor.unsigned) divisor = divisor.toUnsigned();\n    if (divisor.gt(this)) return UZERO;\n    if (divisor.gt(this.shru(1)))\n      // 15 >>> 1 = 7 ; with divisor = 8 ; true\n      return UONE;\n    res = UZERO;\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  rem = this;\n  while (rem.gte(divisor)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n      delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),\n      // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      approxRes = fromNumber(approx),\n      approxRem = approxRes.mul(divisor);\n    while (approxRem.isNegative() || approxRem.gt(rem)) {\n      approx -= delta;\n      approxRes = fromNumber(approx, this.unsigned);\n      approxRem = approxRes.mul(divisor);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) approxRes = ONE;\n\n    res = res.add(approxRes);\n    rem = rem.sub(approxRem);\n  }\n  return res;\n};\n\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.div = LongPrototype.divide;\n\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.modulo = function modulo(divisor) {\n  if (!isLong(divisor)) divisor = fromValue(divisor);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high,\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  return this.sub(this.div(divisor).mul(divisor));\n};\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.mod = LongPrototype.modulo;\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.rem = LongPrototype.modulo;\n\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nLongPrototype.not = function not() {\n  return fromBits(~this.low, ~this.high, this.unsigned);\n};\n\n/**\n * Returns count leading zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countLeadingZeros = function countLeadingZeros() {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\n\n/**\n * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.clz = LongPrototype.countLeadingZeros;\n\n/**\n * Returns count trailing zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countTrailingZeros = function countTrailingZeros() {\n  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n};\n\n/**\n * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.ctz = LongPrototype.countTrailingZeros;\n\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.and = function and(other) {\n  if (!isLong(other)) other = fromValue(other);\n  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.or = function or(other) {\n  if (!isLong(other)) other = fromValue(other);\n  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.xor = function xor(other) {\n  if (!isLong(other)) other = fromValue(other);\n  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  else if (numBits < 32)\n    return fromBits(\n      this.low << numBits,\n      (this.high << numBits) | (this.low >>> (32 - numBits)),\n      this.unsigned,\n    );\n  else return fromBits(0, this.low << (numBits - 32), this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shl = LongPrototype.shiftLeft;\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRight = function shiftRight(numBits) {\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  else if (numBits < 32)\n    return fromBits(\n      (this.low >>> numBits) | (this.high << (32 - numBits)),\n      this.high >> numBits,\n      this.unsigned,\n    );\n  else\n    return fromBits(\n      this.high >> (numBits - 32),\n      this.high >= 0 ? 0 : -1,\n      this.unsigned,\n    );\n};\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr = LongPrototype.shiftRight;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits < 32)\n    return fromBits(\n      (this.low >>> numBits) | (this.high << (32 - numBits)),\n      this.high >>> numBits,\n      this.unsigned,\n    );\n  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n  return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n};\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateLeft = function rotateLeft(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = 32 - numBits;\n    return fromBits(\n      (this.low << numBits) | (this.high >>> b),\n      (this.high << numBits) | (this.low >>> b),\n      this.unsigned,\n    );\n  }\n  numBits -= 32;\n  b = 32 - numBits;\n  return fromBits(\n    (this.high << numBits) | (this.low >>> b),\n    (this.low << numBits) | (this.high >>> b),\n    this.unsigned,\n  );\n};\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotl = LongPrototype.rotateLeft;\n\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateRight = function rotateRight(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = 32 - numBits;\n    return fromBits(\n      (this.high << b) | (this.low >>> numBits),\n      (this.low << b) | (this.high >>> numBits),\n      this.unsigned,\n    );\n  }\n  numBits -= 32;\n  b = 32 - numBits;\n  return fromBits(\n    (this.low << b) | (this.high >>> numBits),\n    (this.high << b) | (this.low >>> numBits),\n    this.unsigned,\n  );\n};\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotr = LongPrototype.rotateRight;\n\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nLongPrototype.toSigned = function toSigned() {\n  if (!this.unsigned) return this;\n  return fromBits(this.low, this.high, false);\n};\n\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nLongPrototype.toUnsigned = function toUnsigned() {\n  if (this.unsigned) return this;\n  return fromBits(this.low, this.high, true);\n};\n\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nLongPrototype.toBytes = function toBytes(le) {\n  return le ? this.toBytesLE() : this.toBytesBE();\n};\n\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nLongPrototype.toBytesLE = function toBytesLE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    lo & 0xff,\n    (lo >>> 8) & 0xff,\n    (lo >>> 16) & 0xff,\n    lo >>> 24,\n    hi & 0xff,\n    (hi >>> 8) & 0xff,\n    (hi >>> 16) & 0xff,\n    hi >>> 24,\n  ];\n};\n\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nLongPrototype.toBytesBE = function toBytesBE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    hi >>> 24,\n    (hi >>> 16) & 0xff,\n    (hi >>> 8) & 0xff,\n    hi & 0xff,\n    lo >>> 24,\n    (lo >>> 16) & 0xff,\n    (lo >>> 8) & 0xff,\n    lo & 0xff,\n  ];\n};\n\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n  return le\n    ? Long.fromBytesLE(bytes, unsigned)\n    : Long.fromBytesBE(bytes, unsigned);\n};\n\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n  return new Long(\n    bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),\n    bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),\n    unsigned,\n  );\n};\n\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n  return new Long(\n    (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],\n    (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],\n    unsigned,\n  );\n};\n\n// Support conversion to/from BigInt where available\nif (typeof BigInt === \"function\") {\n  /**\n   * Returns a Long representing the given big integer.\n   * @function\n   * @param {number} value The big integer value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  Long.fromBigInt = function fromBigInt(value, unsigned) {\n    var lowBits = Number(BigInt.asIntN(32, value));\n    var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));\n    return fromBits(lowBits, highBits, unsigned);\n  };\n\n  // Override\n  Long.fromValue = function fromValueWithBigInt(value, unsigned) {\n    if (typeof value === \"bigint\") return Long.fromBigInt(value, unsigned);\n    return fromValue(value, unsigned);\n  };\n\n  /**\n   * Converts the Long to its big integer representation.\n   * @this {!Long}\n   * @returns {bigint}\n   */\n  LongPrototype.toBigInt = function toBigInt() {\n    var lowBigInt = BigInt(this.low >>> 0);\n    var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);\n    return (highBigInt << BigInt(32)) | lowBigInt;\n  };\n}\n\nexport default Long;\n", "'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n", "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n", "/* eslint-disable no-fallthrough */\nimport Long from 'long';\nimport { Buffer } from 'buffer';\n\n// Interface representing a number with its length\nexport interface SNumber {\n  value: number;\n  length: number;\n}\n\n// Interface representing a Long number with its length\nexport interface SLong {\n  value: Long;\n  length: number;\n}\n\n// Type alias for a number value which can be either SNumber or a number\nexport type NumberValue = SNumber | number;\n\n// Type alias for a Long value which can be either SLong or Long\nexport type LongValue = SLong | Long;\n\n// Constant representing an empty buffer\nconst EMPTY_BUFFER = Buffer.allocUnsafe(0);\n\n// Function to check if a value is a string\nconst _isString = (value: any): boolean => typeof value === 'string' || value instanceof String;\n\n// Helper functions for UTF-8 handling removed - now using TextEncoder/TextDecoder\n\n// Function to check if an object is an instance of SmartBuffer\nexport const isSmartBuffer = (obj: any): boolean => obj instanceof SmartBuffer;\n\n// Class representing a SmartBuffer\nexport class SmartBuffer {\n  // Static property representing an empty buffer\n  static EMPTY_BUFFER = EMPTY_BUFFER;\n\n  /**\n   * Default initial capacity\n   */\n  static DEFAULT_CAPACITY = 64;\n\n  /**\n   * Default no assertions flag\n   */\n  static DEFAULT_NOASSERT = false;\n\n  /**\n   * Maximum number of bytes required to store a 32bit base 128 variable-length integer\n   */\n  static MAX_VARINT32_BYTES = 5;\n\n  /**\n   * Maximum number of bytes required to store a 64bit base 128 variable-length integer\n   */\n  static MAX_VARINT64_BYTES = 10;\n\n  /**\n   * Metrics representing number of UTF8 characters. Evaluates to `c`.\n   */\n  static METRICS_CHARS = 'c';\n\n  /**\n   * Metrics representing number of bytes. Evaluates to `b`.\n   */\n  static METRICS_BYTES = 'b';\n\n  // Buffer to store data\n  public buffer: Buffer;\n  // Write offset\n  public woffset: number = 0;\n  // Read offset\n  public roffset: number = 0;\n  // Flag to skip assertions\n  public noAssert: boolean;\n\n  /**\n   * Constructs a new SmartBuffer\n   *\n   * @param {number} [capacity] Initial capacity. Defaults to SmartBuffer.DEFAULT_CAPACITY(64)\n   * @param {boolean} [noAssert] Whether to skip assertions of offsets and values. Defaults to SmartBuffer.DEFAULT_NOASSERT(false)\n   */\n  constructor(capacity?: number, noAssert: boolean = SmartBuffer.DEFAULT_NOASSERT) {\n    // Determine the initial capacity\n    let lCapacity = capacity === void 0 || Number.isNaN(capacity) ? SmartBuffer.DEFAULT_CAPACITY : capacity;\n    if (!noAssert) {\n      lCapacity |= 0;\n      if (lCapacity < 0) {\n        throw new TypeError('Illegal capacity');\n      }\n      noAssert = Boolean(noAssert);\n    }\n\n    // Allocate buffer with the determined capacity\n    this.buffer = lCapacity === 0 ? EMPTY_BUFFER : Buffer.allocUnsafe(lCapacity);\n    this.noAssert = noAssert;\n  }\n\n  /**\n   * Gets the number of remaining readable bytes or effective length.\n   *\n   * @returns {number}\n   */\n  get length() {\n    return this.woffset - this.roffset;\n  }\n\n  /**\n   * Gets the capacity of this SmartBuffer's backing buffer or real length.\n   *\n   * @returns {number}\n   */\n  get capacity() {\n    return this.buffer.length;\n  }\n\n  /**\n   * Reads a BitSet as an array of booleans.\n   *\n   * @param {number} [offset] Offset to read from. Will use and increase offset by length if omitted.\n   * @returns {boolean[]}\n   */\n  readBitSet(offset?: number): boolean[] {\n    // Determine the offset to read from\n    let loffset = offset ?? this.roffset;\n\n    // Read the variable-length integer representing the number of bits\n    const ret = this.readVarint32(loffset) as SNumber;\n    const bits = ret.value;\n    let bytes = bits >> 3;\n    let bit = 0;\n    const value: boolean[] = [];\n    let k;\n\n    // Update the offset after reading the variable-length integer\n    loffset += ret.length;\n\n    // Read the bytes and convert them to booleans\n    while (bytes--) {\n      k = this.readInt8(loffset++);\n      value[bit++] = Boolean(k & 0x01);\n      value[bit++] = Boolean(k & 0x02);\n      value[bit++] = Boolean(k & 0x04);\n      value[bit++] = Boolean(k & 0x08);\n      value[bit++] = Boolean(k & 0x10);\n      value[bit++] = Boolean(k & 0x20);\n      value[bit++] = Boolean(k & 0x40);\n      value[bit++] = Boolean(k & 0x80);\n    }\n\n    // Read the remaining bits if any\n    if (bit < bits) {\n      let m = 0;\n      k = this.readInt8(loffset++);\n      while (bit < bits) {\n        value[bit++] = Boolean((k >> m++) & 1);\n      }\n    }\n\n    // Update the read offset if no specific offset was provided\n    if (offset === void 0) {\n      this.roffset = loffset;\n    }\n    return value;\n  }\n\n  /**\n   * Reads the specified number of bytes.\n   *\n   * @param {number} length Number of bytes to read\n   * @param {number} [offset] Offset to read from. Will use and increase offset by length if omitted.\n   * @returns {SmartBuffer}\n   */\n  read(length: number, offset?: number) {\n    // Determine the offset to read from\n    let loffset = offset ?? this.roffset;\n    if (!this.noAssert) {\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + length > this.buffer.length) {\n        throw new TypeError(`Illegal offset: 0 <= ${loffset} (${length}) <= ${this.buffer.length}`);\n      }\n    }\n    // Slice the buffer to get the specified number of bytes\n    const slice = this.slice(offset, loffset + length);\n    // Update the read offset if no specific offset was provided\n    if (offset === void 0) {\n      this.roffset += length;\n    }\n    return slice;\n  }\n\n  /**\n   * Reads an 8bit signed integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readInt8(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(1, offset);\n    let value = this.buffer[loffset]!;\n    if ((value & 0x80) === 0x80) {\n      value = -(0xff - value + 1); // Cast to signed\n    }\n    return value;\n  }\n\n  /**\n   * Reads an 8bit unsigned integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readUInt8(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(1, offset);\n    return this.buffer[loffset];\n  }\n\n  /**\n   * Reads a 16bit signed le integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readInt16LE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(2, offset);\n    let value = 0;\n    value = this.buffer[loffset]!;\n    value |= this.buffer[loffset + 1]! << 8;\n    if ((value & 0x8000) === 0x8000) {\n      value = -(0xffff - value + 1); // Cast to signed\n    }\n    return value;\n  }\n\n  /**\n   * Reads a 16bit signed be integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readInt16BE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(2, offset);\n    let value = 0;\n    value = this.buffer[loffset]! << 8;\n    value |= this.buffer[loffset + 1]!;\n    if ((value & 0x8000) === 0x8000) {\n      value = -(0xffff - value + 1); // Cast to signed\n    }\n    return value;\n  }\n\n  /**\n   * Reads a 16bit unsigned le integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readUInt16LE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(2, offset);\n    let value = 0;\n    value = this.buffer[loffset]!;\n    value |= this.buffer[loffset + 1]! << 8;\n    return value;\n  }\n\n  /**\n   * Reads a 16bit unsigned be integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readUInt16BE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(2, offset);\n    let value = 0;\n    value = this.buffer[loffset]! << 8;\n    value |= this.buffer[loffset + 1]!;\n    return value;\n  }\n\n  /**\n   * Reads a 24bit unsigned be integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readUInt24BE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(3, offset);\n    let value = 0;\n    value = this.buffer[loffset]! << 16;\n    value |= this.buffer[loffset + 1]! << 8;\n    value |= this.buffer[loffset + 2]!;\n    value |= 0; // Cast to signed\n    return value;\n  }\n\n  /**\n   * Reads a 32bit signed le integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readInt32LE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(4, offset);\n    let value = 0;\n    value = this.buffer[loffset + 2]! << 16;\n    value |= this.buffer[loffset + 1]! << 8;\n    value |= this.buffer[loffset]!;\n    value += (this.buffer[loffset + 3]! << 24) >>> 0;\n    value |= 0; // Cast to signed\n    return value;\n  }\n\n  /**\n   * Reads a 32bit signed be integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readInt32BE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(4, offset);\n    let value = 0;\n    value = this.buffer[loffset + 1]! << 16;\n    value |= this.buffer[loffset + 2]! << 8;\n    value |= this.buffer[loffset + 3]!;\n    value += (this.buffer[loffset]! << 24) >>> 0;\n    value |= 0; // Cast to signed\n    return value;\n  }\n\n  /**\n   * Reads a 32bit unsigned le integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readUInt32LE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(4, offset);\n    let value = 0;\n    value = this.buffer[loffset + 2]! << 16;\n    value |= this.buffer[loffset + 1]! << 8;\n    value |= this.buffer[loffset]!;\n    value += (this.buffer[loffset + 3]! << 24) >>> 0;\n    return value;\n  }\n\n  /**\n   * Reads a 32bit unsigned be integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readUInt32BE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(4, offset);\n    let value = 0;\n    value = this.buffer[loffset + 1]! << 16;\n    value |= this.buffer[loffset + 2]! << 8;\n    value |= this.buffer[loffset + 3]!;\n    value += (this.buffer[loffset]! << 24) >>> 0;\n    return value;\n  }\n\n  /**\n   * Reads a 64bit signed le integer as math.Long\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {ateos.math.Long}\n   */\n  readInt64LE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    let lo = 0;\n    let hi = 0;\n    lo = this.buffer[loffset + 2]! << 16;\n    lo |= this.buffer[loffset + 1]! << 8;\n    lo |= this.buffer[loffset]!;\n    lo += (this.buffer[loffset + 3]! << 24) >>> 0;\n    hi = this.buffer[loffset + 6]! << 16;\n    hi |= this.buffer[loffset + 5]! << 8;\n    hi |= this.buffer[loffset + 4]!;\n    hi += (this.buffer[loffset + 7]! << 24) >>> 0;\n    return new Long(lo, hi, false);\n  }\n\n  /**\n   * Reads a 64bit signed be integer as math.Long\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {ateos.math.Long}\n   */\n  readInt64BE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    let lo = 0;\n    let hi = 0;\n    hi = this.buffer[loffset + 1]! << 16;\n    hi |= this.buffer[loffset + 2]! << 8;\n    hi |= this.buffer[loffset + 3]!;\n    hi += (this.buffer[loffset]! << 24) >>> 0;\n    lo = this.buffer[loffset + 5]! << 16;\n    lo |= this.buffer[loffset + 6]! << 8;\n    lo |= this.buffer[loffset + 7]!;\n    lo += (this.buffer[loffset + 4]! << 24) >>> 0;\n    return new Long(lo, hi, false);\n  }\n\n  /**\n   * Reads a 64bit unsigned le integer as math.Long\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {ateos.math.Long}\n   */\n  readUInt64LE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    let lo = 0;\n    let hi = 0;\n    lo = this.buffer[loffset + 2]! << 16;\n    lo |= this.buffer[loffset + 1]! << 8;\n    lo |= this.buffer[loffset]!;\n    lo += (this.buffer[loffset + 3]! << 24) >>> 0;\n    hi = this.buffer[loffset + 6]! << 16;\n    hi |= this.buffer[loffset + 5]! << 8;\n    hi |= this.buffer[loffset + 4]!;\n    hi += (this.buffer[loffset + 7]! << 24) >>> 0;\n    return new Long(lo, hi, true);\n  }\n\n  /**\n   * Reads a 64bit unsigned be integer as math.Long\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {ateos.math.Long}\n   */\n  readUInt64BE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    let lo = 0;\n    let hi = 0;\n    hi = this.buffer[loffset + 1]! << 16;\n    hi |= this.buffer[loffset + 2]! << 8;\n    hi |= this.buffer[loffset + 3]!;\n    hi += (this.buffer[loffset]! << 24) >>> 0;\n    lo = this.buffer[loffset + 5]! << 16;\n    lo |= this.buffer[loffset + 6]! << 8;\n    lo |= this.buffer[loffset + 7]!;\n    lo += (this.buffer[loffset + 4]! << 24) >>> 0;\n    return new Long(lo, hi, true);\n  }\n\n  /**\n   * Reads a 64bit unsigned be integer as BigInt\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {bigint}\n   */\n  readBigIntBE(offset?: number): bigint {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    let value =\n      (BigInt(this.buffer[loffset]!) << 56n) |\n      (BigInt(this.buffer[loffset + 1]!) << 48n) |\n      (BigInt(this.buffer[loffset + 2]!) << 40n) |\n      (BigInt(this.buffer[loffset + 3]!) << 32n) |\n      (BigInt(this.buffer[loffset + 4]!) << 24n) |\n      (BigInt(this.buffer[loffset + 5]!) << 16n) |\n      (BigInt(this.buffer[loffset + 6]!) << 8n) |\n      BigInt(this.buffer[loffset + 7]!);\n    if (value & (1n << 63n)) {\n      value -= 1n << 64n;\n    }\n    return value;\n  }\n\n  /**\n   * Reads a 64bit unsigned be integer as BigInt\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {bigint}\n   */\n  readUBigIntBE(offset?: number): bigint {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    const value =\n      (BigInt(this.buffer[loffset]!) << 56n) |\n      (BigInt(this.buffer[loffset + 1]!) << 48n) |\n      (BigInt(this.buffer[loffset + 2]!) << 40n) |\n      (BigInt(this.buffer[loffset + 3]!) << 32n) |\n      (BigInt(this.buffer[loffset + 4]!) << 24n) |\n      (BigInt(this.buffer[loffset + 5]!) << 16n) |\n      (BigInt(this.buffer[loffset + 6]!) << 8n) |\n      BigInt(this.buffer[loffset + 7]!);\n    return value;\n  }\n\n  /**\n   * Reads a 64bit signed le integer as BigInt\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {bigint}\n   */\n  readBigIntLE(offset?: number): bigint {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    let value =\n      (BigInt(this.buffer[loffset]!) << 0n) |\n      (BigInt(this.buffer[loffset + 1]!) << 8n) |\n      (BigInt(this.buffer[loffset + 2]!) << 16n) |\n      (BigInt(this.buffer[loffset + 3]!) << 24n) |\n      (BigInt(this.buffer[loffset + 4]!) << 32n) |\n      (BigInt(this.buffer[loffset + 5]!) << 40n) |\n      (BigInt(this.buffer[loffset + 6]!) << 48n) |\n      (BigInt(this.buffer[loffset + 7]!) << 56n);\n    if (value & (1n << 63n)) {\n      value -= 1n << 64n;\n    }\n    return value;\n  }\n\n  /**\n   * Reads a 64bit unsigned le integer as BigInt\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {bigint}\n   */\n  readUBigIntLE(offset?: number): bigint {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    const value =\n      (BigInt(this.buffer[loffset + 7]!) << 56n) |\n      (BigInt(this.buffer[loffset + 6]!) << 48n) |\n      (BigInt(this.buffer[loffset + 5]!) << 40n) |\n      (BigInt(this.buffer[loffset + 4]!) << 32n) |\n      (BigInt(this.buffer[loffset + 3]!) << 24n) |\n      (BigInt(this.buffer[loffset + 2]!) << 16n) |\n      (BigInt(this.buffer[loffset + 1]!) << 8n) |\n      BigInt(this.buffer[loffset]!);\n    return value;\n  }\n\n  /**\n   * Reads a 32bit le float\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readFloatLE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(4, offset);\n    return this.buffer.readFloatLE(loffset);\n  }\n\n  /**\n   * Reads a 32bit be float\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readFloatBE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(4, offset);\n    return this.buffer.readFloatBE(loffset);\n  }\n\n  /**\n   * Reads a 64bit le float\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readDoubleLE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    return this.buffer.readDoubleLE(loffset);\n  }\n\n  /**\n   * Reads a 64bit be float\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number}\n   */\n  readDoubleBE(offset?: number) {\n    // Check the read offset and get the value\n    const loffset = this._checkRead(8, offset);\n    return this.buffer.readDoubleBE(loffset);\n  }\n\n  /**\n   * Appends some data to this SmartBuffer.\n   * This will overwrite any contents behind the specified offset up to the appended data's length.\n   *\n   * @param {Wrappable} source The source write from\n   * @param {number} [offset] Offset to write to\n   * @param {number} [length] length to read from the source\n   * @param {string} [encoding] encoding to use for wrapping the source in bytearray\n   */\n  write(source: any, offset?: number, length?: number, encoding: string = 'utf8') {\n    // Determine the offset to write to\n    let loffset = offset === void 0 ? this.woffset : offset;\n    const result = loffset >>> 0;\n    if (!this.noAssert) {\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n    let llength;\n    const isString = _isString(source);\n    if (isString) {\n      llength = length || Buffer.byteLength(source);\n    } else {\n      if (!(source instanceof SmartBuffer)) {\n        source = SmartBuffer.wrap(source, encoding);\n      }\n      llength = source.woffset - source.roffset;\n    }\n\n    if (llength <= 0) {\n      return this; // Nothing to append\n    }\n    loffset += llength;\n    let capacity = this.buffer.length;\n    if (loffset > capacity) {\n      this.resize((capacity *= 2) > loffset ? capacity : loffset);\n    }\n    if (isString) {\n      this.buffer.write(source, result);\n    } else {\n      source.buffer.copy(this.buffer, result, source.roffset, source.woffset);\n      source.roffset += llength;\n    }\n    if (offset === void 0) {\n      this.woffset += llength;\n    }\n    return this;\n  }\n\n  /**\n   * Writes the array as a bitset.\n   * @param {boolean[]} value Array of booleans to write\n   * @param {number} [offset] Offset to write to\n   * @returns {SmartBuffer}\n   */\n  writeBitSet(value: any[], offset?: number) {\n    // Determine the offset to write to\n    let loffset = offset ?? this.woffset;\n    if (!this.noAssert) {\n      if (!Array.isArray(value)) {\n        throw new TypeError('Illegal BitSet: Not an array');\n      }\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n\n    const start = loffset;\n    const bits = value.length;\n    let bytes = bits >> 3;\n    let bit = 0;\n    let k;\n\n    // Write the variable-length integer representing the number of bits\n    loffset += this.writeVarint32(bits, loffset) as number;\n\n    // Write the bytes from the boolean array\n    while (bytes--) {\n      k =\n        ((!!value[bit++] as any) & 1) |\n        ((!!value[bit++] as any) << 1) |\n        ((!!value[bit++] as any) << 2) |\n        ((!!value[bit++] as any) << 3) |\n        ((!!value[bit++] as any) << 4) |\n        ((!!value[bit++] as any) << 5) |\n        ((!!value[bit++] as any) << 6) |\n        ((!!value[bit++] as any) << 7);\n      this.writeInt8(k, loffset++);\n    }\n\n    // Write the remaining bits if any\n    if (bit < bits) {\n      let m = 0;\n      k = 0;\n      while (bit < bits) {\n        k = k | ((!!value[bit++] as any) << m++);\n      }\n      this.writeInt8(k, loffset++);\n    }\n\n    // Update the write offset if no specific offset was provided\n    if (offset === void 0) {\n      this.woffset = loffset;\n      return this;\n    }\n    return loffset - start;\n  }\n\n  /**\n   * Writes a buffer at the given offset\n   *\n   * @param {Buffer} buf buffer to write\n   * @param {number} [offset] offset to write at\n   * @returns {this}\n   */\n  writeBuffer(buf: Buffer, offset?: number) {\n    // If the buffer is empty, return immediately\n    if (buf.length === 0) {\n      return this;\n    }\n    // Determine the offset to write to\n    const relative = offset === void 0;\n    const loffset: number = relative ? this.woffset : offset;\n    const targetEnd = loffset + buf.length;\n    let capacity = this.buffer.length;\n    // Resize the buffer if necessary\n    if (targetEnd > capacity) {\n      capacity *= 2;\n      this.resize(capacity > targetEnd ? capacity : targetEnd);\n    }\n    // Copy the buffer to the target offset\n    buf.copy(this.buffer, loffset);\n    // Update the write offset if no specific offset was provided\n    if (relative) {\n      this.woffset = targetEnd;\n    }\n    return this;\n  }\n\n  /**\n   * Writes an 8bit signed integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeInt8(value: number, offset?: number) {\n    // Check the write offset and set the value\n    const iValue = value | 0;\n    const loffset = this._checkWrite(iValue, 1, offset);\n    this.buffer[loffset] = iValue;\n    return this;\n  }\n\n  /**\n   * Writes an 8bit unsigned integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUInt8(value: number, offset?: number) {\n    // Check the write offset and set the value\n    const uValue = value >>> 0;\n    const loffset = this._checkWrite(uValue, 1, offset);\n    this.buffer[loffset] = uValue;\n    return this;\n  }\n\n  /**\n   * Writes a 16bit signed le integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeInt16LE(value: number, offset?: number) {\n    // Check the write offset and set the value\n    const iValue = value | 0;\n    const loffset = this._checkWrite(iValue, 2, offset);\n    this.buffer[loffset + 1] = iValue >>> 8;\n    this.buffer[loffset] = iValue;\n    return this;\n  }\n\n  /**\n   * Writes a 16bit signed be integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeInt16BE(value: number, offset?: number) {\n    // Check the write offset and set the value\n    const iValue = value | 0;\n    const loffset = this._checkWrite(iValue, 2, offset);\n    this.buffer[loffset] = iValue >>> 8;\n    this.buffer[loffset + 1] = iValue;\n    return this;\n  }\n\n  /**\n   * Writes a 16bit unsigned le integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUInt16LE(value: number, offset?: number) {\n    // Check the write offset and set the value\n    const uValue = value >>> 0;\n    const loffset = this._checkWrite(uValue, 2, offset);\n    this.buffer[loffset + 1] = uValue >>> 8;\n    this.buffer[loffset] = uValue;\n    return this;\n  }\n\n  /**\n   * Writes a 16bit unsigned be integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUInt16BE(value: number, offset?: number) {\n    // Check the write offset and set the value\n    const uValue = value >>> 0;\n    const loffset = this._checkWrite(uValue, 2, offset);\n\n    this.buffer[loffset] = uValue >>> 8;\n    this.buffer[loffset + 1] = uValue;\n    return this;\n  }\n\n  /**\n   * Writes a 24bit unsigned be integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUInt24BE(value: number, offset?: number) {\n    // Check the write offset and set the value\n    const uValue = value >>> 0;\n    const loffset = this._checkWrite(uValue, 3, offset);\n    this.buffer[loffset] = uValue >>> 16;\n    this.buffer[loffset + 1] = uValue >>> 8;\n    this.buffer[loffset + 2] = uValue;\n    return this;\n  }\n\n  /**\n   * Writes a 32bit signed le integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeInt32LE(value: number, offset?: number) {\n    const iValue = value | 0;\n    const loffset = this._checkWrite(iValue, 4, offset);\n    this.buffer[loffset + 3] = iValue >>> 24;\n    this.buffer[loffset + 2] = iValue >>> 16;\n    this.buffer[loffset + 1] = iValue >>> 8;\n    this.buffer[loffset] = iValue;\n    return this;\n  }\n\n  /**\n   * Writes a 32bit signed be integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeInt32BE(value: number, offset?: number) {\n    const iValue = value | 0;\n    const loffset = this._checkWrite(iValue, 4, offset);\n    this.buffer[loffset] = iValue >>> 24;\n    this.buffer[loffset + 1] = iValue >>> 16;\n    this.buffer[loffset + 2] = iValue >>> 8;\n    this.buffer[loffset + 3] = iValue;\n    return this;\n  }\n\n  /**\n   * Writes a 32bit unsigned le integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUInt32LE(value: number, offset?: number) {\n    const uValue = value >>> 0;\n    offset = this._checkWrite(uValue, 4, offset);\n    this.buffer[offset + 3] = uValue >>> 24;\n    this.buffer[offset + 2] = uValue >>> 16;\n    this.buffer[offset + 1] = uValue >>> 8;\n    this.buffer[offset] = uValue;\n    return this;\n  }\n\n  /**\n   * Writes a 32bit unsigned be integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUInt32BE(value: number, offset?: number) {\n    const uValue = value >>> 0;\n    offset = this._checkWrite(uValue, 4, offset);\n    this.buffer[offset] = uValue >>> 24;\n    this.buffer[offset + 1] = uValue >>> 16;\n    this.buffer[offset + 2] = uValue >>> 8;\n    this.buffer[offset + 3] = uValue;\n    return this;\n  }\n\n  /**\n   * Writes a 64bit signed le long integer\n   *\n   * @param {ateos.math.Long | string | number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeInt64LE(value: Long, offset?: number) {\n    const [lvalue, loffset] = this._checkWriteLong(value, offset);\n    const lo = lvalue.low;\n    const hi = lvalue.high;\n    this.buffer[loffset + 3] = lo >>> 24;\n    this.buffer[loffset + 2] = lo >>> 16;\n    this.buffer[loffset + 1] = lo >>> 8;\n    this.buffer[loffset] = lo;\n    this.buffer[loffset + 7] = hi >>> 24;\n    this.buffer[loffset + 6] = hi >>> 16;\n    this.buffer[loffset + 5] = hi >>> 8;\n    this.buffer[loffset + 4] = hi;\n    return this;\n  }\n\n  /**\n   * Writes a 64bit signed be long integer\n   *\n   * @param {ateos.math.Long | string | number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeInt64BE(value: Long, offset?: number) {\n    const [lvalue, loffset] = this._checkWriteLong(value, offset);\n    const lo = lvalue.low;\n    const hi = lvalue.high;\n    this.buffer[loffset] = hi >>> 24;\n    this.buffer[loffset + 1] = hi >>> 16;\n    this.buffer[loffset + 2] = hi >>> 8;\n    this.buffer[loffset + 3] = hi;\n    this.buffer[loffset + 4] = lo >>> 24;\n    this.buffer[loffset + 5] = lo >>> 16;\n    this.buffer[loffset + 6] = lo >>> 8;\n    this.buffer[loffset + 7] = lo;\n    return this;\n  }\n\n  /**\n   * Writes a 64bit unsigned le long integer\n   *\n   * @param {ateos.math.Long | string | number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUInt64LE(value: Long, offset?: number) {\n    const [lvalue, loffset] = this._checkWriteLong(value, offset);\n    const lo = lvalue.low;\n    const hi = lvalue.high;\n    this.buffer[loffset + 3] = lo >>> 24;\n    this.buffer[loffset + 2] = lo >>> 16;\n    this.buffer[loffset + 1] = lo >>> 8;\n    this.buffer[loffset] = lo;\n    this.buffer[loffset + 7] = hi >>> 24;\n    this.buffer[loffset + 6] = hi >>> 16;\n    this.buffer[loffset + 5] = hi >>> 8;\n    this.buffer[loffset + 4] = hi;\n    return this;\n  }\n\n  /**\n   * Writes a 64bit unsigned be long integer\n   *\n   * @param {ateos.math.Long | string | number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUInt64BE(value: Long, offset?: number) {\n    const [lvalue, loffset] = this._checkWriteLong(value, offset);\n    const lo = lvalue.low;\n    const hi = lvalue.high;\n    this.buffer[loffset] = hi >>> 24;\n    this.buffer[loffset + 1] = hi >>> 16;\n    this.buffer[loffset + 2] = hi >>> 8;\n    this.buffer[loffset + 3] = hi;\n    this.buffer[loffset + 4] = lo >>> 24;\n    this.buffer[loffset + 5] = lo >>> 16;\n    this.buffer[loffset + 6] = lo >>> 8;\n    this.buffer[loffset + 7] = lo;\n    return this;\n  }\n\n  /**\n   * Writes a 64bit unsigned be long integer using BigInt\n   *\n   * @param {bigint} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeBigIntBE(value: bigint, offset?: number) {\n    const loffset = this._checkWrite(Number(value), 8, offset);\n    const isNegative = value < 0n;\n    if (isNegative) {\n      value = (1n << 64n) + value;\n    }\n    this.buffer[loffset] = Number((BigInt(value) >> 56n) & BigInt(0xff));\n    this.buffer[loffset + 1] = Number((BigInt(value) >> 48n) & BigInt(0xff));\n    this.buffer[loffset + 2] = Number((BigInt(value) >> 40n) & BigInt(0xff));\n    this.buffer[loffset + 3] = Number((BigInt(value) >> 32n) & BigInt(0xff));\n    this.buffer[loffset + 4] = Number((BigInt(value) >> 24n) & BigInt(0xff));\n    this.buffer[loffset + 5] = Number((BigInt(value) >> 16n) & BigInt(0xff));\n    this.buffer[loffset + 6] = Number((BigInt(value) >> 8n) & BigInt(0xff));\n    this.buffer[loffset + 7] = Number(BigInt(value) & BigInt(0xff));\n    return this;\n  }\n\n  /**\n   * Writes a 64bit unsigned be integer using BigInt\n   *\n   * @param {bigint} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUBigIntBE(value: bigint, offset?: number) {\n    const loffset = this._checkWrite(Number(value), 8, offset);\n    this.buffer[loffset] = Number((BigInt(value) >> 56n) & BigInt(0xff));\n    this.buffer[loffset + 1] = Number((BigInt(value) >> 48n) & BigInt(0xff));\n    this.buffer[loffset + 2] = Number((BigInt(value) >> 40n) & BigInt(0xff));\n    this.buffer[loffset + 3] = Number((BigInt(value) >> 32n) & BigInt(0xff));\n    this.buffer[loffset + 4] = Number((BigInt(value) >> 24n) & BigInt(0xff));\n    this.buffer[loffset + 5] = Number((BigInt(value) >> 16n) & BigInt(0xff));\n    this.buffer[loffset + 6] = Number((BigInt(value) >> 8n) & BigInt(0xff));\n    this.buffer[loffset + 7] = Number(BigInt(value) & BigInt(0xff));\n    return this;\n  }\n\n  /**\n   * Writes a 64bit signed le integer using BigInt\n   *\n   * @param {bigint} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeBigIntLE(value: bigint, offset?: number) {\n    const loffset = this._checkWrite(Number(value), 8, offset);\n    const isNegative = value < 0n;\n    if (isNegative) {\n      value = (1n << 64n) + value;\n    }\n    this.buffer[loffset] = Number(value & 0xffn);\n    this.buffer[loffset + 1] = Number((BigInt(value) >> 8n) & 0xffn);\n    this.buffer[loffset + 2] = Number((BigInt(value) >> 16n) & 0xffn);\n    this.buffer[loffset + 3] = Number((BigInt(value) >> 24n) & 0xffn);\n    this.buffer[loffset + 4] = Number((BigInt(value) >> 32n) & 0xffn);\n    this.buffer[loffset + 5] = Number((BigInt(value) >> 40n) & 0xffn);\n    this.buffer[loffset + 6] = Number((BigInt(value) >> 48n) & 0xffn);\n    this.buffer[loffset + 7] = Number((BigInt(value) >> 56n) & 0xffn);\n    return this;\n  }\n\n  /**\n   * Writes a 64bit unsigned le integer using BigInt\n   *\n   * @param {bigint} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeUBigIntLE(value: bigint, offset?: number) {\n    const loffset = this._checkWrite(Number(value), 8, offset);\n    this.buffer[loffset] = Number(value & 0xffn);\n    this.buffer[loffset + 1] = Number((BigInt(value) >> 8n) & 0xffn);\n    this.buffer[loffset + 2] = Number((BigInt(value) >> 16n) & 0xffn);\n    this.buffer[loffset + 3] = Number((BigInt(value) >> 24n) & 0xffn);\n    this.buffer[loffset + 4] = Number((BigInt(value) >> 32n) & 0xffn);\n    this.buffer[loffset + 5] = Number((BigInt(value) >> 40n) & 0xffn);\n    this.buffer[loffset + 6] = Number((BigInt(value) >> 48n) & 0xffn);\n    this.buffer[loffset + 7] = Number((BigInt(value) >> 56n) & 0xffn);\n    return this;\n  }\n\n  /**\n   * Writes a 32bit le float\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeFloatLE(value: number, offset?: number) {\n    const loffset = this._checkWrite(value, 4, offset, true);\n    this.buffer.writeFloatLE(value, loffset);\n    return this;\n  }\n\n  /**\n   * Writes a 32bit be float\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeFloatBE(value: number, offset?: number) {\n    const loffset = this._checkWrite(value, 4, offset, true);\n    this.buffer.writeFloatBE(value, loffset);\n    return this;\n  }\n\n  /**\n   * Writes a 64bit le float\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeDoubleLE(value: number, offset?: number) {\n    const loffset = this._checkWrite(value, 8, offset, true);\n    this.buffer.writeDoubleLE(value, loffset);\n    return this;\n  }\n\n  /**\n   * Writes a 64bit be float\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this}\n   */\n  writeDoubleBE(value: number, offset?: number) {\n    const loffset = this._checkWrite(value, 8, offset, true);\n    this.buffer.writeDoubleBE(value, loffset);\n    return this;\n  }\n\n  _checkRead(bytes: number, offset?: number) {\n    const loffset = offset ?? this.roffset;\n    if (offset === void 0) {\n      this.roffset += bytes;\n    }\n    if (!this.noAssert) {\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      if (loffset < 0 || loffset + bytes > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (${bytes}) <= ${this.buffer.length}`);\n      }\n    }\n    return loffset;\n  }\n\n  _checkWrite(value: any, bytes: number, offset?: number, isFloat: boolean = false) {\n    let loffset: number = (offset ?? this.woffset) >>> 0;\n    if (offset === void 0) {\n      this.woffset += bytes;\n    }\n    const result = (loffset >>>= 0);\n    if (!this.noAssert) {\n      if (typeof value !== 'number' || (!isFloat && value % 1 !== 0)) {\n        throw new TypeError(`Illegal value: ${value} (not an integer)`);\n      }\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${offset} (not an integer)`);\n      }\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n    loffset += bytes;\n    let capacity = this.buffer.length;\n    if (loffset > capacity) {\n      this.resize((capacity *= 2) > loffset ? capacity : loffset);\n    }\n    return result;\n  }\n\n  _checkWriteLong(value: any, offset?: number) {\n    let loffset = offset ?? this.woffset;\n    if (offset === void 0) {\n      this.woffset += 8;\n    }\n    const result = (loffset >>>= 0);\n    if (!this.noAssert) {\n      if (typeof value === 'number') {\n        value = Long.fromNumber(value);\n      } else if (_isString(value)) {\n        value = Long.fromString(value);\n      } else if (!(typeof value === 'object' && value instanceof Long)) {\n        throw new TypeError(`Illegal value: ${value} (not an integer or Long)`);\n      }\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n    if (typeof value === 'number') {\n      value = Long.fromNumber(value);\n    } else if (_isString(value)) {\n      value = Long.fromString(value);\n    }\n\n    loffset += 8;\n    let capacity = this.buffer.length;\n    if (loffset > capacity) {\n      this.resize((capacity *= 2) > loffset ? capacity : loffset);\n    }\n    return [value, result];\n  }\n\n  /**\n   * Writes a 32bit base 128 variable-length integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this | number} this if offset is omitted, else the actual number of bytes written\n   */\n  writeVarint32(value: any, offset?: number) {\n    let loffset = offset ?? this.woffset;\n    if (!this.noAssert) {\n      if (typeof value !== 'number' || value % 1 !== 0) {\n        throw new TypeError(`Illegal value: ${value} (not an integer)`);\n      }\n      value |= 0;\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n    const size = SmartBuffer.calculateVarint32(value);\n    let b;\n    loffset += size;\n    let capacity10 = this.buffer.length;\n    if (loffset > capacity10) {\n      this.resize((capacity10 *= 2) > loffset ? capacity10 : loffset);\n    }\n    loffset -= size;\n    value >>>= 0;\n    while (value >= 0x80) {\n      b = (value & 0x7f) | 0x80;\n      this.buffer[loffset++] = b;\n      value >>>= 7;\n    }\n    this.buffer[loffset++] = value;\n    if (offset === void 0) {\n      this.woffset = loffset;\n      return this;\n    }\n    return size;\n  }\n\n  /**\n   * Writes a zig-zag encoded 32bit base 128 variable-length integer\n   *\n   * @param {number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this | number} this if offset is omitted, else the actual number of bytes written\n   */\n  writeVarint32ZigZag(value: any, offset?: number) {\n    return this.writeVarint32(SmartBuffer.zigZagEncode32(value), offset);\n  }\n\n  /**\n   * Reads a 32bit base 128 variable-length integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number | { value: number, length: number}} The value read if offset is omitted,\n   *      else the value read and the actual number of bytes read\n   */\n  readVarint32(offset?: number): NumberValue {\n    let loffset = offset ?? this.roffset;\n    if (!this.noAssert) {\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 1 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (1) <= ${this.buffer.length}`);\n      }\n    }\n    let c = 0;\n    let value = 0 >>> 0;\n    let b;\n    do {\n      if (!this.noAssert && loffset > this.buffer.length) {\n        const err = new Error('Truncated');\n        Object.defineProperty(err, 'truncated', {\n          enumerable: true,\n          value: true,\n        });\n        throw err;\n      }\n      b = this.buffer[loffset++]!;\n      if (c < 5) {\n        value |= (b & 0x7f) << (7 * c);\n      }\n      ++c;\n    } while ((b & 0x80) !== 0);\n    value |= 0;\n    if (offset === void 0) {\n      this.roffset = loffset;\n      return value;\n    }\n    return { value, length: c };\n  }\n\n  /**\n   * Reads a zig-zag encoded 32bit base 128 variable-length integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number | { value: number, length: number}} The value read if offset is omitted,\n   *      else the value read and the actual number of bytes read\n   */\n  readVarint32ZigZag(offset?: number): NumberValue {\n    let val = this.readVarint32(offset);\n    if (typeof val === 'object') {\n      val.value = SmartBuffer.zigZagDecode32(val.value);\n    } else {\n      val = SmartBuffer.zigZagDecode32(val);\n    }\n    return val;\n  }\n\n  /**\n   * Writes a 64bit base 128 variable-length integer\n   *\n   * @param {ateos.math.Long | string | number} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this | number} this if offset is omitted, else the actual number of bytes written\n   */\n  writeVarint64(value: any, offset?: number) {\n    let loffset: number = offset === void 0 ? this.woffset : offset;\n    if (!this.noAssert) {\n      if (typeof value === 'number') {\n        value = Long.fromNumber(value);\n      } else if (_isString(value)) {\n        value = Long.fromString(value);\n      } else if (!(typeof value === 'object' && value instanceof Long)) {\n        throw new TypeError(`Illegal value: ${value} (not an integer or Long)`);\n      }\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n    if (typeof value === 'number') {\n      value = Long.fromNumber(value, false);\n    } else if (_isString(value)) {\n      value = Long.fromString(value, false);\n    } else if (value.unsigned !== false) {\n      value = value.toSigned();\n    }\n    const size = SmartBuffer.calculateVarint64(value);\n    const part0 = value.toInt() >>> 0;\n    const part1 = value.shru(28).toInt() >>> 0;\n    const part2 = value.shru(56).toInt() >>> 0;\n    loffset += size;\n    let capacity11 = this.buffer.length;\n    if (loffset > capacity11) {\n      this.resize((capacity11 *= 2) > loffset ? capacity11 : loffset);\n    }\n    loffset -= size;\n    // eslint-disable-next-line default-case\n    switch (size) {\n      // @ts-expect-error TS7030\n      case 10:\n        this.buffer[loffset + 9] = (part2 >>> 7) & 0x01;\n      // @ts-expect-error TS7030\n      case 9:\n        this.buffer[loffset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7f;\n      // @ts-expect-error TS7030\n      case 8:\n        this.buffer[loffset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7f;\n      // @ts-expect-error TS7030\n      case 7:\n        this.buffer[loffset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7f;\n      // @ts-expect-error TS7030\n      case 6:\n        this.buffer[loffset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7f;\n      // @ts-expect-error TS7030\n      case 5:\n        this.buffer[loffset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7f;\n      // @ts-expect-error TS7030\n      case 4:\n        this.buffer[loffset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7f;\n      // @ts-expect-error TS7030\n      case 3:\n        this.buffer[loffset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7f;\n      // @ts-expect-error TS7030\n      case 2:\n        this.buffer[loffset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7f;\n      // falls through\n      case 1:\n        this.buffer[loffset] = size !== 1 ? part0 | 0x80 : part0 & 0x7f;\n    }\n    if (offset === void 0) {\n      this.woffset += size;\n      return this;\n    }\n    return size;\n  }\n\n  /**\n   * Writes a zig-zag encoded 64bit base 128 variable-length integer\n   *\n   * @param {ateos.math.I.Longable} value\n   * @param {number} [offset] Offset to write to\n   * @returns {this | number} this if offset is omitted, else the actual number of bytes written\n   */\n  writeVarint64ZigZag(value: any, offset: number) {\n    return this.writeVarint64(SmartBuffer.zigZagEncode64(value), offset);\n  }\n\n  /**\n   * Reads a 64bit base 128 variable-length integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number | { value: ateos.math.Long, c: number }} The value read if offset is omitted,\n   *      else the value read and the actual number of bytes read\n   */\n  readVarint64(offset?: number): LongValue {\n    let loffset = offset === void 0 ? this.roffset : offset;\n    if (!this.noAssert) {\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 1 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (1) <= ${this.buffer.length}`);\n      }\n    }\n    // ref: src/google/protobuf/io/coded_stream.cc\n    const start = loffset;\n    let part0 = 0;\n    let part1 = 0;\n    let part2 = 0;\n    let b = 0;\n    b = this.buffer[loffset++]!;\n    part0 = b & 0x7f;\n    if (b & 0x80) {\n      b = this.buffer[loffset++]!;\n      part0 |= (b & 0x7f) << 7;\n      if (b & 0x80 || (this.noAssert && b === void 0)) {\n        b = this.buffer[loffset++]!;\n        part0 |= (b & 0x7f) << 14;\n        if (b & 0x80 || (this.noAssert && b === void 0)) {\n          b = this.buffer[loffset++]!;\n          part0 |= (b & 0x7f) << 21;\n          if (b & 0x80 || (this.noAssert && b === void 0)) {\n            b = this.buffer[loffset++]!;\n            part1 = b & 0x7f;\n            if (b & 0x80 || (this.noAssert && b === void 0)) {\n              b = this.buffer[loffset++]!;\n              part1 |= (b & 0x7f) << 7;\n              if (b & 0x80 || (this.noAssert && b === void 0)) {\n                b = this.buffer[loffset++]!;\n                part1 |= (b & 0x7f) << 14;\n                if (b & 0x80 || (this.noAssert && b === void 0)) {\n                  b = this.buffer[loffset++]!;\n                  part1 |= (b & 0x7f) << 21;\n                  if (b & 0x80 || (this.noAssert && b === void 0)) {\n                    b = this.buffer[loffset++]!;\n                    part2 = b & 0x7f;\n                    if (b & 0x80 || (this.noAssert && b === void 0)) {\n                      b = this.buffer[loffset++]!;\n                      part2 |= (b & 0x7f) << 7;\n                      if (b & 0x80 || (this.noAssert && b === void 0)) {\n                        throw new RangeError('Buffer overrun');\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    const value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2 << 24), false);\n    if (offset === void 0) {\n      this.roffset = loffset;\n      return value;\n    }\n    return { value, length: loffset - start };\n  }\n\n  /**\n   * Reads a zig-zag encoded 64bit base 128 variable-length integer\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {number | { value: ateos.math.Long, c: number }} The value read if offset is omitted,\n   *      else the value read and the actual number of bytes read\n   */\n  readVarint64ZigZag(offset?: number): LongValue {\n    let val = this.readVarint64(offset);\n    if (typeof val === 'object' && (val as SLong).value instanceof Long) {\n      (val as SLong).value = SmartBuffer.zigZagDecode64((val as SLong).value);\n    } else {\n      val = SmartBuffer.zigZagDecode64(val);\n    }\n    return val;\n  }\n\n  /**\n   * Writes a NULL-terminated UTF8 encoded string.\n   * For this to work the specified string must not contain any NULL characters itself\n   *\n   * @param {string} str\n   * @param {number} [offset] Offset to write to\n   * @returns {this | number} this if offset is omitted, else the actual number of bytes written\n   */\n  writeCString(str: any, offset?: number) {\n    let loffset = offset === void 0 ? this.woffset : offset;\n    let i;\n    let k = str.length;\n    if (!this.noAssert) {\n      if (!_isString(str)) {\n        throw new TypeError('Illegal str: Not a string');\n      }\n      for (i = 0; i < k; ++i) {\n        if (str.charCodeAt(i) === 0) {\n          throw new TypeError('Illegal str: Contains NULL-characters');\n        }\n      }\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n    // UTF8 strings do not contain zero bytes in between except for the zero character, so:\n    k = Buffer.byteLength(str, 'utf8');\n    loffset += k + 1;\n    let capacity12 = this.buffer.length;\n    if (loffset > capacity12) {\n      this.resize((capacity12 *= 2) > loffset ? capacity12 : loffset);\n    }\n    loffset -= k + 1;\n    loffset += this.buffer.write(str, loffset, k, 'utf8');\n    this.buffer[loffset++] = 0;\n    if (offset === void 0) {\n      this.woffset = loffset;\n      return this;\n    }\n    return k;\n  }\n\n  /**\n   * Reads a NULL-terminated UTF8 encoded string.\n   * For this to work the string read must not contain any NULL characters itself\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {string | { string: string, length: number }} The string read if offset is omitted,\n   *      else the string read and the actual number of bytes read\n   */\n  readCString(offset?: number) {\n    let loffset = offset === void 0 ? this.roffset : offset;\n    if (!this.noAssert) {\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${offset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 1 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (1) <= ${this.buffer.length}`);\n      }\n    }\n    const start = loffset;\n    let temp;\n    // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:\n    do {\n      if (loffset >= this.buffer.length) {\n        throw new RangeError(`Index out of range: ${loffset} <= ${this.buffer.length}`);\n      }\n      temp = this.buffer[loffset++];\n    } while (temp !== 0);\n    const str = this.buffer.toString('utf8', start, loffset - 1);\n    if (offset === void 0) {\n      this.roffset = loffset;\n      return str;\n    }\n    return { string: str, length: loffset - start };\n  }\n\n  /**\n   * Writes an UTF8 encoded string\n   *\n   * @param {string} str\n   * @param {offset} offset Offset to write to\n   * @returns {this | number} this if offset is omitted, else the actual number of bytes written\n   */\n  writeString(str: string, offset?: number) {\n    let loffset = offset === void 0 ? this.woffset : offset;\n    if (!this.noAssert) {\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n    const k = Buffer.byteLength(str, 'utf8');\n    loffset += k;\n    let capacity14 = this.buffer.length;\n    if (loffset > capacity14) {\n      capacity14 *= 2;\n      this.resize(capacity14 > loffset ? capacity14 : loffset);\n    }\n    loffset -= k;\n    loffset += this.buffer.write(str, loffset, k, 'utf8');\n    if (offset === void 0) {\n      this.woffset = loffset;\n      return this;\n    }\n    return k;\n  }\n\n  /**\n   * Reads an UTF8 encoded string\n   *\n   * @param {number} length Number of characters or bytes to read\n   * @param {Metrics} [metrics] Metrics specifying what n is meant to count. Defaults to SmartBuffer.METRICS_CHARS(\"c\")\n   * @param {number} [offset] Offset to read from\n   * @returns {string | { string: string, length: number}} The string read if offset is omitted,\n   *      else the string read and the actual number of bytes read\n   */\n  readString(length: number, metrics: any, offset?: number) {\n    if (typeof metrics === 'number') {\n      offset = metrics;\n      metrics = undefined;\n    }\n    let loffset = offset === void 0 ? this.roffset : offset;\n    if (metrics === void 0) {\n      metrics = SmartBuffer.METRICS_CHARS;\n    }\n    if (!this.noAssert) {\n      if (typeof length !== 'number' || length % 1 !== 0) {\n        throw new TypeError(`Illegal length: ${length} (not an integer)`);\n      }\n      length |= 0;\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n\n    const start = loffset;\n    let temp;\n    if (metrics === SmartBuffer.METRICS_CHARS) {\n      // Modern implementation using TextDecoder for UTF-8 decoding\n      const decoder = new TextDecoder('utf-8', { fatal: false });\n      let charCount = 0;\n      let result = '';\n\n      // Read UTF-8 bytes and decode them character by character\n      while (charCount < length && loffset < this.buffer.length) {\n        // Try to decode one character at a time\n        let bytesToRead = 1;\n        let decoded = '';\n\n        // UTF-8 can be 1-4 bytes per character\n        while (bytesToRead <= 4 && loffset + bytesToRead <= this.buffer.length) {\n          const bytes = this.buffer.subarray(loffset, loffset + bytesToRead);\n          decoded = decoder.decode(bytes, { stream: false });\n\n          // Check if we got a valid character (not replacement character U+FFFD)\n          if (decoded && decoded !== '\\uFFFD') {\n            break;\n          }\n          bytesToRead++;\n        }\n\n        if (decoded && decoded !== '\\uFFFD') {\n          result += decoded;\n          charCount += [...decoded].length; // Count actual characters (handles surrogate pairs)\n          loffset += bytesToRead;\n        } else {\n          // Invalid UTF-8 sequence or end of buffer\n          break;\n        }\n      }\n\n      if (charCount !== length) {\n        throw new RangeError(`Illegal range: Truncated data, ${charCount} == ${length}`);\n      }\n\n      if (offset === void 0) {\n        this.roffset = loffset;\n        return result;\n      }\n      return { string: result, length: loffset - start };\n    } else if (metrics === SmartBuffer.METRICS_BYTES) {\n      if (!this.noAssert) {\n        if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n          throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n        }\n        loffset >>>= 0;\n        if (loffset < 0 || loffset + length > this.buffer.length) {\n          throw new RangeError(`Illegal offset: 0 <= ${loffset} (${length}) <= ${this.buffer.length}`);\n        }\n      }\n      temp = this.buffer.toString('utf8', loffset, loffset + length);\n      if (offset === void 0) {\n        this.roffset += length;\n        return temp;\n      }\n      return { string: temp, length };\n    }\n    throw new TypeError(`Unsupported metrics: ${metrics}`);\n  }\n\n  /**\n   * Writes a length as varint32 prefixed UTF8 encoded string\n   *\n   * @param {string} str\n   * @param {number} [offset] Offset to read from\n   * @returns {this | number} this if offset is omitted, else the actual number of bytes written\n   */\n  writeVString(str: string, offset?: number) {\n    let loffset = offset ?? this.woffset;\n    if (!this.noAssert) {\n      if (!_isString(str)) {\n        throw new TypeError('Illegal str: Not a string');\n      }\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n    const start = loffset;\n    const k = Buffer.byteLength(str, 'utf8');\n    const l = SmartBuffer.calculateVarint32(k);\n    loffset += l + k;\n    let capacity15 = this.buffer.length;\n    if (loffset > capacity15) {\n      this.resize((capacity15 *= 2) > loffset ? capacity15 : loffset);\n    }\n    loffset -= l + k;\n    loffset += this.writeVarint32(k, loffset) as number;\n    loffset += this.buffer.write(str, loffset, k, 'utf8');\n    if (offset === void 0) {\n      this.woffset = loffset;\n      return this;\n    }\n    return loffset - start;\n  }\n\n  /**\n   * Reads a length as varint32 prefixed UTF8 encoded string\n   *\n   * @param {number} [offset] Offset to read from\n   * @returns {string | { string: string, length: number }} The string read if offset is omitted,\n   *      else the string read and the actual number of bytes read\n   */\n  readVString(offset?: number) {\n    let loffset = offset ?? this.roffset;\n    if (!this.noAssert) {\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 1 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (1) <= ${this.buffer.length}`);\n      }\n    }\n    const start = loffset;\n    const len = this.readVarint32(loffset);\n    const str = this.readString(\n      (len as SNumber).value,\n      SmartBuffer.METRICS_BYTES,\n      (loffset += (len as SNumber).length)\n    );\n    loffset += str.length;\n    if (offset === void 0) {\n      this.roffset = loffset;\n      return (str as any).string;\n    }\n    return { string: (str as any).string, length: loffset - start };\n  }\n\n  /**\n   * Appends this SmartBuffer's contents to another SmartBuffer.\n   * This will overwrite any contents behind the specified offset up to the length of this SmartBuffer's data\n   *\n   * @param {SmartBuffer} target\n   * @param {number} [offset] Offset to append to\n   * @returns {this}\n   */\n  appendTo(target: SmartBuffer, offset?: number) {\n    target.write(this, offset);\n    return this;\n  }\n\n  /**\n   * Enables or disables assertions of argument types and offsets.\n   * Assertions are enabled by default but you can opt to disable them if your code already makes sure that everything is valid\n   *\n   * @param {boolean} assert\n   */\n  assert(assert: boolean) {\n    this.noAssert = !assert;\n    return this;\n  }\n\n  /**\n   * Resets this SmartBuffer's offsets.\n   *\n   * @returns {this}\n   */\n  reset(resetWOffset = false) {\n    this.roffset = 0;\n    if (resetWOffset) {\n      this.woffset = 0;\n    }\n    return this;\n  }\n\n  /**\n   * Creates a cloned instance of this SmartBuffer, preset with this SmartBuffer's values for roffset and woffset.\n   *\n   * @param {boolean} copy Whether to copy the backing buffer or to return another view on the same, false by default\n   * @param {SmartBuffer}\n   */\n  clone(copy: boolean = false) {\n    const bb = new SmartBuffer(0, this.noAssert);\n    if (copy) {\n      const buffer = Buffer.allocUnsafe(this.buffer.length);\n      this.buffer.copy(buffer);\n      bb.buffer = buffer;\n    } else {\n      bb.buffer = this.buffer;\n    }\n    bb.roffset = this.roffset;\n    bb.woffset = this.woffset;\n    return bb;\n  }\n\n  /**\n   * Compacts this SmartBuffer to be backed by a buffer of its contents' length.\n   * Will set offset = 0 and limit = capacity.\n   *\n   * @param {number} begin Offset to start at, buffer offset by default\n   * @param {number} end Offset to end at, buffer limit by default\n   * @returns {this}\n   */\n  compact(begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.roffset : begin;\n    let lend = end === void 0 ? this.buffer.length : end;\n    if (!this.noAssert) {\n      if (typeof lbegin !== 'number' || lbegin % 1 !== 0) {\n        throw new TypeError('Illegal begin: Not an integer');\n      }\n      lbegin >>>= 0;\n      if (typeof lend !== 'number' || lend % 1 !== 0) {\n        throw new TypeError('Illegal end: Not an integer');\n      }\n      lend >>>= 0;\n      if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n        throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n      }\n    }\n    if (lbegin === 0 && lend === this.buffer.length) {\n      return this; // Already compacted\n    }\n    const len = lend - lbegin;\n    if (len === 0) {\n      this.buffer = EMPTY_BUFFER;\n      this.roffset = 0;\n      this.woffset = 0;\n      return this;\n    }\n    const buffer = Buffer.allocUnsafe(len);\n    this.buffer.copy(buffer, 0, lbegin, lend);\n    this.buffer = buffer;\n    this.woffset -= this.roffset;\n    this.roffset = 0;\n    return this;\n  }\n\n  /**\n   * Creates a copy of this SmartBuffer's contents.\n   *\n   * @param {number} begin Begin offset, buffer offset by default\n   * @param {number} end End offset, buffer limit by default\n   * @returns {SmartBuffer}\n   */\n  copy(begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.roffset : begin;\n    let lend = end === void 0 ? this.woffset : end;\n    if (!this.noAssert) {\n      if (typeof lbegin !== 'number' || lbegin % 1 !== 0) {\n        throw new TypeError('Illegal begin: Not an integer');\n      }\n      lbegin >>>= 0;\n      if (typeof lend !== 'number' || lend % 1 !== 0) {\n        throw new TypeError('Illegal end: Not an integer');\n      }\n      lend >>>= 0;\n      if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n        throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n      }\n    }\n    if (lbegin === lend) {\n      return new SmartBuffer(0, this.noAssert);\n    }\n    const capacity = lend - lbegin;\n    const bb = new SmartBuffer(capacity, this.noAssert);\n    bb.roffset = 0;\n    bb.woffset = 0;\n    this.copyTo(bb, 0, lbegin, lend);\n    return bb;\n  }\n\n  /**\n   * Copies this SmartBuffer's contents to another SmartBuffer.\n   *\n   * @param {SmartBuffer} target\n   * @param {number} [targetOffset] Offset to copy to. Will use and increase the target's offset by the number of bytes copied if omitted\n   * @param {number} [sourceStart] Offset to start copying from. Will use and increase offset by the number of bytes copied if omitted\n   * @param {number} [sourceEnd] Offset to end copying from, defaults to the buffer limit\n   * @returns {this}\n   */\n  copyTo(target: SmartBuffer, targetOffset?: number, sourceStart?: number, sourceEnd?: number) {\n    if (!this.noAssert) {\n      if (!(target instanceof SmartBuffer)) {\n        throw new TypeError(\"'target' is not a SmartBuffer\");\n      }\n    }\n    const ltargetOffset = targetOffset === void 0 ? target.woffset : targetOffset | 0;\n    const lsourceStart = sourceStart === void 0 ? this.roffset : sourceStart | 0;\n    const lsourceEnd = sourceEnd === void 0 ? this.woffset : sourceEnd | 0;\n\n    if (ltargetOffset < 0 || ltargetOffset > target.buffer.length) {\n      throw new RangeError(`Illegal target range: 0 <= ${ltargetOffset} <= ${target.buffer.length}`);\n    }\n    if (lsourceStart < 0 || lsourceEnd > this.buffer.length) {\n      throw new RangeError(`Illegal source range: 0 <= ${lsourceStart} <= ${this.buffer.length}`);\n    }\n\n    const len = lsourceEnd - lsourceStart;\n    if (len === 0) {\n      return target; // Nothing to copy\n    }\n\n    target.ensureCapacity(ltargetOffset + len);\n\n    this.buffer.copy(target.buffer, ltargetOffset, lsourceStart, lsourceEnd);\n\n    if (sourceStart === void 0) {\n      this.roffset += len;\n    }\n    if (targetOffset === void 0) {\n      target.woffset += len;\n    }\n\n    return this;\n  }\n\n  /**\n   * Makes sure that this SmartBuffer is backed by a SmartBuffer#buffer of at least the specified capacity.\n   * If the current capacity is exceeded, it will be doubled.\n   * If double the current capacity is less than the required capacity, the required capacity will be used instead\n   *\n   * @param {number} capacity\n   * @returns {this}\n   */\n  ensureCapacity(capacity: number) {\n    let current = this.buffer.length;\n    if (current < capacity) {\n      return this.resize((current *= 2) > capacity ? current : capacity);\n    }\n    return this;\n  }\n\n  /**\n   * Overwrites this SmartBuffer's contents with the specified value.\n   *\n   * @param {number | string} value Byte value to fill with. If given as a string, the first character is used\n   * @param {number} [begin] Begin offset. Will use and increase offset by the number of bytes written if omitted. defaults to offset\n   * @param {number} [end] End offset, defaults to limit.\n   * @returns {this}\n   */\n  fill(value: any, begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.woffset : begin;\n    if (_isString(value) && value.length > 0) {\n      value = value.charCodeAt(0);\n    }\n    // When end is not specified, determine the appropriate default:\n    // Use buffer.length to maintain backward compatibility\n    let lend = end === void 0 ? this.buffer.length : end;\n\n    if (!this.noAssert) {\n      if (typeof value !== 'number' || value % 1 !== 0) {\n        throw new TypeError(`Illegal value: ${value} (not an integer)`);\n      }\n      value |= 0;\n      if (typeof lbegin !== 'number' || lbegin % 1 !== 0) {\n        throw new TypeError('Illegal begin: Not an integer');\n      }\n      lbegin >>>= 0;\n      if (typeof lend !== 'number' || lend % 1 !== 0) {\n        throw new TypeError('Illegal end: Not an integer');\n      }\n      lend >>>= 0;\n      if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n        throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n      }\n    }\n    if (lbegin >= lend) {\n      return this; // Nothing to fill\n    }\n    this.buffer.fill(value, lbegin, lend);\n    if (begin === void 0) {\n      this.woffset = lend;\n    }\n    return this;\n  }\n\n  /**\n   * Prepends some data to this SmartBuffer.\n   * This will overwrite any contents before the specified offset up to the prepended data's length.\n   * If there is not enough space available before the specified offset,\n   * the backing buffer will be resized and its contents moved accordingly\n   *\n   * @param {Wrappable} source Data to prepend\n   * @param {string} [encoding] Encoding if data is a string\n   * @param {number} [offset] Offset to prepend at. Will use and decrease offset by the number of bytes prepended if omitted.\n   * @returns {this}\n   */\n  prepend(source: any, offset?: number, encoding?: any) {\n    let loffset = offset === void 0 ? this.roffset : offset;\n    if (!this.noAssert) {\n      if (typeof loffset !== 'number' || loffset % 1 !== 0) {\n        throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n      }\n      loffset >>>= 0;\n      if (loffset < 0 || loffset + 0 > this.buffer.length) {\n        throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n      }\n    }\n    if (!(source instanceof SmartBuffer)) {\n      source = SmartBuffer.wrap(source, encoding);\n    }\n    const len = source.buffer.length - source.roffset;\n    if (len <= 0) {\n      return this; // Nothing to prepend\n    }\n    const diff = len - loffset;\n    if (diff > 0) {\n      // Not enough space before offset, so resize + move\n      const buffer = Buffer.allocUnsafe(this.buffer.length + diff);\n      this.buffer.copy(buffer, len, loffset, this.buffer.length);\n      this.buffer = buffer;\n      this.roffset += diff;\n      this.woffset += diff;\n      loffset += diff;\n    }\n    source.buffer.copy(this.buffer, loffset - len, source.roffset, source.buffer.length);\n\n    source.roffset = source.buffer.length;\n    if (offset === void 0) {\n      this.roffset -= len;\n    }\n    return this;\n  }\n\n  /**\n   * Prepends this SmartBuffer to another SmartBuffer.\n   * This will overwrite any contents before the specified offset up to the prepended data's length.\n   * If there is not enough space available before the specified offset,\n   * the backing buffer will be resized and its contents moved accordingly\n   *\n   * @param {Wrappable} target\n   * @param {number} offset Offset to prepend at\n   */\n  prependTo(target: any, offset?: number) {\n    target.prepend(this, offset);\n    return this;\n  }\n\n  /**\n   * Resizes this SmartBuffer to be backed by a buffer of at least the given capacity.\n   * Will do nothing if already that large or larger.\n   *\n   * @param {number} capacity\tCapacity required\n   * @returns {this}\n   */\n  resize(capacity: number) {\n    if (!this.noAssert) {\n      if (typeof capacity !== 'number' || capacity % 1 !== 0) {\n        throw new TypeError(`'capacity' is not an integer: ${capacity}`);\n      }\n      capacity |= 0;\n      if (capacity < 0) {\n        throw new TypeError(`Not valid capacity value: 0 <= ${capacity}`);\n      }\n    }\n    if (this.buffer.length < capacity) {\n      const buffer = Buffer.allocUnsafe(capacity);\n      this.buffer.copy(buffer);\n      this.buffer = buffer;\n    }\n    return this;\n  }\n\n  /**\n   * Reverses this SmartBuffer's contents.\n   *\n   * @param {number} [begin] Offset to start at, defaults to roffset\n   * @param {number} [end] Offset to end at, defaults to woffset\n   * @returns {this}\n   */\n  reverse(begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.roffset : begin;\n    let lend = end === void 0 ? this.woffset : end;\n    if (!this.noAssert) {\n      if (typeof lbegin !== 'number' || lbegin % 1 !== 0) {\n        throw new TypeError('Illegal begin: Not an integer');\n      }\n      lbegin >>>= 0;\n      if (typeof lend !== 'number' || lend % 1 !== 0) {\n        throw new TypeError('Illegal end: Not an integer');\n      }\n      lend >>>= 0;\n      if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n        throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n      }\n    }\n    if (lbegin === lend) {\n      return this; // Nothing to reverse\n    }\n    Array.prototype.reverse.call(this.buffer.slice(lbegin, lend));\n    return this;\n  }\n\n  /**\n   * Skips the next length bytes. This will just advance.\n   *\n   * @param {number} length\n   * @returns {this}\n   */\n  skipRead(length: number) {\n    if (!this.noAssert) {\n      if (typeof length !== 'number' || length % 1 !== 0) {\n        throw new TypeError(`Illegal length: ${length} (not an integer)`);\n      }\n      length |= 0;\n    }\n    const offset = this.roffset + length;\n    if (!this.noAssert) {\n      if (offset < 0 || offset > this.buffer.length) {\n        throw new RangeError(`Illegal length: 0 <= ${this.roffset} + ${length} <= ${this.buffer.length}`);\n      }\n    }\n    this.roffset = offset;\n    return this;\n  }\n\n  /**\n   * Skips the next length bytes. This will just advance.\n   *\n   * @param {number} length\n   * @returns {this}\n   */\n  skipWrite(length: number) {\n    if (!this.noAssert) {\n      if (typeof length !== 'number' || length % 1 !== 0) {\n        throw new TypeError(`Illegal length: ${length} (not an integer)`);\n      }\n      length |= 0;\n    }\n    const offset = this.woffset + length;\n    if (!this.noAssert) {\n      if (offset < 0 || offset > this.buffer.length) {\n        throw new RangeError(`Illegal length: 0 <= ${this.woffset} + ${length} <= ${this.buffer.length}`);\n      }\n    }\n    this.woffset = offset;\n    return this;\n  }\n\n  /**\n   * Slices this SmartBuffer by creating a cloned instance with roffset = begin and woffset = end\n   *\n   * @param {number} [begin] Begin offset, defaults to offset\n   * @param {number} [end] End offset, defaults to limit\n   * @returns {SmartBuffer}\n   */\n  slice(begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.roffset : begin;\n    let lend = end === void 0 ? this.woffset : end;\n    if (!this.noAssert) {\n      if (typeof lbegin !== 'number' || lbegin % 1 !== 0) {\n        throw new TypeError('Illegal begin: Not an integer');\n      }\n      lbegin >>>= 0;\n      if (typeof end !== 'number' || lend % 1 !== 0) {\n        throw new TypeError('Illegal end: Not an integer');\n      }\n      lend >>>= 0;\n      if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n        throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n      }\n    }\n    const bb = new SmartBuffer(lend - lbegin);\n    bb.buffer = this.buffer.slice(begin, lend);\n    bb.woffset = bb.capacity;\n    return bb;\n  }\n\n  /**\n   * Returns a copy of the backing buffer that contains this SmartBuffer's contents.\n   *\n   * @param {boolean} [forceCopy] If true returns a copy, otherwise returns a view referencing the same memory if possible,\n   *      false by default\n   * @param {number} [begin] Begin offset, roffset by default\n   * @param {number} [end] End offset, woffset by default\n   * @returns {Buffer}\n   */\n  toBuffer(forceCopy: boolean = false, begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.roffset : begin;\n    let lend = end === void 0 ? this.woffset : end;\n    lbegin >>>= 0;\n    lend >>>= 0;\n    if (!this.noAssert) {\n      if (typeof lbegin !== 'number' || lbegin % 1 !== 0) {\n        throw new TypeError('Illegal begin: Not an integer');\n      }\n      if (typeof lend !== 'number' || lend % 1 !== 0) {\n        throw new TypeError('Illegal end: Not an integer');\n      }\n      if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n        throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n      }\n    }\n    if (forceCopy) {\n      const buffer = Buffer.allocUnsafe(lend - lbegin);\n      this.buffer.copy(buffer, 0, lbegin, end);\n      return buffer;\n    }\n    if (lbegin === 0 && lend === this.buffer.length) {\n      return this.buffer;\n    }\n    return this.buffer.slice(lbegin, lend);\n  }\n\n  /**\n   * Returns a raw buffer compacted to contain this SmartBuffer's contents\n   *\n   * @returns {ArrayBuffer}\n   */\n  toArrayBuffer() {\n    let offset = this.roffset;\n    let limit = this.woffset;\n    if (!this.noAssert) {\n      if (offset === void 0 || offset % 1 !== 0) {\n        throw new TypeError('Illegal offset: Not an integer');\n      }\n      offset >>>= 0;\n      if (typeof limit !== 'number' || limit % 1 !== 0) {\n        throw new TypeError('Illegal limit: Not an integer');\n      }\n      limit >>>= 0;\n      if (offset < 0 || offset > limit || limit > this.buffer.length) {\n        throw new RangeError(`Illegal range: 0 <= ${offset} <= ${limit} <= ${this.buffer.length}`);\n      }\n    }\n    const ab = new ArrayBuffer(limit - offset);\n    const dst = new Uint8Array(ab);\n    this.buffer.copy(dst);\n    return ab;\n  }\n\n  /**\n   * Converts the SmartBuffer's contents to a string\n   *\n   * @param {string} encoding Output encoding\n   * @param {number} [begin] Begin offset, offset by default\n   * @param {number} [end] End offset, limit by default\n   * @returns {string}\n   */\n  toString(encoding?: string, begin?: number, end?: number) {\n    if (encoding === void 0) {\n      return `ByteArrayNB(roffset=${this.roffset},woffset=${this.woffset},capacity=${this.capacity})`;\n    }\n\n    switch (encoding) {\n      case 'utf8':\n        return this.toUTF8(begin, end);\n      case 'base64':\n        return this.toBase64(begin, end);\n      case 'hex':\n        return this.toHex(begin, end);\n      case 'binary':\n        return this.toBinary(begin, end);\n      case 'debug':\n        return this.toDebug();\n      default:\n        throw new TypeError(`Unsupported encoding: ${encoding}`);\n    }\n  }\n\n  /**\n   * Encodes this SmartBuffer's contents to a base64 encoded string\n   *\n   * @param {number} [begin] Begin offset, offset by default\n   * @param {number} [end] End offset, limit by default\n   * @returns {string}\n   */\n  toBase64(begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.roffset : begin;\n    let lend = end === void 0 ? this.woffset : end;\n    lbegin |= 0;\n    lend |= 0;\n    if (lbegin < 0 || lend > this.buffer.length || lbegin > lend) {\n      throw new RangeError('begin, end');\n    }\n    return this.buffer.toString('base64', lbegin, lend);\n  }\n\n  /**\n   * Encodes this SmartBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes\n   *\n   * @param {number} [begin] Begin offset, offset by default\n   * @param {number} [end] End offset, limit by default\n   * @returns {string}\n   */\n  toBinary(begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.roffset : begin;\n    let lend = end === void 0 ? this.woffset : end;\n    lbegin |= 0;\n    lend |= 0;\n    if (lbegin < 0 || lend > this.capacity || lbegin > lend) {\n      throw new RangeError('begin, end');\n    }\n    return this.buffer.toString('binary', lbegin, lend);\n  }\n\n  /**\n   * Encodes this SmartBuffer to a hex encoded string with marked offsets\n   *\n   * '<' - roffset\n   * '>' - woffset\n   * '|' - roffset=woffset=capacity\n   * '^' - roffset=woffset\n   * ']' - woffset=capacity\n   * '*' - capacity\n   *\n   * @param {boolean} [columns] If true returns two columns hex + ascii, defaults to false\n   * @returns {string}\n   */\n  toDebug(columns: boolean = false) {\n    let i = -1;\n    const k = this.buffer.length;\n    let b;\n    let hex = '';\n    let asc = '';\n    let out = '';\n    while (i < k) {\n      if (i !== -1) {\n        b = this.buffer[i]!;\n        if (b < 0x10) {\n          hex += `0${b.toString(16).toUpperCase()}`;\n        } else {\n          hex += b.toString(16).toUpperCase();\n        }\n        if (columns) {\n          asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';\n        }\n      }\n      ++i;\n      if (columns) {\n        if (i > 0 && i % 16 === 0 && i !== k) {\n          while (hex.length < 3 * 16 + 3) {\n            hex += ' ';\n          }\n          out += `${hex + asc}\\n`;\n          hex = asc = '';\n        }\n      }\n      if (i === this.roffset && this.roffset === this.woffset && this.woffset === this.buffer.length) {\n        hex += '|';\n      } else if (i === this.roffset && this.roffset === this.woffset) {\n        hex += '^';\n      } else if (i === this.roffset && this.roffset === this.buffer.length) {\n        hex += '[';\n      } else if (i === this.woffset && this.woffset === this.buffer.length) {\n        hex += ']';\n      } else if (i === this.roffset) {\n        hex += '<';\n      } else if (i === this.woffset) {\n        hex += '>';\n      } else if (i === this.buffer.length) {\n        hex += '*';\n      } else {\n        hex += columns || (i !== 0 && i !== k) ? ' ' : '';\n      }\n    }\n    if (columns && hex !== ' ') {\n      while (hex.length < 3 * 16 + 3) {\n        hex += ' ';\n      }\n      out += `${hex + asc}\\n`;\n    }\n    return columns ? out : hex;\n  }\n\n  /**\n   * Encodes this SmartBuffer's contents to a hex encoded string\n   *\n   * @param {number} [begin] Begin offset, offset by default\n   * @param {number} [end] End offset, limit by default\n   * @returns {string}\n   */\n  toHex(begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.roffset : begin;\n    let lend = end === void 0 ? this.woffset : end;\n    if (!this.noAssert) {\n      if (typeof lbegin !== 'number' || lbegin % 1 !== 0) {\n        throw new TypeError('Illegal begin: Not an integer');\n      }\n      lbegin >>>= 0;\n      if (typeof lend !== 'number' || lend % 1 !== 0) {\n        throw new TypeError('Illegal end: Not an integer');\n      }\n      lend >>>= 0;\n      if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n        throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n      }\n    }\n    return this.buffer.toString('hex', lbegin, lend);\n  }\n\n  /**\n   * Encodes this SmartBuffer's contents to an UTF8 encoded string\n   *\n   * @param {number} [begin] Begin offset, offset by default\n   * @param {number} [end] End offset, limit by default\n   * @returns {string}\n   */\n  toUTF8(begin?: number, end?: number) {\n    let lbegin = begin === void 0 ? this.roffset : begin;\n    let lend = end === void 0 ? this.woffset : end;\n    if (!this.noAssert) {\n      if (typeof lbegin !== 'number' || lbegin % 1 !== 0) {\n        throw new TypeError('Illegal begin: Not an integer');\n      }\n      lbegin >>>= 0;\n      if (typeof lend !== 'number' || lend % 1 !== 0) {\n        throw new TypeError('Illegal end: Not an integer');\n      }\n      lend >>>= 0;\n      if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n        throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n      }\n    }\n    return this.buffer.toString('utf8', lbegin, lend);\n  }\n\n  /**\n   * Allocates a new SmartBuffer backed by a buffer of the specified capacity.\n   *\n   * @param {number} [capacity] Initial capacity. Defaults to SmartBuffer.DEFAULT_CAPACITY(64)\n   * @param {boolean} [noAssert] Whether to skip assertions of offsets and values. Defaults to SmartBuffer.DEFAULT_NOASSERT(false)\n   */\n  static alloc(capacity?: number, noAssert: boolean = SmartBuffer.DEFAULT_NOASSERT) {\n    return new SmartBuffer(capacity, noAssert);\n  }\n\n  /**\n   * Concatenates multiple ByteArrays into one\n   *\n   * @param {Wrappable[]} buffers\n   * @param {string} encoding Encoding for strings\n   * @param {boolean} noAssert Whether to skip assertions of offsets and values. Defaults to SmartBuffer.DEFAULT_NOASSERT(false)\n   */\n  static concat(buffers: any[], encoding?: any, noAssert: boolean = SmartBuffer.DEFAULT_NOASSERT) {\n    let capacity = 0;\n    const k = buffers.length;\n    let i = 0;\n    let length;\n    for (; i < k; ++i) {\n      if (!(buffers[i] instanceof SmartBuffer)) {\n        buffers[i] = SmartBuffer.wrap(buffers[i], encoding);\n      }\n      length = buffers[i].woffset - buffers[i].roffset;\n      if (length > 0) {\n        capacity += length;\n      }\n    }\n    if (capacity === 0) {\n      return new SmartBuffer(0, noAssert);\n    }\n    const bb = new SmartBuffer(capacity, noAssert);\n    let bi;\n    i = 0;\n\n    while (i < k) {\n      bi = buffers[i++];\n      length = bi.woffset - bi.roffset;\n      if (length <= 0) {\n        continue;\n      }\n      bi.buffer.copy(bb.buffer, bb.woffset, bi.roffset, bi.woffset);\n      bb.woffset += length;\n    }\n    bb.roffset = 0;\n    return bb;\n  }\n\n  /**\n   * Wraps a buffer or a string.\n   * Sets the allocated SmartBuffer's offset to 0 and its limit to the length of the wrapped data\n   *\n   * @param {Wrappable} buffer\n   * @param {string} encoding Encoding for strings\n   * @param {boolean} noAssert Whether to skip assertions of offsets and values. Defaults to SmartBuffer.DEFAULT_NOASSERT(false)\n   */\n  static wrap(buffer: any, encoding?: string, noAssert?: boolean): SmartBuffer {\n    if (_isString(buffer)) {\n      if (encoding === void 0) {\n        encoding = 'utf8';\n      }\n      switch (encoding) {\n        case 'base64':\n          return SmartBuffer.fromBase64(buffer);\n        case 'hex':\n          return SmartBuffer.fromHex(buffer);\n        case 'binary':\n          return SmartBuffer.fromBinary(buffer);\n        case 'utf8':\n          return SmartBuffer.fromUTF8(buffer);\n        case 'debug':\n          return SmartBuffer.fromDebug(buffer);\n        default:\n          throw new TypeError(`Unsupported encoding: ${encoding}`);\n      }\n    }\n\n    let bb;\n    if (buffer instanceof SmartBuffer) {\n      bb = buffer.clone();\n      return bb;\n    }\n\n    let b;\n\n    if (buffer instanceof Uint8Array) {\n      // Extract bytes from Uint8Array\n      b = Buffer.from(buffer);\n      buffer = b;\n    } else if (buffer instanceof ArrayBuffer) {\n      // Convert ArrayBuffer to Buffer\n      b = Buffer.from(buffer);\n      buffer = b;\n    } else if (!(buffer instanceof Buffer)) {\n      // Create from octets if it is an error, otherwise fail\n      if (!Array.isArray(buffer)) {\n        throw new TypeError('Illegal buffer');\n      }\n      buffer = Buffer.from(buffer);\n    }\n    bb = new SmartBuffer(0, noAssert);\n    if (buffer.length > 0) {\n      // Avoid references to more than one EMPTY_BUFFER\n      bb.buffer = buffer;\n      bb.woffset = buffer.length;\n    }\n    return bb;\n  }\n\n  /**\n   * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer\n   *\n   * @param {number} value\n   * @returns {number}\n   */\n  static calculateVarint32(value: number): number {\n    value = value >>> 0;\n    if (value < 1 << 7) {\n      return 1;\n    } else if (value < 1 << 14) {\n      return 2;\n    } else if (value < 1 << 21) {\n      return 3;\n    } else if (value < 1 << 28) {\n      return 4;\n    }\n    return 5;\n  }\n\n  /**\n   * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding\n   *\n   * @param {number} n\n   * @returns {number}\n   */\n  static zigZagEncode32(n: number) {\n    return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h\n  }\n\n  /**\n   * Decodes a zigzag encoded signed 32bit integer\n   *\n   * @param {number}\n   * @returns {number}\n   */\n  static zigZagDecode32(n: number) {\n    return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h\n  }\n\n  /**\n   * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer\n   *\n   * @param {ateos.math.Long | number | string} value\n   * @returns {number}\n   */\n  static calculateVarint64(value: string | number | Long) {\n    let lValue: Long;\n    if (typeof value === 'number') {\n      lValue = Long.fromNumber(value);\n    } else if (_isString(value)) {\n      lValue = Long.fromString(value as string);\n    } else {\n      lValue = value as Long;\n    }\n    // ref: src/google/protobuf/io/coded_stream.cc\n    const part0 = lValue.toInt() >>> 0;\n    const part1 = lValue.shru(28).toInt() >>> 0;\n    const part2 = lValue.shru(56).toInt() >>> 0;\n    if (part2 === 0) {\n      if (part1 === 0) {\n        if (part0 < 1 << 14) {\n          return part0 < 1 << 7 ? 1 : 2;\n        }\n        return part0 < 1 << 21 ? 3 : 4;\n      }\n      if (part1 < 1 << 14) {\n        return part1 < 1 << 7 ? 5 : 6;\n      }\n      return part1 < 1 << 21 ? 7 : 8;\n    }\n    return part2 < 1 << 7 ? 9 : 10;\n  }\n\n  /**\n   * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding\n   *\n   * @param {ateos.math.Long | number | string} value\n   * @returns {ateos.math.Long}\n   */\n  static zigZagEncode64(value: string | number | LongValue) {\n    let lValue: Long;\n    if (typeof value === 'number') {\n      lValue = Long.fromNumber(value as number, false);\n    } else if (_isString(value)) {\n      lValue = Long.fromString(value as string, false);\n    } else if ((value as Long).unsigned !== false) {\n      lValue = (value as Long).toSigned();\n    } else {\n      lValue = value as Long;\n    }\n    // ref: src/google/protobuf/wire_format_lite.h\n    return lValue.shl(1).xor(lValue.shr(63)).toUnsigned();\n  }\n\n  /**\n   * Decodes a zigzag encoded signed 64bit integer.\n   *\n   * @param {ateos.math.Long | number | string} value\n   * @returns {ateos.math.Long}\n   */\n  static zigZagDecode64(value: string | number | LongValue) {\n    let lValue: Long;\n    if (typeof value === 'number') {\n      lValue = Long.fromNumber(value as number, false);\n    } else if (_isString(value)) {\n      lValue = Long.fromString(value as string, false);\n    } else if ((value as Long).unsigned !== false) {\n      lValue = (value as Long).toSigned();\n    } else {\n      lValue = value as Long;\n    }\n    // ref: src/google/protobuf/wire_format_lite.h\n    return lValue.shru(1).xor(lValue.and(Long.ONE).toSigned().negate()).toSigned();\n  }\n\n  /**\n   * Calculates the number of UTF8 characters of a string.\n   * JavaScript itself uses UTF-16, so that a string's length property does not reflect its actual UTF8 size\n   * if it contains code points larger than 0xFFFF\n   *\n   * @param {string} str\n   * @returns {number}\n   */\n  static calculateUTF8Chars(str: string) {\n    // Modern implementation: count actual Unicode code points\n    // This handles surrogate pairs correctly\n    return [...str].length;\n  }\n\n  /**\n   *  Calculates the number of UTF8 bytes of a string.\n   *\n   * @param {string} str\n   * @returns {number}\n   */\n  static calculateString(str: string) {\n    if (!_isString(str)) {\n      throw new TypeError(`Illegal argument: ${typeof str}`);\n    }\n    return Buffer.byteLength(str, 'utf8');\n  }\n\n  /**\n   * Decodes a base64 encoded string to a SmartBuffer\n   *\n   * @param {string} str\n   * @returns {SmartBuffer}\n   */\n  static fromBase64(str: string) {\n    return SmartBuffer.wrap(Buffer.from(str, 'base64'));\n  }\n\n  /**\n   * Encodes a binary string to base64 like window.btoa does\n   *\n   * @param {string} str\n   * @returns {SmartBuffer}\n   */\n  static btoa(str: string) {\n    return SmartBuffer.fromBinary(str).toBase64();\n  }\n\n  /**\n   * Decodes a base64 encoded string to binary like window.atob does\n   *\n   * @param {string} b64\n   * @returns {SmartBuffer}\n   */\n  static atob(b64: string) {\n    return SmartBuffer.fromBase64(b64).toBinary();\n  }\n\n  /**\n   * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a SmartBuffer\n   *\n   * @param {string} str\n   * @returns {SmartBuffer}\n   */\n  static fromBinary(str: string) {\n    return SmartBuffer.wrap(Buffer.from(str, 'binary'));\n  }\n\n  /**\n   * Decodes a hex encoded string with marked offsets to a SmartBuffer\n   *\n   * @param {string} str\n   * @param {boolean} [noAssert]\n   * @returns {SmartBuffer}\n   */\n  static fromDebug(str: string, noAssert: boolean = SmartBuffer.DEFAULT_NOASSERT) {\n    const k = str.length;\n    const bb = new SmartBuffer(((k + 1) / 3) | 0, noAssert);\n    let i = 0;\n    let j = 0;\n    let ch;\n    let b;\n    let rs = false; // Require symbol next\n    let hw = false;\n    let hr = false;\n    let hl = false;\n    let fail = false;\n    while (i < k) {\n      switch ((ch = str.charAt(i++))) {\n        case '|':\n          if (!noAssert) {\n            if (hr || hw || hl) {\n              fail = true;\n              break;\n            }\n            hr = hw = hl = true;\n          }\n          bb.roffset = bb.woffset = j;\n          rs = false;\n          break;\n        case ']':\n          if (!noAssert) {\n            if (hw || hl) {\n              fail = true;\n              break;\n            }\n            hw = hl = true;\n          }\n          bb.woffset = j;\n          rs = false;\n          break;\n        case '^':\n          if (!noAssert) {\n            if (hr || hw) {\n              fail = true;\n              break;\n            }\n            hr = hw = true;\n          }\n          bb.roffset = bb.woffset = j;\n          rs = false;\n          break;\n        case '<':\n          if (!noAssert) {\n            if (hr) {\n              fail = true;\n              break;\n            }\n            hr = true;\n          }\n          bb.roffset = j;\n          rs = false;\n          break;\n        case '*':\n          if (!noAssert) {\n            if (hl) {\n              fail = true;\n              break;\n            }\n            hl = true;\n          }\n          rs = false;\n          break;\n        case '>':\n          if (!noAssert) {\n            if (hw) {\n              fail = true;\n              break;\n            }\n            hw = true;\n          }\n          bb.woffset = j;\n          rs = false;\n          break;\n        case ' ':\n          rs = false;\n          break;\n        default:\n          if (!noAssert) {\n            if (rs) {\n              fail = true;\n              break;\n            }\n          }\n          b = parseInt(ch + str.charAt(i++), 16);\n          if (!noAssert) {\n            if (isNaN(b) || b < 0 || b > 255) {\n              throw new RangeError('Not a debug encoded string');\n            }\n          }\n          bb.buffer[j++] = b;\n          rs = true;\n      }\n      if (fail) {\n        throw new RangeError(`Invalid symbol at ${i}`);\n      }\n    }\n    if (!noAssert) {\n      if (!hr || !hw || !hl) {\n        throw new RangeError(`Missing roffset or woffset or limit: ${str}`);\n      }\n      if (j < bb.buffer.length) {\n        throw new RangeError(`Not a debug encoded string (is it hex?) ${j} < ${k}`);\n      }\n    }\n    return bb;\n  }\n\n  /**\n   * Decodes a hex encoded string to a SmartBuffer\n   *\n   * @param {string} str\n   * @param {boolean} [noAssert]\n   */\n  static fromHex(str: string, noAssert: boolean = SmartBuffer.DEFAULT_NOASSERT) {\n    if (!noAssert) {\n      if (!_isString(str)) {\n        throw new TypeError('Illegal str: Not a string');\n      }\n      if (str.length % 2 !== 0) {\n        throw new TypeError('Illegal str: Length not a multiple of 2');\n      }\n    }\n    const bb = new SmartBuffer(0, true);\n    bb.buffer = Buffer.from(str, 'hex');\n    bb.woffset = bb.buffer.length;\n    return bb;\n  }\n\n  /**\n   * Decodes an UTF8 encoded string to a SmartBuffer\n   *\n   * @param {string} str\n   * @param {boolean} [noAssert]\n   * @returns {SmartBuffer}\n   */\n  static fromUTF8(str: string, noAssert: boolean = SmartBuffer.DEFAULT_NOASSERT) {\n    if (!noAssert) {\n      if (!_isString(str)) {\n        throw new TypeError('Illegal str: Not a string');\n      }\n    }\n    const bb = new SmartBuffer(0, noAssert);\n    bb.buffer = Buffer.from(str, 'utf8');\n    bb.woffset = bb.buffer.length;\n    return bb;\n  }\n}\n", "/**\n * The maximum value that can be used for unique identifiers (UIDs) in the Netron system.\n * This value is derived from Number.MAX_SAFE_INTEGER with an unsigned right shift operation\n * to ensure it's a valid 32-bit unsigned integer. This is crucial for maintaining\n * compatibility with network protocols and binary operations.\n *\n * @constant {number} MAX_UID_VALUE\n * @see Number.MAX_SAFE_INTEGER\n */\nexport const MAX_UID_VALUE = Number.MAX_SAFE_INTEGER >>> 0;\n\n/**\n * A unique Symbol used for context isolation in the Netron framework.\n * This symbol is used to mark and identify context-specific properties and methods,\n * ensuring proper isolation between different execution contexts.\n *\n * @constant {symbol} CONTEXTIFY_SYMBOL\n */\nexport const CONTEXTIFY_SYMBOL = Symbol();\n\n/**\n * Event emitted when a service is exposed to the network.\n * This event is triggered when a service becomes available for remote access,\n * allowing other peers to discover and interact with it.\n *\n * @constant {string} NETRON_EVENT_SERVICE_EXPOSE\n */\nexport const NETRON_EVENT_SERVICE_EXPOSE = 'service:expose';\n\n/**\n * Event emitted when a service is unexposed from the network.\n * This event indicates that a previously available service is no longer\n * accessible to remote peers.\n *\n * @constant {string} NETRON_EVENT_SERVICE_UNEXPOSE\n */\nexport const NETRON_EVENT_SERVICE_UNEXPOSE = 'service:unexpose';\n\n/**\n * Event emitted when a new peer connects to the network.\n * This event is triggered when a new peer successfully establishes\n * a connection and becomes part of the Netron network.\n *\n * @constant {string} NETRON_EVENT_PEER_CONNECT\n */\nexport const NETRON_EVENT_PEER_CONNECT = 'peer:connect';\n\n/**\n * Event emitted when a peer disconnects from the network.\n * This event indicates that a previously connected peer has\n * terminated its connection or become unavailable.\n *\n * @constant {string} NETRON_EVENT_PEER_DISCONNECT\n */\nexport const NETRON_EVENT_PEER_DISCONNECT = 'peer:disconnect';\n\n/**\n * The maximum time (in milliseconds) allowed for establishing a connection\n * with a remote peer. If the connection is not established within this timeframe,\n * the connection attempt will be considered failed.\n *\n * @constant {number} CONNECT_TIMEOUT\n */\nexport const CONNECT_TIMEOUT = 5000;\n\n/**\n * The maximum time (in milliseconds) allowed for a request to complete.\n * If a response is not received within this timeframe, the request\n * will be considered timed out and an error will be raised.\n *\n * @constant {number} REQUEST_TIMEOUT\n */\nexport const REQUEST_TIMEOUT = 5000;\n", "import { MAX_UID_VALUE } from './constants.js';\n\n/**\n * A class that provides functionality for generating and managing unique identifiers (UIDs)\n * within the Netron system. This implementation ensures thread-safe and sequential\n * generation of unique identifiers while maintaining a strict upper bound.\n *\n * @class Uid\n * @description Core identifier generation system for packet tracking and correlation\n * @property {number} value - Current UID value, stored as an unsigned 32-bit integer\n */\nexport class Uid {\n  /**\n   * Current UID value, stored as an unsigned 32-bit integer.\n   * The value is initialized using a zero-fill right shift to ensure proper\n   * unsigned integer representation.\n   *\n   * @private\n   * @type {number}\n   */\n  private value: number = 0 >>> 0;\n\n  /**\n   * Creates a new Uid instance with an optional initial value.\n   * The constructor ensures proper initialization by calling reset() with\n   * the provided initial value.\n   *\n   * @constructor\n   * @param {number} [initialValue=0] - The starting value for UID generation\n   */\n  constructor(initialValue: number = 0) {\n    this.reset(initialValue);\n  }\n\n  /**\n   * Generates the next unique identifier in sequence.\n   * This method implements a circular counter that wraps around to 1 when\n   * reaching MAX_UID_VALUE, ensuring continuous unique identifier generation\n   * within the defined bounds.\n   *\n   * @method next\n   * @returns {number} The next unique identifier in sequence\n   * @throws {Error} If the maximum UID value is exceeded\n   */\n  next(): number {\n    this.value = this.value === MAX_UID_VALUE ? 1 : this.value + 1;\n    return this.value;\n  }\n\n  /**\n   * Resets the UID generator to a specified initial value.\n   * The value is converted to an unsigned 32-bit integer using a zero-fill\n   * right shift operation to ensure proper numeric representation.\n   *\n   * @method reset\n   * @param {number} [initialValue=0] - The value to reset the generator to\n   * @throws {Error} If the initial value exceeds MAX_UID_VALUE\n   */\n  reset(initialValue: number = 0) {\n    this.value = initialValue >>> 0;\n  }\n}\n", "/**\n * Represents the impulse flag of a network packet, which determines whether the packet\n * is a request or a response in the request-response communication pattern.\n *\n * @typedef {number} PacketImpulse\n * @property {0} RESPONSE - Indicates that the packet is a response to a previous request\n * @property {1} REQUEST - Indicates that the packet is initiating a new request\n *\n * @example\n * // Create a request packet\n * const requestPacket = new Packet();\n * requestPacket.setImpulse(1); // Set as request\n *\n * // Create a response packet\n * const responsePacket = new Packet();\n * responsePacket.setImpulse(0); // Set as response\n */\nexport type PacketImpulse = 0 | 1;\n\n/**\n * Defines the set of packet types used in the Netron network protocol.\n * Each type represents a specific operation or action that can be performed\n * through network communication.\n *\n * @constant {number} TYPE_PING - Used for connection health checks and latency measurement\n * @constant {number} TYPE_GET - Requests retrieval of a property value from a remote peer\n * @constant {number} TYPE_SET - Requests modification of a property value on a remote peer\n * @constant {number} TYPE_CALL - Initiates execution of a remote method or function\n * @constant {number} TYPE_TASK - Triggers execution of a predefined remote task\n * @constant {number} TYPE_STREAM - Indicates streaming data transmission\n * @constant {number} TYPE_STREAM_ERROR - Signals an error condition during stream transmission\n * @constant {number} TYPE_STREAM_CLOSE - Explicit stream closure notification\n *\n * @example\n * // Create a packet for property retrieval\n * const packet = new Packet();\n * packet.setType(TYPE_GET);\n */\nexport const TYPE_PING = 0x00;\nexport const TYPE_GET = 0x01;\nexport const TYPE_SET = 0x02;\nexport const TYPE_CALL = 0x03;\nexport const TYPE_TASK = 0x04;\nexport const TYPE_STREAM = 0x05;\nexport const TYPE_STREAM_ERROR = 0x06;\nexport const TYPE_STREAM_CLOSE = 0x07;\n\n/**\n * Represents the union type of all possible packet types in the Netron protocol.\n * This type is used to ensure type safety when working with packet types throughout\n * the codebase.\n *\n * @typedef {number} PacketType\n * @property {number} TYPE_GET - Property retrieval request\n * @property {number} TYPE_SET - Property modification request\n * @property {number} TYPE_CALL - Remote method invocation\n * @property {number} TYPE_TASK - Remote task execution\n * @property {number} TYPE_STREAM - Data streaming\n * @property {number} TYPE_STREAM_ERROR - Stream error notification\n * @property {number} TYPE_STREAM_CLOSE - Stream close notification\n *\n * @example\n * function handlePacket(packet: Packet) {\n *   const type: PacketType = packet.getType();\n *   switch(type) {\n *     case TYPE_GET:\n *       // Handle property retrieval\n *       break;\n *     case TYPE_SET:\n *       // Handle property modification\n *       break;\n *   }\n * }\n */\nexport type PacketType =\n  | typeof TYPE_GET\n  | typeof TYPE_SET\n  | typeof TYPE_CALL\n  | typeof TYPE_TASK\n  | typeof TYPE_STREAM\n  | typeof TYPE_STREAM_ERROR\n  | typeof TYPE_STREAM_CLOSE;\n\n/**\n * Enumerates the possible types of packets within a data stream.\n * This enum is used to manage the flow and state of streaming data transmission.\n *\n * @enum {number}\n * @property {number} FIRST - Indicates the initial packet of a new stream\n * @property {number} MIDDLE - Represents intermediate packets in an ongoing stream\n * @property {number} LAST - Marks the final packet of a stream\n *\n * @example\n * // Handle stream packets based on their position\n * function processStreamPacket(packet: Packet) {\n *   switch(packet.streamType) {\n *     case StreamType.FIRST:\n *       // Initialize stream processing\n *       break;\n *     case StreamType.MIDDLE:\n *       // Process stream data\n *       break;\n *     case StreamType.LAST:\n *       // Finalize stream processing\n *       break;\n *   }\n * }\n */\nexport enum StreamType {\n  FIRST = 0x01,\n  MIDDLE = 0x02,\n  LAST = 0x03,\n}\n", "import { Uid } from '../uid.js';\nimport { PacketType, TYPE_STREAM, PacketImpulse } from './types.js';\n\n/**\n * Extracts the value of a single bit from a number at a specified position.\n * This is a low-level bit manipulation utility function used throughout the packet implementation.\n *\n * @param {number} target - The source number from which to extract the bit value\n * @param {number} offset - The zero-based position of the bit to extract (0 = least significant bit)\n * @returns {number} The value of the bit at the specified position (0 or 1)\n *\n * @example\n * // Get the 3rd bit (position 2) of the number 5 (binary 101)\n * const bit = getBit(5, 2); // Returns 1\n */\nconst getBit = (target: number, offset: number): number => (target >> offset) & 1;\n\n/**\n * Clears a range of bits in a number, setting them to 0.\n * This operation preserves all other bits in the number while zeroing out the specified range.\n *\n * @param {number} target - The number in which to clear bits\n * @param {number} offset - The starting position of the bits to clear\n * @param {number} count - The number of consecutive bits to clear\n * @returns {number} A new number with the specified bits cleared\n *\n * @example\n * // Clear bits 2-4 (inclusive) of the number 255 (binary 11111111)\n * const result = clearBits(255, 2, 3); // Returns 227 (binary 11100011)\n */\nconst clearBits = (target: number, offset: number, count: number): number => {\n  let result = target;\n  for (let i = offset; i < offset + count; ++i) {\n    result &= ~(1 << i);\n  }\n  return result;\n};\n\n/**\n * Writes a value into a range of bits in a number.\n * This operation combines clearing the target bits and then setting them to the new value.\n *\n * @param {number} target - The number in which to write bits\n * @param {number} val - The value to write into the bits\n * @param {number} offset - The starting position to write the bits\n * @param {number} count - The number of bits to write\n * @returns {number} A new number with the specified bits updated\n *\n * @example\n * // Write the value 3 (binary 11) into bits 2-3 of the number 0\n * const result = writeBits(0, 3, 2, 2); // Returns 12 (binary 1100)\n */\nconst writeBits = (target: number, val: number, offset: number, count: number): number => {\n  let result = target;\n  for (let i = 0; i < count; ++i) {\n    if (val & (1 << i)) {\n      result |= 1 << (offset + i);\n    }\n  }\n  return result;\n};\n\n/**\n * Reads a range of bits from a number and returns them as a new value.\n * This operation extracts consecutive bits and combines them into a single number.\n *\n * @param {number} target - The number from which to read bits\n * @param {number} offset - The starting position to read bits\n * @param {number} count - The number of bits to read\n * @returns {number} The value of the read bits combined into a single number\n *\n * @example\n * // Read bits 2-3 from the number 12 (binary 1100)\n * const value = readBits(12, 2, 2); // Returns 3 (binary 11)\n */\nconst readBits = (target: number, offset: number, count: number): number => {\n  let val = 0;\n  for (let i = 0; i < count; ++i) {\n    if (getBit(target, offset + i)) {\n      val |= 1 << i;\n    }\n  }\n  return val;\n};\n\nconst IMPULSE_OFFSET = 6; // Bit position for the impulse flag\nconst ERROR_OFFSET = 7; // Bit position for the error flag\nconst TYPE_OFFSET = 0; // Starting bit position for the type field\nconst TYPE_SIZE = 4; // Number of bits used for the type field\nconst EOS_OFFSET = 4; // Bit position for the end of stream flag\nconst LIVE_OFFSET = 5; // Bit position for the live stream flag\n\nconst uid = new Uid();\n\n/**\n * Represents a Netron network packet with its control flags and payload data.\n *\n * The packet structure consists of:\n * - flags: Control flags (uint8) containing various packet metadata\n * - id: Packet identifier (uint32) for tracking and correlation\n * - data: The actual payload data of the packet\n * - streamId: Optional unique identifier for stream packets (uint32)\n * - streamIndex: Optional chunk number for stream packets (uint32)\n *\n * The control flags are organized as follows:\n *\n * | Field    | Offset | Bits | Range  | Description                                      |\n * |----------|--------|------|--------|--------------------------------------------------|\n * | type     | 0      | 4    | 0-15   | Packet type (see ACTION_*)                       |\n * | eos      | 4      | 1    | 0-1    | End of stream flag                               |\n * | live     | 5      | 1    | 0-1    | Live stream indicator                            |\n * | impulse  | 6      | 1    | 0-1    | Request/response flag                            |\n * | error    | 7      | 1    | 0-1    | Error indicator                                  |\n *\n * @class Packet\n * @property {number} flags - The control flags of the packet (uint8)\n * @property {any} data - The payload data of the packet\n * @property {number} [streamId] - Unique identifier for stream packets (uint32)\n * @property {number} [streamIndex] - Chunk number for stream packets (uint32)\n */\nexport class Packet {\n  /** Control flags of the packet (uint8) containing various metadata bits */\n  public flags = 0;\n\n  /** The actual payload data of the packet */\n  public data: any;\n\n  /** Unique identifier for stream packets (uint32) */\n  public streamId?: number;\n\n  /** Chunk number for stream packets (uint32) */\n  public streamIndex?: number;\n\n  /**\n   * Creates a new Packet instance with the specified identifier.\n   * The identifier is used for tracking and correlation of packets in the network.\n   *\n   * @param {number} id - The unique identifier for this packet (uint32)\n   * @throws {Error} If the provided ID is not a valid unsigned 32-bit integer\n   */\n  constructor(public id: number) { }\n\n  /**\n   * Sets the packet type in the control flags while preserving all other flags.\n   * The type field occupies 4 bits (0-3) in the flags byte and determines\n   * the primary purpose of the packet in the protocol.\n   *\n   * @param {PacketType} type - The type to set in the packet flags\n   * @throws {Error} If the type value exceeds the 4-bit range (0-15)\n   */\n  setType(type: PacketType) {\n    this.flags = writeBits(clearBits(this.flags, TYPE_OFFSET, TYPE_SIZE), type, TYPE_OFFSET, TYPE_SIZE);\n  }\n\n  /**\n   * Retrieves the packet type from the control flags.\n   * This method extracts the 4-bit type field from the flags byte.\n   *\n   * @returns {PacketType} The type of the packet as specified in the flags\n   */\n  getType(): PacketType {\n    return readBits(this.flags, TYPE_OFFSET, TYPE_SIZE) as PacketType;\n  }\n\n  /**\n   * Sets the impulse flag in the control flags.\n   * The impulse flag (bit 6) indicates whether this is a request (1) or response (0) packet.\n   * This flag is crucial for request-response pattern implementation in the protocol.\n   *\n   * @param {PacketImpulse} val - The value to set for the impulse flag (0 or 1)\n   * @throws {Error} If the value is not 0 or 1\n   */\n  setImpulse(val: PacketImpulse) {\n    this.flags = (this.flags & ~(1 << IMPULSE_OFFSET)) | (val << IMPULSE_OFFSET);\n  }\n\n  /**\n   * Retrieves the impulse flag from the control flags.\n   *\n   * @returns {PacketImpulse} The value of the impulse flag (0 or 1)\n   */\n  getImpulse(): PacketImpulse {\n    return getBit(this.flags, IMPULSE_OFFSET) as PacketImpulse;\n  }\n\n  /**\n   * Sets the error flag in the control flags.\n   * The error flag (bit 7) indicates whether this packet represents an error condition.\n   * When set, the packet's data typically contains error information.\n   *\n   * @param {0 | 1} val - The value to set for the error flag (0 or 1)\n   * @throws {Error} If the value is not 0 or 1\n   */\n  setError(val: 0 | 1) {\n    this.flags = (this.flags & ~(1 << ERROR_OFFSET)) | (val << ERROR_OFFSET);\n  }\n\n  /**\n   * Retrieves the error flag from the control flags.\n   *\n   * @returns {number} The value of the error flag (0 or 1)\n   */\n  getError() {\n    return getBit(this.flags, ERROR_OFFSET);\n  }\n\n  /**\n   * Sets comprehensive stream information in the packet.\n   * This method updates both the stream metadata fields and the corresponding control flags\n   * for stream-specific attributes (end-of-stream and live stream indicators).\n   *\n   * @param {number} streamId - The unique identifier for the stream (uint32)\n   * @param {number} streamIndex - The sequential position of this chunk in the stream (uint32)\n   * @param {boolean} isLast - Indicates if this is the final chunk in the stream\n   * @param {boolean} isLive - Indicates if this is a live streaming packet\n   * @throws {Error} If streamId or streamIndex are not valid unsigned 32-bit integers\n   */\n  setStreamInfo(streamId: number, streamIndex: number, isLast: boolean, isLive: boolean) {\n    this.streamId = streamId;\n    this.streamIndex = streamIndex;\n    this.flags = writeBits(writeBits(this.flags, isLast ? 1 : 0, EOS_OFFSET, 1), isLive ? 1 : 0, LIVE_OFFSET, 1);\n  }\n\n  /**\n   * Determines if this packet is part of a stream.\n   * This check is based on the packet type being set to TYPE_STREAM.\n   *\n   * @returns {boolean} True if the packet is a stream chunk, false otherwise\n   */\n  isStreamChunk(): boolean {\n    return this.getType() === TYPE_STREAM;\n  }\n\n  /**\n   * Checks if this packet represents the final chunk of a stream.\n   * This is determined by the end-of-stream flag (bit 4) in the control flags.\n   *\n   * @returns {boolean} True if the packet is the last chunk of a stream, false otherwise\n   */\n  isLastChunk(): boolean {\n    return getBit(this.flags, EOS_OFFSET) === 1;\n  }\n\n  /**\n   * Determines if this packet is part of a live stream.\n   * This is indicated by the live stream flag (bit 5) in the control flags.\n   *\n   * @returns {boolean} True if the stream is live, false otherwise\n   */\n  isLive(): boolean {\n    return getBit(this.flags, LIVE_OFFSET) === 1;\n  }\n\n  /**\n   * Generates a new unique packet identifier using the UID generator.\n   * This method is used to ensure unique packet identification across the network.\n   *\n   * @returns {number} A new unique packet identifier (uint32)\n   */\n  static nextId(): number {\n    return uid.next();\n  }\n\n  /**\n   * Resets the packet ID generator to its initial state.\n   * This method should be used with caution as it may cause ID collisions\n   * if packets with old IDs are still in transit.\n   */\n  static resetId() {\n    uid.reset();\n  }\n}\n", "import { Buffer } from 'buffer';\nimport { SmartBuffer } from '@omnitron-dev/smartbuffer';\nimport { isBuffer, isPlainObject } from '@omnitron-dev/common';\n\nimport { EncoderInfo, EncodeFunction } from './types.js';\n\n/**\n * Get a human-readable type name for a value.\n * Replaces type-detect library with a lightweight implementation.\n */\nconst getType = (value: any): string => {\n  if (value === null) return 'null';\n  if (value === undefined) return 'undefined';\n\n  const type = typeof value;\n  if (type !== 'object') return type;\n\n  // Use Object.prototype.toString for more specific object types\n  const stringTag = Object.prototype.toString.call(value);\n  const match = stringTag.match(/\\[object (\\w+)\\]/);\n  return match ? match[1].toLowerCase() : 'object';\n};\n\nconst encodeString = (x: any, buf: SmartBuffer) => {\n  const len = Buffer.byteLength(x);\n  if (len < 32) {\n    buf.writeInt8(0xa0 | len);\n    if (len === 0) {\n      return;\n    }\n  } else if (len <= 0xff) {\n    buf.writeUInt16BE(0xd900 | len);\n  } else if (len <= 0xffff) {\n    buf.writeInt8(0xda);\n    buf.writeUInt16BE(len);\n  } else {\n    buf.writeInt8(0xdb);\n    buf.writeUInt32BE(len);\n  }\n  buf.write(x, undefined, len);\n};\n\nconst encodeCustom = (x: any, type: number, encFunc: EncodeFunction, buf: SmartBuffer) => {\n  const encoded = encFunc(x, buf);\n\n  const length = encoded.length;\n  if (length === 1) {\n    buf.writeUInt8(0xd4);\n  } else if (length === 2) {\n    buf.writeUInt8(0xd5);\n  } else if (length === 4) {\n    buf.writeUInt8(0xd6);\n  } else if (length === 8) {\n    buf.writeUInt8(0xd7);\n  } else if (length === 16) {\n    buf.writeUInt8(0xd8);\n  } else if (length < 256) {\n    buf.writeUInt16BE(0xc700 | length);\n  } else if (length < 0x10000) {\n    buf.writeUInt32BE(0xc8000000 | (length << 8));\n    buf.woffset -= 1;\n  } else {\n    buf.writeUInt8(0xc9);\n    buf.writeUInt32BE(length);\n  }\n  buf.writeInt8(type);\n  buf.write(encoded);\n};\n\nexport default class Encoder {\n  constructor(private encodingTypes: Map<number, EncoderInfo>) { }\n\n  encode(x: any, buf?: SmartBuffer) {\n    buf = buf || new SmartBuffer(1024, true);\n    this._encode(x, buf);\n    return buf;\n  }\n\n  private _encode(x: any, buf: SmartBuffer): void {\n    const type = typeof x;\n    switch (type) {\n      case 'undefined': {\n        buf.writeUInt32BE(0xd4000000); // fixext special type/value\n        buf.woffset--;\n        break;\n      }\n      case 'boolean': {\n        if (x === true) {\n          buf.writeInt8(0xc3);\n        } else {\n          buf.writeInt8(0xc2);\n        }\n        break;\n      }\n      case 'string': {\n        encodeString(x, buf);\n        break;\n      }\n      case 'bigint': {\n        encodeCustom(x, 120, this.encodingTypes.get(120)!.encode, buf);\n        break;\n      }\n      case 'number': {\n        if (x !== (x | 0)) {\n          // as double\n          buf.writeInt8(0xcb);\n          buf.writeDoubleBE(x);\n        } else if (x >= 0) {\n          if (x < 128) {\n            buf.writeInt8(x);\n          } else if (x < 256) {\n            buf.writeInt16BE(0xcc00 | x);\n          } else if (x < 65536) {\n            buf.writeInt8(0xcd);\n            buf.writeUInt16BE(x);\n          } else if (x <= 0xffffffff) {\n            buf.writeInt8(0xce);\n            buf.writeUInt32BE(x);\n          } else if (x <= 9007199254740991) {\n            buf.writeInt8(0xcf);\n            buf.writeUInt64BE(x);\n          } else {\n            // as double\n            buf.writeInt8(0xcb);\n            buf.writeDoubleBE(x);\n          }\n        } else {\n          if (x >= -32) {\n            buf.writeInt8(0x100 + x);\n          } else if (x >= -128) {\n            buf.writeInt8(0xd0);\n            buf.writeInt8(x);\n          } else if (x >= -32768) {\n            buf.writeInt8(0xd1);\n            buf.writeInt16BE(x);\n          } else if (x > -214748365) {\n            buf.writeInt8(0xd2);\n            buf.writeInt32BE(x);\n          } else if (x >= -9007199254740991) {\n            buf.writeInt8(0xd3);\n            buf.writeInt64BE(x);\n          } else {\n            // as double\n            buf.writeInt8(0xcb);\n            buf.writeDoubleBE(x);\n          }\n        }\n        break;\n      }\n      default: {\n        if (x === null) {\n          buf.writeInt8(0xc0);\n        } else if (isBuffer(x)) {\n          if (x.length <= 0xff) {\n            buf.writeInt16BE(0xc400 | x.length);\n          } else if (x.length <= 0xffff) {\n            buf.writeInt8(0xc5);\n            buf.writeUInt16BE(x.length);\n          } else {\n            buf.writeUInt8(0xc6);\n            buf.writeUInt32BE(x.length);\n          }\n          buf.write(x);\n        } else if (Array.isArray(x)) {\n          if (x.length < 16) {\n            buf.writeInt8(0x90 | x.length);\n          } else if (x.length < 65536) {\n            buf.writeInt8(0xdc);\n            buf.writeUInt16BE(x.length);\n          } else {\n            buf.writeInt8(0xdd);\n            buf.writeUInt32BE(x.length);\n          }\n          for (const obj of x) {\n            this._encode(obj, buf);\n          }\n        } else if (isPlainObject(x)) {\n          const keys = Object.keys(x);\n\n          if (keys.length < 16) {\n            buf.writeInt8(0x80 | keys.length);\n          } else {\n            buf.writeInt8(0xde);\n            buf.writeUInt16BE(keys.length);\n          }\n\n          for (const key of keys) {\n            encodeString(key, buf);\n            this._encode(x[key], buf);\n          }\n        } else {\n          // try extensions\n          const encTypes = this.encodingTypes;\n          for (const [type_, info] of encTypes.entries()) {\n            if (info.check(x)) {\n              encodeCustom(x, type_, info.encode, buf);\n              return;\n            }\n          }\n          throw new Error(`Not supported: ${getType(x)}`);\n        }\n      }\n    }\n  }\n}\n", "import { SmartBuffer, isSmartBuffer } from '@omnitron-dev/smartbuffer';\n\nimport { BufferType, DecodeFunction } from './types.js';\n\nconst getSize = (first: number) => {\n  switch (first) {\n    case 0xc4:\n      return 2;\n    case 0xc5:\n      return 3;\n    case 0xc6:\n      return 5;\n    case 0xc7:\n      return 3;\n    case 0xc8:\n      return 4;\n    case 0xc9:\n      return 6;\n    case 0xca:\n      return 5;\n    case 0xcb:\n      return 9;\n    case 0xcc:\n      return 2;\n    case 0xcd:\n      return 3;\n    case 0xce:\n      return 5;\n    case 0xcf:\n      return 9;\n    case 0xd0:\n      return 2;\n    case 0xd1:\n      return 3;\n    case 0xd2:\n      return 5;\n    case 0xd3:\n      return 9;\n    case 0xd4:\n      return 3;\n    case 0xd5:\n      return 4;\n    case 0xd6:\n      return 6;\n    case 0xd7:\n      return 10;\n    case 0xd8:\n      return 18;\n    case 0xd9:\n      return 2;\n    case 0xda:\n      return 3;\n    case 0xdb:\n      return 5;\n    case 0xde:\n      return 3;\n    default:\n      return -1;\n  }\n};\n\nconst buildDecodeResult = (value: any, bytesConsumed: number) => ({\n  value,\n  bytesConsumed,\n});\n\nconst isValidDataSize = (dataLength: number, bufLength: number, headerLength: number) =>\n  bufLength >= headerLength + dataLength;\n\nexport default class Decoder {\n  constructor(private decodingTypes: Map<number, DecodeFunction>) { }\n\n  decode(buf: BufferType) {\n    const smartBuf: SmartBuffer = isSmartBuffer(buf) ? (buf as SmartBuffer) : SmartBuffer.wrap(buf, undefined, true);\n\n    const result = this.tryDecode(smartBuf);\n    if (result) {\n      return result.value;\n    }\n    throw new Error('Incomplete buffer');\n  }\n\n  tryDecode(buf: SmartBuffer): any {\n    const bufLength = buf.length;\n    if (bufLength <= 0) {\n      return null;\n    }\n\n    const first = buf.readUInt8()!;\n    let length;\n    let result: any = 0;\n    let type;\n    const size = getSize(first);\n\n    if (size !== -1 && bufLength < size) {\n      return null;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (first) {\n      case 0xc0:\n        return buildDecodeResult(null, 1);\n      case 0xc2:\n        return buildDecodeResult(false, 1);\n      case 0xc3:\n        return buildDecodeResult(true, 1);\n      case 0xcc:\n        // 1-byte unsigned int\n        result = buf.readUInt8();\n        return buildDecodeResult(result, 2);\n      case 0xcd:\n        // 2-bytes BE unsigned int\n        result = buf.readUInt16BE();\n        return buildDecodeResult(result, 3);\n      case 0xce:\n        // 4-bytes BE unsigned int\n        result = buf.readUInt32BE();\n        return buildDecodeResult(result, 5);\n      case 0xcf:\n        // 8-bytes BE unsigned int\n        result = buf.readUInt64BE().toNumber();\n        return buildDecodeResult(result, 9);\n      case 0xd0:\n        // 1-byte signed int\n        result = buf.readInt8();\n        return buildDecodeResult(result, 2);\n      case 0xd1:\n        // 2-bytes signed int\n        result = buf.readInt16BE();\n        return buildDecodeResult(result, 3);\n      case 0xd2:\n        // 4-bytes signed int\n        result = buf.readInt32BE();\n        return buildDecodeResult(result, 5);\n      case 0xd3:\n        result = buf.readInt64BE().toNumber();\n        return buildDecodeResult(result, 9);\n      case 0xca:\n        // 4-bytes float\n        result = buf.readFloatBE();\n        return buildDecodeResult(result, 5);\n      case 0xcb:\n        // 8-bytes double\n        result = buf.readDoubleBE();\n        return buildDecodeResult(result, 9);\n      case 0xd9:\n        // strings up to 2^8 - 1 bytes\n        length = buf.readUInt8();\n        if (!length || !isValidDataSize(length, bufLength, 2)) {\n          return null;\n        }\n        result = buf.toString('utf8', buf.roffset, buf.roffset + length);\n        buf.skipRead(length);\n        return buildDecodeResult(result, 2 + length);\n      case 0xda:\n        // strings up to 2^16 - 1 bytes\n        length = buf.readUInt16BE();\n        if (!isValidDataSize(length, bufLength, 3)) {\n          return null;\n        }\n        result = buf.toString('utf8', buf.roffset, buf.roffset + length);\n        buf.skipRead(length);\n        return buildDecodeResult(result, 3 + length);\n      case 0xdb:\n        // strings up to 2^32 - 1 bytes\n        length = buf.readUInt32BE();\n        if (!isValidDataSize(length, bufLength, 5)) {\n          return null;\n        }\n        result = buf.toString('utf8', buf.roffset, buf.roffset + length);\n        buf.skipRead(length);\n        return buildDecodeResult(result, 5 + length);\n      case 0xc4:\n        // buffers up to 2^8 - 1 bytes\n        length = buf.readUInt8();\n        if (length === undefined || !isValidDataSize(length, bufLength, 2)) {\n          return null;\n        }\n        result = buf.slice(buf.roffset, buf.roffset + length).buffer;\n        buf.skipRead(length);\n        return buildDecodeResult(result, 2 + length);\n      case 0xc5:\n        // buffers up to 2^16 - 1 bytes\n        length = buf.readUInt16BE();\n        if (!isValidDataSize(length, bufLength, 3)) {\n          return null;\n        }\n        result = buf.slice(buf.roffset, buf.roffset + length).buffer;\n        buf.skipRead(length);\n        return buildDecodeResult(result, 3 + length);\n      case 0xc6:\n        // buffers up to 2^32 - 1 bytes\n        length = buf.readUInt32BE();\n        if (!isValidDataSize(length, bufLength, 5)) {\n          return null;\n        }\n        result = buf.slice(buf.roffset, buf.roffset + length).buffer;\n        buf.skipRead(length);\n        return buildDecodeResult(result, 5 + length);\n      case 0xdc:\n        // array up to 2^16 - 1 elements\n        if (bufLength < 3) {\n          return null;\n        }\n\n        length = buf.readUInt16BE();\n        return this.decodeArray(buf, length, 3);\n      case 0xdd:\n        // array up to 2^32 - 1 elements\n        if (bufLength < 5) {\n          return null;\n        }\n\n        length = buf.readUInt32BE();\n        return this.decodeArray(buf, length, 5);\n      case 0xde:\n        // maps up to 2^16 - 1 elements\n        length = buf.readUInt16BE();\n        return this.decodeMap(buf, length, 3);\n      case 0xdf:\n        throw new Error('map too big to decode in JS');\n      case 0xd4:\n        return this.decodeFixExt(buf, 1);\n      case 0xd5:\n        return this.decodeFixExt(buf, 2);\n      case 0xd6:\n        return this.decodeFixExt(buf, 4);\n      case 0xd7:\n        return this.decodeFixExt(buf, 8);\n      case 0xd8:\n        return this.decodeFixExt(buf, 16);\n      case 0xc7:\n        // ext up to 2^8 - 1 bytes\n        length = buf.readUInt8();\n        type = buf.readUInt8();\n        if (!type || !length || !isValidDataSize(length, bufLength, 3)) {\n          return null;\n        }\n        return this.decodeExt(buf, type, length, 3);\n      case 0xc8:\n        // ext up to 2^16 - 1 bytes\n        length = buf.readUInt16BE();\n        type = buf.readUInt8();\n        if (!type || !length || !isValidDataSize(length, bufLength, 4)) {\n          return null;\n        }\n        return this.decodeExt(buf, type, length, 4);\n      case 0xc9:\n        // ext up to 2^32 - 1 bytes\n        length = buf.readUInt32BE();\n        type = buf.readUInt8();\n        if (!type || !length || !isValidDataSize(length, bufLength, 6)) {\n          return null;\n        }\n        return this.decodeExt(buf, type, length, 6);\n    }\n\n    if ((first & 0xf0) === 0x90) {\n      // we have an array with less than 15 elements\n      length = first & 0x0f;\n      return this.decodeArray(buf, length, 1);\n    } else if ((first & 0xf0) === 0x80) {\n      // we have a map with less than 15 elements\n      length = first & 0x0f;\n      return this.decodeMap(buf, length, 1);\n    } else if ((first & 0xe0) === 0xa0) {\n      // fixstr up to 31 bytes\n      length = first & 0x1f;\n      if (isValidDataSize(length, bufLength, 1)) {\n        result = buf.toString('utf8', buf.roffset, buf.roffset + length);\n        buf.skipRead(length);\n        return buildDecodeResult(result, length + 1);\n      }\n      return null;\n    } else if (first >= 0xe0) {\n      // 5 bits negative ints\n      result = first - 0x100;\n      return buildDecodeResult(result, 1);\n    } else if (first < 0x80) {\n      // 7-bits positive ints\n      return buildDecodeResult(first, 1);\n    }\n    throw new Error('Not implemented yet');\n  }\n\n  private decodeMap(buf: SmartBuffer, length: number, headerLength: number) {\n    const result: any = {};\n    let key;\n    let totalBytesConsumed = 0;\n\n    for (let i = 0; i < length; ++i) {\n      const keyResult = this.tryDecode(buf);\n      if (keyResult) {\n        const valueResult = this.tryDecode(buf);\n        if (valueResult) {\n          key = keyResult.value;\n          result[key] = valueResult.value;\n          totalBytesConsumed += keyResult.bytesConsumed + valueResult.bytesConsumed;\n        } else {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    }\n    return buildDecodeResult(result, headerLength + totalBytesConsumed);\n  }\n\n  private decodeArray(buf: SmartBuffer, length: number, headerLength: number) {\n    const result: any[] = [];\n    let totalBytesConsumed = 0;\n\n    for (let i = 0; i < length; ++i) {\n      const decodeResult: any = this.tryDecode(buf);\n      if (decodeResult) {\n        result.push(decodeResult.value);\n        totalBytesConsumed += decodeResult.bytesConsumed;\n      } else {\n        return null;\n      }\n    }\n    return buildDecodeResult(result, headerLength + totalBytesConsumed);\n  }\n\n  private decodeFixExt(buf: SmartBuffer, size: number) {\n    const type = buf.readUInt8()!;\n    return this.decodeExt(buf, type, size, 2);\n  }\n\n  private decodeExt(buf: SmartBuffer, type: number, size: number, headerSize: number) {\n    const decTypes = this.decodingTypes;\n    const decode = decTypes.get(type);\n    if (decode) {\n      const value = decode(buf.slice(buf.roffset, buf.roffset + size));\n      buf.skipRead(size);\n      return buildDecodeResult(value, headerSize + size);\n    }\n    if (type === 0) {\n      const val = buf.readUInt8();\n      if (val === 0) {\n        return buildDecodeResult(undefined, headerSize + size);\n      }\n    }\n    throw new Error(`Unable to find ext type ${type}`);\n  }\n}\n", "// Start of Selection\nimport { SmartBuffer } from '@omnitron-dev/smartbuffer';\n\nimport Encoder from './encoder.js';\nimport Decoder from './decoder.js';\nimport { BufferType, EncoderInfo, DecodeFunction, EncodeFunction } from './types.js';\n\nexport default class Serializer {\n  private encodingTypes: Map<number, EncoderInfo> = new Map();\n  private decodingTypes: Map<number, DecodeFunction> = new Map();\n\n  public encoder = new Encoder(this.encodingTypes);\n  public decoder = new Decoder(this.decodingTypes);\n\n  constructor(private initialCapacity = 64) { }\n\n  registerEncoder(type: number, check: any, encode: EncodeFunction): Serializer {\n    this.encodingTypes.set(type, { check, encode });\n    return this;\n  }\n\n  registerDecoder(type: number, decode: DecodeFunction): Serializer {\n    this.decodingTypes.set(type, decode);\n    return this;\n  }\n\n  register(type: number, constructor: any, encode: EncodeFunction, decode: DecodeFunction): Serializer {\n    if (type < 0 || type > 127) {\n      throw new RangeError(`Bad type: 0 <= ${type} <= 127`);\n    }\n    this.registerEncoder(\n      type,\n      (obj: any) => obj instanceof constructor,\n      (obj: any) => {\n        const extBuf = new SmartBuffer(this.initialCapacity, true);\n        encode(obj, extBuf);\n        return extBuf;\n      }\n    );\n    this.registerDecoder(type, decode);\n\n    return this;\n  }\n\n  encode(x: any, buf?: SmartBuffer) {\n    return this.encoder.encode(x, buf);\n  }\n\n  decode(buf: BufferType) {\n    return this.decoder.decode(buf);\n  }\n}\n", "export const errorIdMap: Record<any, number> = {};\nexport const stdIdMap: Record<string, number> = {};\nexport const stdErrors: any[] = [];\n\nexport const idErrorMap: Record<number, any> = {\n  1: Error,\n  2: SyntaxError,\n  3: TypeError,\n  4: ReferenceError,\n  5: RangeError,\n  6: EvalError,\n  7: URIError,\n};\n\nconst keys: number[] = Object.keys(idErrorMap).map((v) => +v);\nfor (let i = 0; i < keys.length; i++) {\n  const errCode = keys[i]!;\n  const ExceptionClass = idErrorMap[errCode];\n  errorIdMap[ExceptionClass] = errCode;\n  stdErrors.push(ExceptionClass);\n  stdIdMap[ExceptionClass.name] = errCode;\n}\n\nexport const createError = (id: number, message: string, stack?: string) => {\n  const err = new idErrorMap[id](message);\n  err.stack = stack;\n  return err;\n};\n\nexport const getStdErrorId = (err: any): number => stdIdMap[err.constructor.name] ?? stdIdMap[Error.name]!;\n", "import Long from 'long';\nimport { SmartBuffer } from '@omnitron-dev/smartbuffer';\n\nimport { BufferType } from './types.js';\nimport Serializer from './serializer.js';\nimport { createError, getStdErrorId } from './errors.js';\n\nexport const registerCommonTypesFor = (s: Serializer) => {\n  // Custom types mapping:\n  // 126 - std errors\n  // 125 - Date\n  // 124 - Map\n  // 123 - Set\n  // 122 - reserved\n  // 121 - RegExp\n  // 120 - BigInt\n  // 119 - Long\n  // 110-118 - reserved for other ateos types\n  // 100-109 - reserved for netron types\n  // 1-99 - user-defined types\n\n  // Std errors encoders/decoders\n  s.register(\n    126,\n    Error,\n    (obj: any, buf: SmartBuffer) => {\n      buf.writeUInt16BE(getStdErrorId(obj));\n      s.encode(obj.name, buf);\n      s.encode(obj.stack, buf);\n      s.encode(obj.message, buf);\n      // Encode custom fields\n      const customFields = Object.keys(obj).filter(\n        (key) => !['stack', 'message', 'name'].includes(key) && obj[key] !== undefined\n      );\n      buf.writeUInt16BE(customFields.length);\n      for (const key of customFields) {\n        s.encode(key, buf);\n        s.encode(obj[key], buf);\n      }\n    },\n    (buf: SmartBuffer) => {\n      const id = buf.readUInt16BE();\n      const name = s.decode(buf);\n      const stack = s.decode(buf);\n      const message = s.decode(buf);\n      const error = createError(id, message, stack);\n      error.name = name;\n      // Decode custom fields\n      const customFieldsCount = buf.readUInt16BE();\n      for (let i = 0; i < customFieldsCount; i++) {\n        const key = s.decode(buf);\n        const value = s.decode(buf);\n        error[key] = value;\n      }\n      return error;\n    }\n  );\n\n  // Date\n  s.register(\n    125,\n    Date,\n    (obj: any, buf: SmartBuffer) => {\n      buf.writeUInt64BE(obj.getTime());\n    },\n    (buf: SmartBuffer) => new Date(buf.readUInt64BE().toNumber())\n  );\n\n  // Map\n  s.register(\n    124,\n    Map,\n    (obj: Map<any, any>, buf: SmartBuffer) => {\n      buf.writeUInt32BE(obj.size);\n      for (const [key, val] of obj.entries()) {\n        s.encode(key, buf);\n        s.encode(val, buf);\n      }\n    },\n    (buf: SmartBuffer) => {\n      const map = new Map();\n      const size = buf.readUInt32BE();\n      for (let i = 0; i < size; i++) {\n        const key = s.decode(buf);\n        const val = s.decode(buf);\n        map.set(key, val);\n      }\n      return map;\n    }\n  );\n\n  // Set\n  s.register(\n    123,\n    Set,\n    (obj: Set<any>, buf: SmartBuffer) => {\n      buf.writeUInt32BE(obj.size);\n      for (const val of obj.values()) {\n        s.encode(val, buf);\n      }\n    },\n    (buf: SmartBuffer) => {\n      const set = new Set();\n      const size = buf.readUInt32BE();\n      for (let i = 0; i < size; i++) {\n        const val = s.decode(buf);\n        set.add(val);\n      }\n      return set;\n    }\n  );\n\n  // RegExp\n  s.register(\n    121,\n    RegExp,\n    (obj: RegExp, buf: SmartBuffer) => {\n      s.encode(obj.source, buf);\n      s.encode(obj.flags, buf);\n    },\n    (buf: SmartBuffer) => {\n      const source = s.decode(buf);\n      const flags = s.decode(buf);\n      return new RegExp(source, flags);\n    }\n  );\n\n  // BigInt encoder/decoder\n  s.register(\n    120,\n    BigInt,\n    (obj: bigint, buf: SmartBuffer) => {\n      const str = obj.toString();\n      s.encode(str, buf);\n    },\n    (buf: SmartBuffer) => {\n      const str = s.decode(buf);\n      return BigInt(str);\n    }\n  );\n\n  // Long encoder/decoder\n  s.register(\n    119,\n    Long,\n    (obj: Long, buf: SmartBuffer) => {\n      buf.writeInt8(obj.unsigned ? 1 : 0);\n      if (obj.unsigned) {\n        buf.writeUInt64BE(obj);\n      } else {\n        buf.writeInt64BE(obj);\n      }\n    },\n    (buf: SmartBuffer) => {\n      const unsigned = Boolean(buf.readInt8());\n      return unsigned ? buf.readUInt64BE() : buf.readInt64BE();\n    }\n  );\n};\n\nexport { Serializer };\nexport const serializer = new Serializer();\nregisterCommonTypesFor(serializer);\n\nexport const encode = (obj: any) => serializer.encode(obj).toBuffer();\nexport const decode = (buf: BufferType) => serializer.decode(buf);\nexport const tryDecode = (buf: SmartBuffer) => serializer.decoder.tryDecode(buf);\n", "/**\n * Represents a reference to a service definition within the Netron distributed system.\n * This class serves as a lightweight proxy that maintains a connection to a service\n * definition by its unique identifier. It is used extensively in the service discovery\n * and dependency injection mechanisms of the Netron framework.\n *\n * @class Reference\n * @description A service definition reference that enables dynamic service resolution\n * and late binding in the Netron service architecture.\n *\n * @example\n * // Creating a reference to a service definition\n * const serviceRef = new Reference('user-service-v1');\n *\n * @see ServiceStub\n * @see Definition\n */\nexport class Reference {\n  /**\n   * Creates a new instance of Reference.\n   * The constructor initializes a reference to a service definition using its unique identifier.\n   * This identifier is used by the Netron framework to locate and resolve the actual service\n   * definition when needed.\n   *\n   * @param {string} defId - The unique identifier of the service definition.\n   * This identifier must match the ID of an existing service definition in the Netron network.\n   *\n   * @throws {Error} If the provided defId is not a valid string or is empty.\n   *\n   * @example\n   * // Creating a reference to a specific service\n   * const authServiceRef = new Reference('authentication-service');\n   */\n  constructor(public defId: string) {\n    if (!defId || typeof defId !== 'string') {\n      throw new Error('Service definition ID must be a non-empty string');\n    }\n  }\n}\n", "import { ServiceMetadata } from './types.js';\n\n// Browser-compatible UUID generation\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID\n  ? () => crypto.randomUUID()\n  : () => {\n      // Fallback for older browsers\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n      });\n    };\n\n/**\n * The Definition class represents a service definition within the Netron framework.\n * It encapsulates all necessary information about a service, including its unique identifier,\n * associated peer, and comprehensive metadata. This class serves as a fundamental building block\n * for service discovery, registration, and communication within the Netron ecosystem.\n *\n * @class Definition\n * @property {string} parentId - Optional identifier of a parent service definition, used for\n *                              establishing hierarchical relationships between services.\n *                              Defaults to an empty string when no parent is specified.\n * @property {string} id - The unique identifier of this service definition, generated using\n *                        cryptographically secure random UUID generation.\n * @property {string} peerId - The identifier of the peer that owns or provides this service.\n * @property {ServiceMetadata} meta - Detailed metadata describing the service's capabilities,\n *                                   including its name, version, available methods, and properties.\n */\nexport class Definition {\n  /**\n   * The identifier of the parent service definition, if this service is part of a hierarchy.\n   * This property enables the creation of service trees and facilitates service composition.\n   *\n   * @type {string}\n   * @default ''\n   */\n  public parentId: string = '';\n\n  /**\n   * Constructs a new Definition instance with the specified parameters.\n   *\n   * @param {string} id - A unique identifier for the service definition. This should be\n   *                      generated using the static nextId() method to ensure uniqueness.\n   * @param {string} peerId - The identifier of the peer that owns or provides this service.\n   *                          This links the service to its provider in the network.\n   * @param {ServiceMetadata} meta - The service metadata object containing detailed\n   *                                information about the service's capabilities and interface.\n   * @throws {Error} If the provided id is not a valid UUID or if the metadata is incomplete.\n   */\n  constructor(\n    public id: string,\n    public peerId: string,\n    public meta: ServiceMetadata\n  ) { }\n\n  /**\n   * Generates a new cryptographically secure unique identifier using the Node.js crypto module.\n   * This method uses the randomUUID() function to create a version 4 UUID that is suitable\n   * for use as a service definition identifier.\n   *\n   * @static\n   * @returns {string} A new UUID v4 string that can be used as a unique identifier.\n   * @example\n   * const newId = Definition.nextId();\n   * // Returns something like: '123e4567-e89b-12d3-a456-426614174000'\n   */\n  static nextId(): string {\n    return randomUUID();\n  }\n}\n", "// Browser stub for Node.js stream module\nexport class Readable {\n  constructor() {}\n}\nexport class Writable {\n  constructor() {}\n}\nexport default { Readable, Writable };\n", "import { Readable, ReadableOptions } from 'stream';\n\nimport { Packet } from './packet/index.js';\nimport { RemotePeer } from './remote-peer.js';\n\n/**\n * Maximum number of packets that can be buffered in the stream before\n * triggering a buffer overflow error. This limit helps prevent memory\n * exhaustion in high-throughput scenarios.\n */\nconst MAX_BUFFER_SIZE = 10_000;\n\n/**\n * Configuration options for creating a new NetronReadableStream instance.\n * Extends the standard Node.js Readable stream options with Netron-specific\n * parameters required for peer-to-peer communication.\n *\n * @interface NetronReadableStreamOptions\n * @extends ReadableOptions\n * @property {RemotePeer} peer - The remote peer this stream is associated with\n * @property {number} streamId - Unique identifier for this stream\n * @property {boolean} [isLive=false] - Whether this is a live streaming connection\n */\nexport interface NetronReadableStreamOptions extends ReadableOptions {\n  peer: RemotePeer;\n  streamId: number;\n  isLive?: boolean;\n}\n\n/**\n * A specialized Readable stream implementation for the Netron distributed system.\n * This class handles the reception and ordered delivery of data packets from\n * remote peers, implementing sophisticated buffering and flow control mechanisms.\n *\n * @class NetronReadableStream\n * @extends Readable\n * @description Implements a reliable, ordered data stream for peer-to-peer communication\n */\nexport class NetronReadableStream extends Readable {\n  /** The remote peer this stream is associated with */\n  public readonly peer: RemotePeer;\n\n  /** Internal buffer for storing out-of-order packets */\n  private buffer: Map<number, any> = new Map();\n\n  /** Next expected packet index for ordered delivery */\n  private expectedIndex: number = 0;\n\n  /** Timeout handle for stream inactivity detection */\n  private timeout?: NodeJS.Timeout;\n\n  /** Unique identifier for this stream */\n  public readonly id: number;\n\n  /** Whether the stream has been closed */\n  private isClosed: boolean = false;\n\n  /** Whether all data has been successfully received */\n  public isComplete: boolean = false;\n\n  /** Whether this is a live streaming connection */\n  public isLive: boolean;\n\n  /**\n   * Creates a new NetronReadableStream instance.\n   *\n   * @param {NetronReadableStreamOptions} options - Configuration options for the stream\n   * @throws {Error} If stream initialization fails\n   */\n  constructor({ peer, streamId, isLive = false, ...opts }: NetronReadableStreamOptions) {\n    super({ ...opts, objectMode: true });\n\n    this.peer = peer;\n    this.id = streamId;\n    this.isLive = isLive;\n\n    this.peer.logger.info({ streamId: this.id, isLive }, 'Creating readable stream');\n    this.peer.readableStreams.set(this.id, this);\n\n    if (!this.isLive) {\n      this.resetTimeout();\n    }\n\n    this.on('close', this.cleanup);\n    this.on('error', this.handleError);\n  }\n\n  /**\n   * Processes incoming data packets and manages ordered delivery.\n   * This method implements the core packet handling logic, including:\n   * - Buffer overflow protection\n   * - Packet reordering\n   * - Flow control\n   * - Stream completion detection\n   *\n   * @param {Packet} packet - The incoming data packet\n   * @returns {void}\n   * @throws {Error} If buffer overflow occurs or stream is closed\n   */\n  public onPacket(packet: Packet): void {\n    if (this.isClosed) {\n      this.peer.logger.warn({ streamId: this.id }, 'Received packet for closed stream');\n      return;\n    }\n\n    this.resetTimeout();\n\n    if (this.buffer.size > MAX_BUFFER_SIZE) {\n      this.peer.logger.error({ streamId: this.id, size: this.buffer.size }, 'Stream buffer overflow');\n      this.destroy(new Error(`Buffer overflow: more than ${MAX_BUFFER_SIZE} packets buffered`));\n      return;\n    }\n\n    this.peer.logger.debug({ streamId: this.id, index: packet.streamIndex }, 'Processing packet');\n\n    // Don't buffer the last packet's data if it's null\n    if (!packet.isLastChunk() || packet.data !== null) {\n      this.buffer.set(packet.streamIndex!, packet.data);\n    }\n\n    while (this.buffer.has(this.expectedIndex)) {\n      const chunk = this.buffer.get(this.expectedIndex);\n      this.buffer.delete(this.expectedIndex);\n      this.expectedIndex++;\n\n      if (!this.push(chunk)) {\n        this.peer.logger.debug({ streamId: this.id }, 'Stream backpressure detected');\n        break;\n      }\n    }\n\n    if (packet.isLastChunk()) {\n      this.peer.logger.info({ streamId: this.id }, 'Received last chunk');\n      this.isComplete = true;\n\n      // Push null to signal end of stream (Node.js convention)\n      this.push(null);\n      // Don't close immediately - let the stream finish naturally\n    }\n  }\n\n  /**\n   * Implementation of the Readable stream's _read method.\n   * This method is called when the stream's internal buffer is ready to accept more data.\n   * In our implementation, data is pushed in onPacket, so this method is intentionally empty.\n   *\n   * @returns {void}\n   */\n  override _read(): void {\n    // Data is pushed in onPacket, no action needed here\n  }\n\n  /**\n   * Resets the stream's inactivity timeout.\n   * This method implements automatic stream cleanup for non-live streams\n   * that have been inactive for too long.\n   *\n   * @returns {void}\n   */\n  private resetTimeout(): void {\n    if (this.isLive) return;\n\n    if (this.timeout) clearTimeout(this.timeout);\n\n    // Use stream timeout from Netron options (defaults to 60 seconds)\n    const timeoutDuration = this.peer.netron.options?.streamTimeout ?? 60000;\n    this.peer.logger.debug({ streamId: this.id, timeoutDuration }, 'Resetting stream timeout');\n\n    this.timeout = setTimeout(() => {\n      const message = `Stream ${this.id} inactive for ${timeoutDuration}ms, closing.`;\n      this.peer.logger.warn(message);\n      this.destroy(new Error(message));\n    }, timeoutDuration);\n  }\n\n  /**\n   * Closes the stream and releases associated resources.\n   * This method implements graceful stream termination with support for\n   * both normal and forced closure scenarios.\n   *\n   * @param {boolean} [force=false] - Whether to force stream closure\n   * @returns {void}\n   */\n  public closeStream(force: boolean = false): void {\n    if (this.isClosed) {\n      this.peer.logger.warn({ streamId: this.id }, 'Attempt to close already closed stream');\n      return;\n    }\n\n    if (this.isLive && !force) {\n      this.peer.logger.warn({ streamId: this.id }, 'Attempt to close live stream');\n      return;\n    }\n\n    this.peer.logger.info({ streamId: this.id, force }, 'Closing stream');\n    this.push(null);\n\n    if (this.isLive && force) {\n      this.destroy();\n    }\n  }\n\n  /**\n   * Forces immediate stream closure due to remote stream termination.\n   * This method is called when receiving an explicit close packet from the remote peer.\n   * It immediately closes the stream and emits appropriate events.\n   *\n   * @param {string} [reason] - Optional reason for the forced closure\n   * @returns {void}\n   */\n  public forceClose(reason?: string): void {\n    if (this.isClosed) {\n      this.peer.logger.warn({ streamId: this.id }, 'Attempt to force close already closed stream');\n      return;\n    }\n\n    this.peer.logger.info({ streamId: this.id, reason }, 'Force closing stream');\n    this.isClosed = true;\n    this.isComplete = true;\n\n    // Push null to signal end of stream\n    this.push(null);\n\n    // Emit close event for listeners\n    process.nextTick(() => {\n      this.emit('close');\n      this.cleanup();\n    });\n  }\n\n  /**\n   * Performs cleanup operations when the stream is closed.\n   * This method ensures proper resource deallocation and stream deregistration.\n   *\n   * @returns {void}\n   */\n  private cleanup = (): void => {\n    this.peer.logger.debug({ streamId: this.id }, 'Cleaning up stream resources');\n    if (this.timeout) clearTimeout(this.timeout);\n    this.peer.readableStreams.delete(this.id);\n    this.buffer.clear();\n  };\n\n  /**\n   * Handles stream error events.\n   * This method implements error logging and cleanup for stream errors.\n   *\n   * @param {Error} error - The error that occurred\n   * @returns {void}\n   */\n  private handleError = (error: Error): void => {\n    this.peer.logger.error({ streamId: this.id, error }, 'Stream error occurred');\n    this.cleanup();\n  };\n\n  /**\n   * Overrides the standard destroy method to ensure proper cleanup.\n   * This method implements a robust stream termination process that\n   * guarantees resource cleanup and error propagation.\n   *\n   * @param {Error} [error] - Optional error to propagate\n   * @returns {this}\n   */\n  public override destroy(error?: Error): this {\n    if (this.isClosed) {\n      this.peer.logger.warn({ streamId: this.id }, 'Attempt to destroy already closed stream');\n      return this;\n    }\n\n    this.peer.logger.info({ streamId: this.id, error }, 'Destroying stream');\n    this.isClosed = true;\n    super.destroy(error);\n    this.cleanup();\n\n    return this;\n  }\n\n  /**\n   * Factory method for creating new NetronReadableStream instances.\n   * This method provides a convenient way to create stream instances\n   * with default configuration.\n   *\n   * @param {RemotePeer} peer - The remote peer for this stream\n   * @param {number} streamId - Unique identifier for the stream\n   * @param {boolean} [isLive=false] - Whether this is a live stream\n   * @returns {NetronReadableStream}\n   */\n  public static create(peer: RemotePeer, streamId: number, isLive: boolean = false): NetronReadableStream {\n    return new NetronReadableStream({ peer, streamId, isLive });\n  }\n}\n", "import { Writable, Readable, WritableOptions } from 'stream';\n\nimport { Uid } from './uid.js';\nimport { RemotePeer } from './remote-peer.js';\nimport { Packet, createPacket, TYPE_STREAM_ERROR, TYPE_STREAM_CLOSE } from './packet/index.js';\n\n/**\n * Global UID generator instance for creating unique stream identifiers.\n * This ensures that each stream gets a unique ID across the application.\n */\nconst uid = new Uid();\n\n/**\n * Configuration options for creating a NetronWritableStream instance.\n * Extends Node.js WritableOptions with Netron-specific properties.\n *\n * @interface NetronWritableStreamOptions\n * @extends {WritableOptions}\n * @property {RemotePeer} peer - The remote peer this stream is associated with\n * @property {number} [streamId] - Optional custom stream identifier\n * @property {boolean} [isLive] - Whether the stream is operating in live/real-time mode\n */\nexport interface NetronWritableStreamOptions extends WritableOptions {\n  peer: RemotePeer;\n  streamId?: number;\n  isLive?: boolean;\n}\n\n/**\n * A specialized writable stream implementation for the Netron distributed system.\n * This class extends Node.js Writable stream to provide distributed stream capabilities\n * with proper error handling, cleanup, and remote peer communication.\n *\n * @class NetronWritableStream\n * @extends {Writable}\n * @property {number} id - Unique identifier for this stream instance\n * @property {RemotePeer} peer - The remote peer this stream is associated with\n * @property {boolean} isLive - Indicates if the stream is operating in live mode\n */\nexport class NetronWritableStream extends Writable {\n  /** Unique identifier for this stream instance */\n  public readonly id: number;\n\n  /** The remote peer this stream is associated with */\n  public readonly peer: RemotePeer;\n\n  /** Current chunk index for maintaining write order */\n  private index: number = 0;\n\n  /** Whether the stream is operating in live/real-time mode */\n  public isLive: boolean;\n\n  /** Flag indicating if the stream has been closed */\n  private isClosed: boolean = false;\n\n  /**\n   * Creates a new NetronWritableStream instance.\n   *\n   * @constructor\n   * @param {NetronWritableStreamOptions} options - Configuration options for the stream\n   * @param {RemotePeer} options.peer - The remote peer this stream is associated with\n   * @param {number} [options.streamId] - Optional custom stream identifier\n   * @param {boolean} [options.isLive=false] - Whether the stream is operating in live mode\n   * @param {WritableOptions} [options] - Additional Node.js stream options\n   */\n  constructor({ peer, streamId, isLive = false, ...opts }: NetronWritableStreamOptions) {\n    super({ ...opts, objectMode: true });\n\n    this.peer = peer;\n    this.isLive = isLive;\n    this.id = streamId ?? uid.next();\n\n    this.peer.logger.info({ streamId: this.id, isLive }, 'Creating writable stream');\n    this.peer.writableStreams.set(this.id, this);\n\n    this.once('close', this.cleanup);\n    // Don't automatically consume error events - let them propagate to consumers\n    // this.once('error', this.handleError);\n  }\n\n  /**\n   * Pipes data from an AsyncIterable or Readable stream into this stream.\n   * Handles backpressure and ensures proper cleanup on errors.\n   *\n   * @param {AsyncIterable<any> | Readable} source - The source stream to pipe from\n   * @returns {Promise<void>} A promise that resolves when piping is complete\n   * @throws {Error} If an error occurs during the piping process\n   */\n  public async pipeFrom(source: AsyncIterable<any> | Readable): Promise<void> {\n    this.peer.logger.debug({ streamId: this.id }, 'Starting pipe operation');\n    try {\n      for await (const chunk of source) {\n        if (!this.write(chunk)) {\n          this.peer.logger.debug({ streamId: this.id }, 'Stream backpressure detected');\n          await new Promise((resolve) => this.once('drain', resolve));\n        }\n      }\n      this.end();\n      this.peer.logger.debug({ streamId: this.id }, 'Pipe operation completed');\n    } catch (error) {\n      this.peer.logger.error({ streamId: this.id, error }, 'Pipe operation failed');\n      this.destroy(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  /**\n   * Internal write implementation for handling stream chunks.\n   * Sends data to the remote peer and manages stream state.\n   *\n   * @override\n   * @param {any} chunk - The data chunk to write\n   * @param {BufferEncoding} _ - Unused encoding parameter\n   * @param {(error?: Error | null) => void} callback - Callback to signal write completion\n   */\n  override _write(chunk: any, _: BufferEncoding, callback: (error?: Error | null) => void): void {\n    if (this.isClosed) {\n      this.peer.logger.warn({ streamId: this.id }, 'Attempt to write to closed stream');\n      callback(new Error('Stream is already closed'));\n      return;\n    }\n\n    this.peer.logger.debug({ streamId: this.id, index: this.index }, 'Writing chunk');\n    this.peer\n      .sendStreamChunk(this.id, chunk, this.index++, false, this.isLive)\n      .then(() => callback())\n      .catch((err: Error) => {\n        this.peer.logger.error({ streamId: this.id, error: err }, 'Error sending stream chunk');\n\n        // Send error packet to remote peer (best effort)\n        this.peer\n          .sendPacket(\n            createPacket(Packet.nextId(), 1, TYPE_STREAM_ERROR, {\n              streamId: this.id,\n              message: err.message,\n            })\n          )\n          .catch(sendErr => {\n            this.peer.logger.error({ streamId: this.id, error: sendErr }, 'Failed to send stream error packet');\n          });\n\n        // Call callback with error to trigger error event on the stream\n        callback(err);\n      });\n  }\n\n  /**\n   * Internal final implementation for handling stream completion.\n   * Sends final chunk to remote peer and performs cleanup.\n   *\n   * @override\n   * @param {(error?: Error | null) => void} callback - Callback to signal finalization completion\n   */\n  override _final(callback: (error?: Error | null) => void): void {\n    if (this.isClosed) {\n      this.peer.logger.warn({ streamId: this.id }, 'Attempt to finalize closed stream');\n      callback(new Error('Stream is already closed'));\n      return;\n    }\n\n    this.peer.logger.debug({ streamId: this.id, index: this.index }, 'Sending final chunk');\n    this.peer\n      .sendStreamChunk(this.id, null, this.index, true, this.isLive)\n      .then(() => callback())\n      .catch((err: Error) => {\n        this.peer.logger.error({ streamId: this.id, error: err }, 'Error sending final chunk');\n        callback(err);\n      })\n      .finally(() => this.closeStream());\n  }\n\n  /**\n   * Gracefully closes the stream and performs cleanup.\n   * This method ensures proper resource cleanup and state management.\n   */\n  public closeStream(): void {\n    if (this.isClosed) {\n      this.peer.logger.warn({ streamId: this.id }, 'Attempt to close already closed stream');\n      return;\n    }\n\n    this.peer.logger.info({ streamId: this.id }, 'Closing stream');\n    this.isClosed = true;\n    this.end();\n    this.cleanup();\n  }\n\n  /**\n   * Overrides the destroy method to ensure proper cleanup and error handling.\n   * Sends a close notification packet to the remote peer for immediate stream termination.\n   *\n   * @override\n   * @param {Error} [error] - Optional error that caused the destruction\n   * @returns {this} The stream instance for chaining\n   */\n  public override destroy(error?: Error): this {\n    if (this.isClosed) {\n      this.peer.logger.warn({ streamId: this.id }, 'Attempt to destroy already closed stream');\n      return this;\n    }\n\n    this.peer.logger.info({ streamId: this.id, error }, 'Destroying stream');\n    this.isClosed = true;\n\n    // Perform cleanup immediately\n    this.cleanup();\n\n    // Immediately call super.destroy to set the destroyed property and emit error if needed\n    super.destroy(error);\n\n    // Send explicit close packet for immediate notification (best effort)\n    const closeReason = error ? error.message : 'Stream destroyed';\n    this.peer\n      .sendPacket(createPacket(Packet.nextId(), 1, TYPE_STREAM_CLOSE, {\n        streamId: this.id,\n        reason: closeReason,\n      }))\n      .catch((sendError) => {\n        this.peer.logger.error({ streamId: this.id, error: sendError }, 'Failed to send stream close packet');\n      });\n\n    return this;\n  }\n\n  /**\n   * Internal cleanup method that removes stream references from the peer.\n   * This ensures proper garbage collection and prevents memory leaks.\n   */\n  private cleanup = () => {\n    this.peer.logger.debug({ streamId: this.id }, 'Cleaning up stream resources');\n    this.peer.writableStreams.delete(this.id);\n  };\n\n\n  /**\n   * Factory method for creating a NetronWritableStream instance.\n   * Optionally pipes data from a source stream if provided.\n   *\n   * @static\n   * @param {RemotePeer} peer - The remote peer this stream is associated with\n   * @param {AsyncIterable<any> | Readable} [source] - Optional source stream to pipe from\n   * @param {boolean} [isLive=false] - Whether the stream is operating in live mode\n   * @param {number} [streamId] - Optional custom stream identifier\n   * @returns {NetronWritableStream} A new stream instance\n   */\n  public static create(\n    peer: RemotePeer,\n    source?: AsyncIterable<any> | Readable,\n    isLive: boolean = false,\n    streamId?: number\n  ): NetronWritableStream {\n    const stream = new NetronWritableStream({ peer, streamId, isLive });\n\n    if (source) {\n      stream.pipeFrom(source);\n    }\n\n    return stream;\n  }\n}\n", "import { RemotePeer } from './remote-peer.js';\nimport { NetronReadableStream } from './readable-stream.js';\nimport { NetronWritableStream } from './writable-stream.js';\n\n/**\n * Represents the type of stream that can be referenced.\n * This type is used to distinguish between readable and writable streams\n * in the Netron distributed system.\n *\n * @typedef {('readable' | 'writable')} StreamReferenceType\n */\nexport type StreamReferenceType = 'readable' | 'writable';\n\n/**\n * StreamReference is a serializable representation of a stream in the Netron system.\n * This class serves as a bridge between local stream instances and their remote\n * representations, enabling stream data to be transmitted across the network.\n *\n * @class StreamReference\n * @property {number} streamId - Unique identifier of the stream\n * @property {StreamReferenceType} type - Type of the stream (readable or writable)\n * @property {boolean} isLive - Indicates if the stream is live/real-time\n * @property {string} peerId - ID of the peer that owns the stream\n */\nexport class StreamReference {\n  /**\n   * Creates a new StreamReference instance.\n   *\n   * @param {number} streamId - Unique identifier of the stream\n   * @param {StreamReferenceType} type - Type of the stream (readable or writable)\n   * @param {boolean} isLive - Indicates if the stream is live/real-time\n   * @param {string} peerId - ID of the peer that owns the stream\n   */\n  constructor(\n    public readonly streamId: number,\n    public readonly type: StreamReferenceType,\n    public readonly isLive: boolean,\n    public readonly peerId: string\n  ) { }\n\n  /**\n   * Creates a StreamReference from an existing stream instance.\n   * This method is used to serialize a local stream for transmission over the network.\n   *\n   * @static\n   * @param {NetronReadableStream | NetronWritableStream} stream - The stream instance to reference\n   * @returns {StreamReference} A new StreamReference representing the given stream\n   */\n  static from(stream: NetronReadableStream | NetronWritableStream): StreamReference {\n    return new StreamReference(\n      stream.id,\n      stream instanceof NetronWritableStream ? 'writable' : 'readable',\n      stream.isLive,\n      stream.peer.id\n    );\n  }\n\n  /**\n   * Creates a stream instance from a StreamReference.\n   * This method is used to deserialize a stream reference into a working stream instance\n   * on the receiving end of a network transmission.\n   *\n   * @static\n   * @param {StreamReference} ref - The stream reference to convert\n   * @param {RemotePeer} peer - The remote peer that owns the stream\n   * @returns {NetronReadableStream | NetronWritableStream} A new stream instance\n   * @throws {Error} If the stream type is invalid or creation fails\n   */\n  static to(ref: StreamReference, peer: RemotePeer): NetronReadableStream | NetronWritableStream {\n    if (ref.type === 'writable') {\n      return NetronReadableStream.create(peer, ref.streamId, ref.isLive);\n    } else {\n      return NetronWritableStream.create(peer, undefined, ref.isLive, ref.streamId);\n    }\n  }\n}\n", "import { SmartBuffer } from '@omnitron-dev/smartbuffer';\nimport { Serializer, registerCommonTypesFor } from '@omnitron-dev/messagepack';\n\nimport { Reference } from '../reference.js';\nimport { Definition } from '../definition.js';\n\n/**\n * Global serializer instance for the Netron application.\n * This serializer is responsible for converting complex objects into binary format\n * and vice versa, enabling efficient network transmission and storage.\n *\n * @type {Serializer}\n * @constant\n */\nexport const serializer = new Serializer();\n\n/**\n * Registers common data types with the serializer.\n * This enables the serializer to handle standard JavaScript types like\n * numbers, strings, arrays, and objects without additional configuration.\n */\nregisterCommonTypesFor(serializer);\n\n/**\n * Registers custom serialization handlers for Netron-specific types.\n * Each type is assigned a unique identifier and provided with custom\n * encoding and decoding functions to handle its specific serialization needs.\n */\nserializer\n  /**\n   * Registers serialization handlers for the Definition class.\n   * Definition objects represent service definitions in the Netron network\n   * and contain metadata about available services.\n   *\n   * @param {number} 109 - Unique type identifier for Definition objects\n   * @param {Definition} - The class constructor for Definition objects\n   * @param {Function} - Encoder function that writes Definition properties to buffer\n   * @param {Function} - Decoder function that reconstructs Definition from buffer\n   */\n  .register(\n    109,\n    Definition,\n    /**\n     * Encodes a Definition object into a binary buffer.\n     * The encoding process preserves the object's identity and relationships\n     * by serializing its id, parentId, peerId, and metadata.\n     *\n     * @param {Definition} obj - The Definition object to encode\n     * @param {SmartBuffer} buf - The buffer to write the encoded data to\n     */\n    (obj: Definition, buf: SmartBuffer) => {\n      serializer.encode(obj.id, buf);\n      serializer.encode(obj.parentId, buf);\n      serializer.encode(obj.peerId, buf);\n      serializer.encode(obj.meta, buf);\n    },\n    /**\n     * Decodes a Definition object from a binary buffer.\n     * Reconstructs the object's state by reading its properties in the same\n     * order they were written during encoding.\n     *\n     * @param {SmartBuffer} buf - The buffer containing the encoded Definition\n     * @returns {Definition} A new Definition instance with restored properties\n     */\n    (buf: SmartBuffer) => {\n      const id = serializer.decode(buf);\n      const parentId = serializer.decode(buf);\n      const peerId = serializer.decode(buf);\n      const meta = serializer.decode(buf);\n      const def = new Definition(id, peerId, meta);\n      def.parentId = parentId;\n      return def;\n    }\n  )\n  /**\n   * Registers serialization handlers for the Reference class.\n   * Reference objects represent service references in the Netron network,\n   * linking to specific service definitions.\n   *\n   * @param {number} 108 - Unique type identifier for Reference objects\n   * @param {Reference} - The class constructor for Reference objects\n   * @param {Function} - Encoder function that writes Reference properties to buffer\n   * @param {Function} - Decoder function that reconstructs Reference from buffer\n   */\n  .register(\n    108,\n    Reference,\n    /**\n     * Encodes a Reference object into a binary buffer.\n     * Only the defId property is serialized as it uniquely identifies\n     * the referenced service definition.\n     *\n     * @param {Reference} obj - The Reference object to encode\n     * @param {SmartBuffer} buf - The buffer to write the encoded data to\n     */\n    (obj: any, buf: SmartBuffer) => {\n      serializer.encode(obj.defId, buf);\n    },\n    /**\n     * Decodes a Reference object from a binary buffer.\n     * Creates a new Reference instance using the decoded defId.\n     *\n     * @param {SmartBuffer} buf - The buffer containing the encoded Reference\n     * @returns {Reference} A new Reference instance with the restored defId\n     */\n    (buf: SmartBuffer) => new Reference(serializer.decode(buf))\n  );\n\n// StreamReference will be registered later to avoid circular dependency\nlet streamReferenceRegistered = false;\nlet StreamReferenceClass: any = null;\n\n/**\n * Registers StreamReference with the serializer.\n * This is done lazily to avoid circular dependency issues during module initialization.\n */\nexport async function ensureStreamReferenceRegistered(): Promise<void> {\n  if (streamReferenceRegistered) {\n    return;\n  }\n\n  try {\n    // Dynamic import to avoid circular dependency\n    const module = await import('../stream-reference.js');\n    StreamReferenceClass = module.StreamReference;\n\n    /**\n     * Registers serialization handlers for the StreamReference class.\n     * StreamReference objects represent stream connections in the Netron network,\n     * containing information about stream type, direction, and associated peer.\n     *\n     * @param {number} 107 - Unique type identifier for StreamReference objects\n     */\n    serializer.register(\n      107,\n      StreamReferenceClass,\n      /**\n       * Encodes a StreamReference object into a binary buffer.\n       * Serializes the stream's identity, type, liveness status, and associated peer.\n       *\n       * @param {StreamReference} obj - The StreamReference object to encode\n       * @param {SmartBuffer} buf - The buffer to write the encoded data to\n       */\n      (obj: any, buf: SmartBuffer) => {\n        serializer.encode(obj.streamId.toString(), buf);\n        buf.writeUInt8(obj.type === 'writable' ? 1 : 0);\n        buf.writeUInt8(obj.isLive ? 1 : 0);\n        serializer.encode(obj.peerId, buf);\n      },\n      /**\n       * Decodes a StreamReference object from a binary buffer.\n       * Reconstructs the stream reference with its type, liveness status,\n       * and associated peer information.\n       *\n       * @param {SmartBuffer} buf - The buffer containing the encoded StreamReference\n       * @returns {StreamReference} A new StreamReference instance with restored properties\n       */\n      (buf: SmartBuffer) => {\n        const streamId = Number(serializer.decode(buf));\n        const streamType = buf.readUInt8() === 1 ? 'writable' : 'readable';\n        const isLive = buf.readUInt8() === 1;\n        const peerId = serializer.decode(buf);\n        return new StreamReferenceClass(streamId, streamType, isLive, peerId);\n      }\n    );\n\n    streamReferenceRegistered = true;\n  } catch (error) {\n    console.error('Failed to register StreamReference:', error);\n    throw error;\n  }\n}\n\n// Create a wrapper for encode/decode that ensures StreamReference is registered\nconst originalEncode = serializer.encode.bind(serializer);\nconst originalDecode = serializer.decode.bind(serializer);\n\nserializer.encode = function(value: any, buffer?: SmartBuffer): any {\n  // Check if value is a StreamReference-like object\n  if (value && value.constructor && value.constructor.name === 'StreamReference' && !streamReferenceRegistered) {\n    // Try to register synchronously using a promise\n    Promise.resolve(ensureStreamReferenceRegistered()).catch(console.error);\n  }\n  return originalEncode(value, buffer);\n};\n\nserializer.decode = function(buffer: SmartBuffer): any {\n  return originalDecode(buffer);\n};", "import { Buffer } from 'buffer';\nimport { SmartBuffer } from '@omnitron-dev/smartbuffer';\n\nimport { Packet } from './packet.js';\nimport { serializer } from './serializer.js';\nimport { PacketType, TYPE_STREAM, PacketImpulse } from './types.js';\n\nexport * from './types.js';\n\n/**\n * Creates a new packet with the specified parameters.\n * This function serves as a factory method for creating Packet instances with predefined properties.\n *\n * @param {number} id - A unique numeric identifier for the packet. Used for tracking and correlation.\n * @param {PacketImpulse} impulse - The impulse type that determines the packet's behavior and processing rules.\n * @param {PacketType} action - The type of packet, defining its role in the communication protocol.\n * @param {any} data - The payload data to be encapsulated within the packet. Can be of any type.\n * @returns {Packet} A newly instantiated Packet object with the specified properties set.\n *\n * @example\n * const packet = createPacket(123, PacketImpulse.REQUEST, PacketType.DATA, { message: 'Hello' });\n */\nexport const createPacket = (id: number, impulse: PacketImpulse, action: PacketType, data: any) => {\n  const packet = new Packet(id);\n  packet.setImpulse(impulse);\n  packet.setType(action);\n  packet.data = data;\n  return packet;\n};\n\n/**\n * Creates a new stream packet with stream-specific parameters.\n * This specialized factory method creates packets designed for streaming data,\n * with additional metadata for stream management and control.\n *\n * @param {number} id - A unique numeric identifier for the packet.\n * @param {number} streamId - The unique identifier of the stream this packet belongs to.\n * @param {number} streamIndex - The sequential position of this packet within the stream.\n * @param {boolean} isLast - Flag indicating if this is the final packet in the stream.\n * @param {boolean} isLive - Flag indicating if this is a live streaming packet.\n * @param {any} data - The actual payload data to be transmitted in the stream.\n * @returns {Packet} A Packet instance configured for streaming with the specified properties.\n *\n * @example\n * const streamPacket = createStreamPacket(123, 456, 0, false, true, { video: 'chunk1' });\n */\nexport const createStreamPacket = (\n  id: number,\n  streamId: number,\n  streamIndex: number,\n  isLast: boolean,\n  isLive: boolean,\n  data: any\n) => {\n  const packet = new Packet(id);\n  packet.setImpulse(1);\n  packet.setType(TYPE_STREAM);\n  packet.setStreamInfo(streamId, streamIndex, isLast, isLive);\n  packet.data = data;\n  return packet;\n};\n\n/**\n * Encodes a Packet instance into a binary buffer for network transmission.\n * This function handles the serialization of packet data into a format suitable\n * for network transmission, including proper byte ordering and stream metadata.\n *\n * @param {Packet} packet - The Packet instance to be encoded.\n * @returns {Buffer} A Buffer containing the binary representation of the packet.\n *\n * @remarks\n * The encoding process follows this structure:\n * 1. Packet ID (4 bytes, big-endian)\n * 2. Flags (1 byte)\n * 3. Serialized data payload\n * 4. Stream metadata (if applicable)\n *\n * @throws {Error} If the packet data cannot be properly serialized.\n */\nexport const encodePacket = (packet: Packet) => {\n  const buf = new SmartBuffer(SmartBuffer.DEFAULT_CAPACITY, true);\n\n  // Write the packet's unique identifier and flags to the buffer.\n  buf.writeUInt32BE(packet.id);\n  buf.writeUInt8(packet.flags);\n\n  // Encode the packet's data using the serializer and write it to the buffer.\n  serializer.encode(packet.data, buf);\n\n  // If the packet is part of a stream, write the stream-specific information.\n  if (packet.isStreamChunk()) {\n    buf.writeUInt32BE(packet.streamId!);\n    buf.writeUInt32BE(packet.streamIndex!);\n  }\n\n  // Convert the SmartBuffer to a standard Buffer and return it.\n  return buf.toBuffer();\n};\n\n/**\n * Decodes a binary buffer into a Packet instance.\n * This function handles the deserialization of network data back into a Packet object,\n * including proper parsing of headers and stream metadata.\n *\n * @param {Buffer | ArrayBuffer} buf - The binary data to decode into a packet.\n * @returns {Packet} A reconstructed Packet instance from the binary data.\n * @throws {Error} If the packet data is invalid or cannot be decoded.\n *\n * @remarks\n * The decoding process follows this structure:\n * 1. Read packet ID (4 bytes, big-endian)\n * 2. Read flags (1 byte)\n * 3. Deserialize data payload\n * 4. Read stream metadata (if applicable)\n *\n * @example\n * const packet = decodePacket(receivedBuffer);\n */\nexport const decodePacket = (buf: Buffer | ArrayBuffer) => {\n  const buffer = SmartBuffer.wrap(buf);\n  const pkt = new Packet(buffer.readUInt32BE());\n  pkt.flags = buffer.readUInt8()!;\n\n  // Attempt to decode the packet's data using the serializer.\n  const result = serializer.decoder.tryDecode(buffer);\n  if (!result) {\n    throw new Error('Invalid packet');\n  }\n  pkt.data = result.value;\n\n  // If the packet is part of a stream, read the stream-specific information.\n  if (pkt.isStreamChunk()) {\n    pkt.streamId = buffer.readUInt32BE();\n    pkt.streamIndex = buffer.readUInt32BE();\n  }\n  return pkt;\n};\n\nexport { Packet, serializer };\n", "/**\n * Netron Client Entry Point\n *\n * Main exports for browser Netron client\n */\n\nexport { BrowserNetronClient } from './browser-netron-client.js';\nexport { BrowserRemotePeer } from './browser-remote-peer.js';\nexport { BrowserWebSocketConnection } from './clients/websocket-client.js';\n\n// Re-export packet types for advanced usage\nexport * from './packet/types.js';\nexport { Packet } from './packet/packet.js';\n\n// Re-export common types\nexport type { EventSubscriber } from './browser-remote-peer.js';\nexport type { BrowserNetronClientOptions } from './browser-netron-client.js';\nexport type { WebSocketClientOptions } from './clients/websocket-client.js';\n", "/**\n * Browser Netron Client - Client-Only Implementation\n *\n * Simplified Netron client for browser that connects to Titan WebSocket server\n * using the correct packet protocol.\n */\n\nimport { EventEmitter } from '@omnitron-dev/eventemitter';\nimport { BrowserWebSocketConnection } from './clients/websocket-client.js';\nimport { BrowserRemotePeer } from './browser-remote-peer.js';\nimport { Definition } from './definition.js';\nimport { getQualifiedName } from './utils.js';\n\n/**\n * Simple logger interface\n */\ninterface SimpleLogger {\n  debug(...args: any[]): void;\n  info(...args: any[]): void;\n  warn(...args: any[]): void;\n  error(...args: any[]): void;\n}\n\n/**\n * Client options\n */\nexport interface BrowserNetronClientOptions {\n  /** Request timeout in milliseconds */\n  timeout?: number;\n  /** Enable reconnection */\n  reconnect?: boolean;\n  /** Reconnection interval */\n  reconnectInterval?: number;\n  /** Maximum reconnection attempts */\n  maxReconnectAttempts?: number;\n  /** Custom logger */\n  logger?: SimpleLogger;\n}\n\n/**\n * Browser Netron Client\n * Connects to Titan server and provides service interface access\n */\nexport class BrowserNetronClient extends EventEmitter {\n  private connection: BrowserWebSocketConnection | null = null;\n  private peer: BrowserRemotePeer | null = null;\n  private options: BrowserNetronClientOptions;\n  private logger: SimpleLogger;\n  public id: string;\n\n  constructor(options: BrowserNetronClientOptions = {}) {\n    super();\n    this.options = options;\n    this.logger = options.logger || console;\n\n    // Generate unique client ID\n    this.id = this.generateId();\n  }\n\n  /**\n   * Connect to Titan WebSocket server\n   */\n  async connect(url: string): Promise<void> {\n    this.logger.info(`Connecting to ${url}`);\n\n    // Create WebSocket connection\n    this.connection = new BrowserWebSocketConnection({\n      url,\n      timeout: this.options.timeout,\n      reconnect: this.options.reconnect,\n      reconnectInterval: this.options.reconnectInterval,\n      maxReconnectAttempts: this.options.maxReconnectAttempts,\n    });\n\n    // Connect to server\n    await this.connection.connect();\n\n    // Wait for handshake\n    await this.performHandshake();\n\n    this.logger.info('Connected successfully');\n  }\n\n  /**\n   * Perform handshake with server\n   */\n  private async performHandshake(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Wait for server ID message\n      const messageHandler = (data: ArrayBuffer, isBinary: boolean) => {\n        try {\n          // Try to decode as JSON text (handshake message)\n          // Server sends handshake as Buffer, which arrives as ArrayBuffer\n          const text = new TextDecoder().decode(data);\n          const message = JSON.parse(text);\n\n          if (message.type === 'id') {\n            // Server sent us their ID\n            const serverId = message.id;\n            this.logger.info(`Received server ID: ${serverId}`);\n\n            // Create peer with server ID\n            this.peer = new BrowserRemotePeer(\n              this.connection!,\n              serverId,\n              this.logger,\n              this.options.timeout\n            );\n\n            // Initialize peer\n            this.peer.init().then(() => {\n              // Send our client ID to server\n              const clientIdMessage = JSON.stringify({\n                type: 'client-id',\n                id: this.id,\n              });\n              this.connection!.send(new TextEncoder().encode(clientIdMessage));\n\n              this.connection!.off('message', messageHandler);\n              resolve();\n            }).catch(reject);\n          }\n        } catch (error) {\n          // Not JSON or not handshake message, ignore\n          this.logger.debug?.('Non-handshake message during handshake:', error);\n        }\n      };\n\n      this.connection!.on('message', messageHandler);\n\n      // Timeout for handshake\n      setTimeout(() => {\n        this.connection!.off('message', messageHandler);\n        reject(new Error('Handshake timeout'));\n      }, this.options.timeout || 10000);\n    });\n  }\n\n  /**\n   * Disconnect from server\n   */\n  async disconnect(): Promise<void> {\n    this.logger.info('Disconnecting');\n\n    if (this.peer) {\n      await this.peer.disconnect();\n      this.peer = null;\n    }\n\n    if (this.connection) {\n      await this.connection.disconnect();\n      this.connection = null;\n    }\n  }\n\n  /**\n   * Query service interface from server\n   */\n  queryInterface<T = any>(serviceName: string): T {\n    if (!this.peer) {\n      throw new Error('Not connected. Call connect() first.');\n    }\n\n    // Split service name into name and version\n    let name: string;\n    let version: string | undefined;\n\n    if (serviceName.includes('@')) {\n      [name, version] = serviceName.split('@');\n    } else {\n      name = serviceName;\n    }\n\n    // Create service proxy\n    return this.createServiceProxy(name, version);\n  }\n\n  /**\n   * Create a proxy for service method calls\n   */\n  private createServiceProxy<T>(serviceName: string, version?: string): T {\n    const qualifiedName = version ? getQualifiedName(serviceName, version) : serviceName;\n\n    // Special properties that should not trigger proxy\n    const SPECIAL_PROPERTIES = [\n      'then',\n      'catch',\n      'finally',\n      'constructor',\n      'prototype',\n      Symbol.toStringTag,\n      Symbol.iterator,\n      Symbol.asyncIterator,\n    ];\n\n    return new Proxy({} as T, {\n      get: (_target, prop: string | symbol) => {\n        // Filter out special properties\n        if (SPECIAL_PROPERTIES.includes(prop as any)) {\n          return undefined;\n        }\n\n        // Return undefined for internal properties\n        if (typeof prop === 'symbol' || prop.startsWith('_')) {\n          return undefined;\n        }\n\n        // Return a function that calls the remote method\n        return async (...args: any[]) => {\n          if (!this.peer) {\n            throw new Error('Not connected');\n          }\n\n          // Query service definition if not already cached\n          let def = Array.from(this.peer.definitions.values()).find(\n            (d) => d.meta.name === qualifiedName\n          );\n\n          if (!def) {\n            // Request service definition from server\n            def = await this.peer.runTask('query_interface', qualifiedName);\n            if (def) {\n              this.peer.refService(def);\n            }\n          }\n\n          if (!def) {\n            throw new Error(`Service not found: ${qualifiedName}`);\n          }\n\n          // Call the method\n          return await this.peer.call(def.id, prop as string, args);\n        };\n      },\n    });\n  }\n\n  /**\n   * Check if connected\n   */\n  isConnected(): boolean {\n    return this.connection !== null && this.connection.isConnected();\n  }\n\n  /**\n   * Get client metrics\n   */\n  getMetrics() {\n    return {\n      id: this.id,\n      connected: this.isConnected(),\n      serverId: this.peer?.id,\n    };\n  }\n\n  /**\n   * Generate unique client ID\n   */\n  private generateId(): string {\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n      return crypto.randomUUID();\n    }\n\n    // Fallback for older browsers\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n      const r = (Math.random() * 16) | 0;\n      const v = c === 'x' ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  }\n}\n", "export * from './types.js';\nexport * from './emitter.js';\nexport * from './history.js';\nexport * from './metrics.js';\nexport * from './wildcard.js';\nexport * from './scheduler.js';\nexport * from './predicates.js';\nexport * from './enhanced-emitter.js';\n", "export {};\n//# sourceMappingURL=types.js.map", "/* eslint-disable @typescript-eslint/no-unsafe-function-type */\nimport { pLimit, type Limit } from '@omnitron-dev/common';\n\n// Type for event listener\ntype EventListener = {\n  fn: Function;\n  context: any;\n  once: boolean;\n};\n\n// EventEmitter implementation that works in Node, Bun, and browser\n// Combines both synchronous and asynchronous event emission capabilities\nexport class EventEmitter {\n  private _events: Map<string | symbol, EventListener | EventListener[]> = new Map();\n  private _eventsCount: number = 0;\n  private onceListeners = new WeakMap<Function, Function>(); // Map to store listeners that should only be called once\n  private limiter?: Limit; // Optional limiter for controlling concurrency\n\n  constructor(concurrency?: number) {\n    // Set concurrency if a valid number is provided\n    if (concurrency && concurrency >= 1) {\n      this.setConcurrency(concurrency);\n    }\n  }\n\n  /**\n   * Return an array listing the events for which the emitter has registered listeners\n   */\n  eventNames(): Array<string | symbol> {\n    return Array.from(this._events.keys());\n  }\n\n  /**\n   * Return the listeners registered for a given event\n   */\n  listeners(event: string | symbol): Function[] {\n    const handlers = this._events.get(event);\n\n    if (!handlers) return [];\n\n    if (!Array.isArray(handlers)) {\n      return [handlers.fn];\n    }\n\n    return handlers.map((h) => h.fn);\n  }\n\n  /**\n   * Return the number of listeners listening to a given event\n   */\n  listenerCount(event: string | symbol): number {\n    const handlers = this._events.get(event);\n\n    if (!handlers) return 0;\n    if (!Array.isArray(handlers)) return 1;\n    return handlers.length;\n  }\n\n  /**\n   * Calls each of the listeners registered for a given event (synchronous)\n   */\n  emit(event: string | symbol, ...args: any[]): boolean {\n    const handlers = this._events.get(event);\n\n    if (!handlers) return false;\n\n    if (!Array.isArray(handlers)) {\n      // Single handler\n      if (handlers.once) {\n        this.removeListener(event, handlers.fn);\n      }\n      handlers.fn.apply(handlers.context, args);\n    } else {\n      // Multiple handlers - iterate over a copy to handle removal during emit\n      const handlersCopy = handlers.slice();\n      for (let i = 0; i < handlersCopy.length; i++) {\n        const handler = handlersCopy[i];\n        if (handler && handler.once) {\n          this.removeListener(event, handler.fn);\n        }\n        if (handler) {\n          handler.fn.apply(handler.context, args);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Add a listener for a given event\n   */\n  on(event: string | symbol, fn: Function, context?: any): this {\n    return this.addListener(event, fn, context, false);\n  }\n\n  /**\n   * Add a listener for a given event (alias for on)\n   */\n  addListener(event: string | symbol, fn: Function, context?: any, once: boolean = false): this {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The listener must be a function');\n    }\n\n    const listener: EventListener = {\n      fn,\n      context: context || this,\n      once: once || false,\n    };\n\n    const existing = this._events.get(event);\n\n    if (!existing) {\n      this._events.set(event, listener);\n      this._eventsCount++;\n    } else if (!Array.isArray(existing)) {\n      this._events.set(event, [existing, listener]);\n    } else {\n      existing.push(listener);\n    }\n\n    return this;\n  }\n\n  /**\n   * Add a one-time listener for a given event\n   */\n  once(event: string | symbol, fn: Function, context?: any): this {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The listener must be a function');\n    }\n\n    let fired = false;\n    const onceListener = (...args: any[]) => {\n      this.removeListener(event, onceListener);\n      if (!fired) {\n        fired = true;\n        return fn.apply(context || this, args);\n      }\n      return undefined;\n    };\n\n    this.on(event, onceListener);\n    this.onceListeners.set(fn, onceListener);\n    return this;\n  }\n\n  /**\n   * Remove a listener from a given event\n   */\n  removeListener(event: string | symbol, fn: Function): this {\n    // Check if this is a once listener\n    const onceListener = this.onceListeners.get(fn);\n    if (onceListener) {\n      this.onceListeners.delete(fn);\n      fn = onceListener;\n    }\n\n    const handlers = this._events.get(event);\n\n    if (!handlers) return this;\n\n    if (!Array.isArray(handlers)) {\n      // Single handler\n      if (handlers.fn === fn) {\n        this._events.delete(event);\n        this._eventsCount--;\n      }\n    } else {\n      // Multiple handlers\n      const filtered = handlers.filter((h) => h.fn !== fn);\n\n      if (filtered.length === 0) {\n        this._events.delete(event);\n        this._eventsCount--;\n      } else if (filtered.length === 1 && filtered[0]) {\n        this._events.set(event, filtered[0]);\n      } else {\n        this._events.set(event, filtered);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Remove listener (alias for removeListener)\n   */\n  off(event: string | symbol, fn: Function): this {\n    return this.removeListener(event, fn);\n  }\n\n  /**\n   * Remove all listeners, or those of the specified event\n   */\n  removeAllListeners(event?: string | symbol): this {\n    if (event) {\n      if (this._events.has(event)) {\n        this._events.delete(event);\n        this._eventsCount--;\n      }\n    } else {\n      this._events.clear();\n      this._eventsCount = 0;\n    }\n\n    return this;\n  }\n\n  // ============= Async Event Emitter Methods =============\n\n  /**\n   * Method to set concurrency limit using p-limit\n   */\n  setConcurrency(concurrency: number) {\n    if (concurrency >= 1) {\n      this.limiter = pLimit(concurrency);\n    }\n    return this;\n  }\n\n  /**\n   * Emit events in parallel, returning a promise that resolves when all listeners have been executed\n   */\n  emitParallel(event: any, ...args: any[]) {\n    const promises = this.listeners(event).map((listener) => this._executeListener(listener, args));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Emit events serially, ensuring each listener is executed one after the other\n   */\n  emitSerial(event: any, ...args: any[]) {\n    return this.listeners(event).reduce(\n      (promise, listener) =>\n        promise.then((values: any) =>\n          this._executeListener(listener, args).then((value: any) => {\n            values.push(value);\n            return values;\n          })\n        ),\n      Promise.resolve([])\n    );\n  }\n\n  /**\n   * Emit events using a reduce function, processing listeners from left to right\n   */\n  emitReduce(event: any, ...args: any[]) {\n    return this._emitReduceRun(event, args);\n  }\n\n  /**\n   * Emit events using a reduce function, processing listeners from right to left\n   */\n  emitReduceRight(event: any, ...args: any[]) {\n    return this._emitReduceRun(event, args, true);\n  }\n\n  /**\n   * Subscribe to an event with an option to only listen once\n   */\n  subscribe(event: any, listener: (...args: any[]) => void, once = false) {\n    const unsubscribe = () => {\n      this.removeListener(event, listener);\n    };\n\n    if (once) {\n      this.once(event, listener);\n    } else {\n      this.on(event, listener);\n    }\n\n    return unsubscribe;\n  }\n\n  /**\n   * Private method to handle reduce logic for event emission\n   */\n  private _emitReduceRun(event: any, args: any[], inverse = false) {\n    const listeners = inverse ? this.listeners(event).reverse() : this.listeners(event);\n    return listeners.reduce(\n      (promise, listener) =>\n        promise.then((prevArgs) => {\n          const currentArgs = Array.isArray(prevArgs) ? prevArgs : [prevArgs];\n          return this._executeListener(listener, currentArgs);\n        }),\n      Promise.resolve(args)\n    );\n  }\n\n  /**\n   * Private method to execute a listener with optional concurrency control\n   */\n  private _executeListener(listener: Function, args: any[]): Promise<any> {\n    try {\n      if (this.limiter) {\n        return this.limiter(() => listener(...args));\n      }\n      return Promise.resolve(listener(...args));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n}\n", "import type { EventRecord, EventFilter, EventStorage, EventHistoryOptions } from './types.js';\n\n/**\n * In-memory event storage implementation\n */\nexport class MemoryEventStorage implements EventStorage {\n  private records: EventRecord[] = [];\n  private maxSize: number;\n\n  constructor(maxSize = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  async save(record: EventRecord): Promise<void> {\n    this.records.push(record);\n\n    // Maintain max size\n    if (this.records.length > this.maxSize) {\n      this.records.shift(); // Remove oldest\n    }\n  }\n\n  async load(filter?: EventFilter): Promise<EventRecord[]> {\n    if (!filter) return [...this.records];\n\n    return this.records.filter(record => {\n      // Filter by event name/pattern\n      if (filter.event) {\n        if (typeof filter.event === 'string') {\n          if (!record.event.includes(filter.event)) return false;\n        } else if (filter.event instanceof RegExp) {\n          if (!filter.event.test(record.event)) return false;\n        }\n      }\n\n      // Filter by time range\n      if (filter.from && record.timestamp < filter.from.getTime()) return false;\n      if (filter.to && record.timestamp > filter.to.getTime()) return false;\n\n      // Filter by tags\n      if (filter.tags && filter.tags.length > 0) {\n        const recordTags = record.metadata.tags || [];\n        if (!filter.tags.some(tag => recordTags.includes(tag))) return false;\n      }\n\n      // Filter by correlation ID\n      if (filter.correlationId && record.metadata.correlationId !== filter.correlationId) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  async clear(): Promise<void> {\n    this.records = [];\n  }\n}\n\n/**\n * Event history manager\n */\nexport class EventHistory {\n  private enabled = false;\n  private storage: EventStorage;\n  private options: EventHistoryOptions;\n  private filter?: (event: string) => boolean;\n\n  constructor(options: EventHistoryOptions = {}) {\n    this.options = options;\n    this.storage = options.storage || new MemoryEventStorage(options.maxSize);\n    this.filter = options.filter;\n  }\n\n  /**\n   * Enable history recording\n   */\n  enable(): void {\n    this.enabled = true;\n  }\n\n  /**\n   * Disable history recording\n   */\n  disable(): void {\n    this.enabled = false;\n  }\n\n  /**\n   * Check if history is enabled\n   */\n  isEnabled(): boolean {\n    return this.enabled;\n  }\n\n  /**\n   * Record an event\n   */\n  async record(record: EventRecord): Promise<void> {\n    if (!this.enabled) return;\n\n    // Apply filter if configured\n    if (this.filter && !this.filter(record.event)) return;\n\n    // Check TTL if configured\n    if (this.options.ttl) {\n      const now = Date.now();\n      const age = now - record.timestamp;\n      if (age > this.options.ttl) return;\n    }\n\n    await this.storage.save(record);\n  }\n\n  /**\n   * Get event history\n   */\n  async getHistory(filter?: EventFilter): Promise<EventRecord[]> {\n    const records = await this.storage.load(filter);\n\n    // Apply TTL filter if configured\n    if (this.options.ttl) {\n      const now = Date.now();\n      return records.filter(record => {\n        const age = now - record.timestamp;\n        return age <= this.options.ttl!;\n      });\n    }\n\n    return records;\n  }\n\n  /**\n   * Clear history\n   */\n  async clear(): Promise<void> {\n    await this.storage.clear();\n  }\n\n  /**\n   * Export history for backup/testing\n   */\n  async export(): Promise<EventRecord[]> {\n    return this.storage.load();\n  }\n\n  /**\n   * Import history from backup/testing\n   */\n  async import(records: EventRecord[]): Promise<void> {\n    await this.clear();\n    for (const record of records) {\n      await this.storage.save(record);\n    }\n  }\n\n  /**\n   * Get statistics about recorded events\n   */\n  async getStats(): Promise<{\n    totalEvents: number;\n    uniqueEvents: number;\n    errorCount: number;\n    avgDuration: number;\n    eventCounts: Map<string, number>;\n  }> {\n    const records = await this.storage.load();\n    const eventCounts = new Map<string, number>();\n    let totalDuration = 0;\n    let errorCount = 0;\n    let durationCount = 0;\n\n    for (const record of records) {\n      // Count events\n      const count = eventCounts.get(record.event) || 0;\n      eventCounts.set(record.event, count + 1);\n\n      // Count errors\n      if (record.error) errorCount++;\n\n      // Calculate average duration\n      if (record.duration !== undefined) {\n        totalDuration += record.duration;\n        durationCount++;\n      }\n    }\n\n    return {\n      totalEvents: records.length,\n      uniqueEvents: eventCounts.size,\n      errorCount,\n      avgDuration: durationCount > 0 ? totalDuration / durationCount : 0,\n      eventCounts\n    };\n  }\n}", "import type { EmitterMetrics, MetricsOptions } from './types.js';\n\n/**\n * Performance metrics collector for EventEmitter\n */\nexport class MetricsCollector {\n  private enabled = false;\n  private options: MetricsOptions;\n\n  // Metrics data\n  private eventsEmitted = 0;\n  private eventsFailed = 0;\n  private listenerCounts = new Map<string, number>();\n  private processingTimes = new Map<string, number[]>();\n  private slowestEvents: Array<{ event: string; duration: number }> = [];\n  private eventCounts = new Map<string, number>();\n  private errorCounts = new Map<string, number>();\n  private startTime = Date.now();\n\n  constructor(options: MetricsOptions = {}) {\n    this.options = {\n      slowThreshold: options.slowThreshold || 100,\n      sampleRate: options.sampleRate || 1,\n      trackMemory: options.trackMemory !== false\n    };\n  }\n\n  /**\n   * Enable metrics collection\n   */\n  enable(): void {\n    this.enabled = true;\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Disable metrics collection\n   */\n  disable(): void {\n    this.enabled = false;\n  }\n\n  /**\n   * Check if metrics are enabled\n   */\n  isEnabled(): boolean {\n    return this.enabled;\n  }\n\n  /**\n   * Record event emission\n   */\n  recordEmission(event: string, success: boolean, duration?: number): void {\n    if (!this.enabled) return;\n\n    // Sample rate check\n    if (this.options.sampleRate! < 1 && Math.random() > this.options.sampleRate!) {\n      return;\n    }\n\n    // Update counters\n    this.eventsEmitted++;\n    const count = this.eventCounts.get(event) || 0;\n    this.eventCounts.set(event, count + 1);\n\n    if (!success) {\n      this.eventsFailed++;\n      const errorCount = this.errorCounts.get(event) || 0;\n      this.errorCounts.set(event, errorCount + 1);\n    }\n\n    // Record processing time\n    if (duration !== undefined) {\n      let times = this.processingTimes.get(event);\n      if (!times) {\n        times = [];\n        this.processingTimes.set(event, times);\n      }\n      times.push(duration);\n\n      // Keep only last 100 samples per event\n      if (times.length > 100) {\n        times.shift();\n      }\n\n      // Track slow events\n      if (duration > this.options.slowThreshold!) {\n        this.addSlowEvent(event, duration);\n      }\n    }\n  }\n\n  /**\n   * Update listener count for an event\n   */\n  updateListenerCount(event: string, count: number): void {\n    if (!this.enabled) return;\n    this.listenerCounts.set(event, count);\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): EmitterMetrics {\n    const avgProcessingTime = new Map<string, number>();\n\n    // Calculate average processing times\n    for (const [event, times] of this.processingTimes.entries()) {\n      if (times.length > 0) {\n        const avg = times.reduce((sum, t) => sum + t, 0) / times.length;\n        avgProcessingTime.set(event, avg);\n      }\n    }\n\n    // Calculate memory usage if enabled\n    let memoryUsage = 0;\n    if (this.options.trackMemory && typeof process !== 'undefined' && process.memoryUsage) {\n      memoryUsage = process.memoryUsage().heapUsed;\n    }\n\n    return {\n      eventsEmitted: this.eventsEmitted,\n      eventsFailed: this.eventsFailed,\n      listenerCount: new Map(this.listenerCounts),\n      avgProcessingTime,\n      slowestEvents: [...this.slowestEvents],\n      memoryUsage,\n      eventCounts: new Map(this.eventCounts),\n      errorCounts: new Map(this.errorCounts)\n    };\n  }\n\n  /**\n   * Export metrics in different formats\n   */\n  export(format: 'json' | 'prometheus' = 'json'): string {\n    const metrics = this.getMetrics();\n\n    if (format === 'json') {\n      return JSON.stringify({\n        timestamp: Date.now(),\n        uptime: Date.now() - this.startTime,\n        metrics: {\n          eventsEmitted: metrics.eventsEmitted,\n          eventsFailed: metrics.eventsFailed,\n          listenerCount: Object.fromEntries(metrics.listenerCount),\n          avgProcessingTime: Object.fromEntries(metrics.avgProcessingTime),\n          slowestEvents: metrics.slowestEvents,\n          memoryUsage: metrics.memoryUsage,\n          eventCounts: Object.fromEntries(metrics.eventCounts),\n          errorCounts: Object.fromEntries(metrics.errorCounts)\n        }\n      }, null, 2);\n    } else if (format === 'prometheus') {\n      // Prometheus format\n      const lines: string[] = [];\n\n      lines.push(`# HELP eventemitter_events_emitted_total Total number of events emitted`);\n      lines.push(`# TYPE eventemitter_events_emitted_total counter`);\n      lines.push(`eventemitter_events_emitted_total ${metrics.eventsEmitted}`);\n\n      lines.push(`# HELP eventemitter_events_failed_total Total number of failed events`);\n      lines.push(`# TYPE eventemitter_events_failed_total counter`);\n      lines.push(`eventemitter_events_failed_total ${metrics.eventsFailed}`);\n\n      lines.push(`# HELP eventemitter_memory_usage_bytes Current memory usage in bytes`);\n      lines.push(`# TYPE eventemitter_memory_usage_bytes gauge`);\n      lines.push(`eventemitter_memory_usage_bytes ${metrics.memoryUsage}`);\n\n      // Per-event metrics\n      for (const [event, count] of metrics.eventCounts.entries()) {\n        lines.push(`eventemitter_event_count{event=\"${event}\"} ${count}`);\n      }\n\n      for (const [event, count] of metrics.listenerCount.entries()) {\n        lines.push(`eventemitter_listener_count{event=\"${event}\"} ${count}`);\n      }\n\n      for (const [event, time] of metrics.avgProcessingTime.entries()) {\n        lines.push(`eventemitter_avg_processing_time_ms{event=\"${event}\"} ${time}`);\n      }\n\n      return lines.join('\\n');\n    }\n\n    return '';\n  }\n\n  /**\n   * Reset all metrics\n   */\n  reset(): void {\n    this.eventsEmitted = 0;\n    this.eventsFailed = 0;\n    this.listenerCounts.clear();\n    this.processingTimes.clear();\n    this.slowestEvents = [];\n    this.eventCounts.clear();\n    this.errorCounts.clear();\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Add a slow event to the tracking list\n   */\n  private addSlowEvent(event: string, duration: number): void {\n    this.slowestEvents.push({ event, duration });\n\n    // Sort by duration (slowest first)\n    this.slowestEvents.sort((a, b) => b.duration - a.duration);\n\n    // Keep only top 10 slowest\n    if (this.slowestEvents.length > 10) {\n      this.slowestEvents = this.slowestEvents.slice(0, 10);\n    }\n  }\n\n  /**\n   * Get summary statistics\n   */\n  getSummary(): string {\n    const metrics = this.getMetrics();\n    const uptime = Date.now() - this.startTime;\n    const eventsPerSecond = this.eventsEmitted / (uptime / 1000);\n    const failureRate = this.eventsEmitted > 0\n      ? (this.eventsFailed / this.eventsEmitted * 100).toFixed(2)\n      : '0.00';\n\n    return `\nEventEmitter Metrics Summary:\n=============================\nUptime: ${Math.floor(uptime / 1000)}s\nTotal Events: ${this.eventsEmitted}\nFailed Events: ${this.eventsFailed}\nFailure Rate: ${failureRate}%\nEvents/Second: ${eventsPerSecond.toFixed(2)}\nUnique Events: ${metrics.eventCounts.size}\nTotal Listeners: ${Array.from(metrics.listenerCount.values()).reduce((sum, c) => sum + c, 0)}\nMemory Usage: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)} MB\nSlowest Event: ${this.slowestEvents[0]?.event || 'N/A'} (${this.slowestEvents[0]?.duration || 0}ms)\n`.trim();\n  }\n}", "import type { PatternCache } from './types.js';\n\n/**\n * Wildcard pattern matcher for event names\n */\nexport class WildcardMatcher {\n  private delimiter: string;\n  private wildcard: string;\n  private globstar: string;\n  private cache: Map<string, PatternCache> = new Map();\n\n  constructor(delimiter = '.', wildcard = '*', globstar = '**') {\n    this.delimiter = delimiter;\n    this.wildcard = wildcard;\n    this.globstar = globstar;\n  }\n\n  /**\n   * Check if a pattern contains wildcards\n   */\n  isWildcard(pattern: string): boolean {\n    return pattern.includes(this.wildcard) || pattern.includes(this.globstar);\n  }\n\n  /**\n   * Match an event name against a pattern\n   */\n  match(eventName: string, pattern: string): boolean {\n    // Direct match\n    if (eventName === pattern) return true;\n\n    // No wildcards, no match\n    if (!this.isWildcard(pattern)) return false;\n\n    // Get or create cached pattern\n    const cached = this.getOrCreatePattern(pattern);\n    return cached.regex.test(eventName);\n  }\n\n  /**\n   * Find all patterns that match an event name\n   */\n  findMatchingPatterns(eventName: string, patterns: string[]): string[] {\n    return patterns.filter(pattern => this.match(eventName, pattern));\n  }\n\n  /**\n   * Get or create a cached pattern\n   */\n  private getOrCreatePattern(pattern: string): PatternCache {\n    let cached = this.cache.get(pattern);\n    if (!cached) {\n      cached = this.compilePattern(pattern);\n      this.cache.set(pattern, cached);\n    }\n    return cached;\n  }\n\n  /**\n   * Compile a pattern into a regex\n   */\n  private compilePattern(pattern: string): PatternCache {\n    const parts = pattern.split(this.delimiter);\n    const isWildcard = this.isWildcard(pattern);\n\n    if (!isWildcard) {\n      return {\n        pattern,\n        regex: new RegExp(`^${this.escapeRegex(pattern)}$`),\n        parts,\n        isWildcard: false\n      };\n    }\n\n    let regexStr = '^';\n    let addedDelimiter = false;\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n\n      // Handle undefined or empty parts (consecutive delimiters)\n      if (!part || part === '') {\n        if (i === 0) {\n          // Empty part at the beginning (e.g., \".start\" split gives [\"\", \"start\"])\n          // Don't add anything, but we'll need a delimiter before next non-empty part\n          addedDelimiter = false;\n        } else if (i === parts.length - 1) {\n          // Empty part at the end (e.g., \"end.\" split gives [\"end\", \"\"])\n          // Add delimiter if needed\n          if (!addedDelimiter && i > 0) {\n            regexStr += this.escapeRegex(this.delimiter);\n          }\n        } else {\n          // Empty part in the middle - add delimiter\n          if (!addedDelimiter) {\n            regexStr += this.escapeRegex(this.delimiter);\n            addedDelimiter = true;\n          }\n        }\n        continue;\n      }\n\n      // Add delimiter before part if not first and not already added\n      const needsDelimiter = i > 0 && !addedDelimiter;\n\n      if (part === this.globstar) {\n        // ** matches zero or more segments\n        if (i === 0) {\n          // ** at the beginning\n          if (parts.length === 1) {\n            // Just ** - matches everything\n            regexStr += '.*';\n          } else {\n            // **.something - matches \"something\" or \"anything.something\"\n            regexStr += `(?:.*${this.escapeRegex(this.delimiter)})?`;\n          }\n          addedDelimiter = true; // Delimiter already included in pattern\n        } else if (i === parts.length - 1) {\n          // ** at the end - matches remaining path or nothing\n          if (needsDelimiter) {\n            regexStr += `(?:${this.escapeRegex(this.delimiter)}.*)?`;\n          } else {\n            regexStr += '(?:.*)?';\n          }\n          addedDelimiter = false;\n        } else {\n          // ** in the middle - matches zero or more segments between parts\n          // Example: app.**.error should match:\n          //   - app.error (zero segments)\n          //   - app.db.error (one segment)\n          //   - app.db.connection.error (multiple segments)\n          if (needsDelimiter) {\n            const delim = this.escapeRegex(this.delimiter);\n            // Match either:\n            // - just delimiter for zero segments (app.error)\n            // - delimiter + content + delimiter for 1+ segments (app.xxx.error)\n            regexStr += `${delim}(?:.*${delim})?`;\n          } else {\n            // Should not happen in practice as ** in middle always follows something\n            regexStr += `(?:.*${this.escapeRegex(this.delimiter)})?`;\n          }\n          addedDelimiter = true; // Delimiter is already part of the pattern\n        }\n      } else if (part === this.wildcard) {\n        if (needsDelimiter) {\n          regexStr += this.escapeRegex(this.delimiter);\n        }\n        // * matches exactly one segment (not containing delimiter, can be empty)\n        regexStr += `[^${this.escapeRegex(this.delimiter)}]*`;\n        addedDelimiter = false;\n      } else if (part.includes(this.wildcard)) {\n        if (needsDelimiter) {\n          regexStr += this.escapeRegex(this.delimiter);\n        }\n        // Handle partial wildcards like \"user*\" or \"*Service\"\n        let partRegex = '';\n        let lastIdx = 0;\n        let idx = part.indexOf(this.wildcard);\n\n        while (idx !== -1) {\n          if (idx > lastIdx) {\n            partRegex += this.escapeRegex(part.substring(lastIdx, idx));\n          }\n          partRegex += `[^${this.escapeRegex(this.delimiter)}]*`;\n          lastIdx = idx + this.wildcard.length;\n          idx = part.indexOf(this.wildcard, lastIdx);\n        }\n\n        if (lastIdx < part.length) {\n          partRegex += this.escapeRegex(part.substring(lastIdx));\n        }\n\n        regexStr += partRegex;\n        addedDelimiter = false;\n      } else {\n        // Literal part\n        if (needsDelimiter) {\n          regexStr += this.escapeRegex(this.delimiter);\n        }\n        regexStr += this.escapeRegex(part);\n        addedDelimiter = false;\n      }\n    }\n    regexStr += '$';\n\n    const regex = new RegExp(regexStr);\n\n    return {\n      pattern,\n      regex,\n      parts,\n      isWildcard: true\n    };\n  }\n\n  /**\n   * Escape special regex characters\n   */\n  private escapeRegex(str: string): string {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  }\n\n  /**\n   * Clear the pattern cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache size for monitoring\n   */\n  getCacheSize(): number {\n    return this.cache.size;\n  }\n}", "import type { ScheduledEvent, ScheduleOptions } from './types.js';\n\n/**\n * Event scheduler for delayed and recurring events\n */\nexport class EventScheduler {\n  private scheduledEvents: Map<string, ScheduledEvent> = new Map();\n  private timers: Map<string, NodeJS.Timeout> = new Map();\n  private nextId = 0;\n\n  /**\n   * Schedule an event for future emission\n   */\n  schedule(\n    event: string,\n    data: any,\n    options: ScheduleOptions,\n    emitFn: (event: string, data: any) => void | Promise<void>\n  ): string {\n    const id = this.generateId();\n    const now = Date.now();\n\n    let executeAt: number;\n\n    if (options.at) {\n      executeAt = options.at.getTime();\n    } else if (options.delay) {\n      executeAt = now + options.delay;\n    } else {\n      executeAt = now;\n    }\n\n    const scheduledEvent: ScheduledEvent = {\n      id,\n      event,\n      data,\n      options,\n      scheduledAt: now,\n      executeAt,\n      status: 'pending'\n    };\n\n    this.scheduledEvents.set(id, scheduledEvent);\n\n    // Handle cron expressions (simplified - would need a proper cron library in production)\n    if (options.cron) {\n      // For demo purposes, we'll interpret simple cron patterns\n      this.scheduleRecurring(id, scheduledEvent, emitFn);\n    } else {\n      // Schedule one-time event\n      const delay = Math.max(0, executeAt - now);\n      const timer = setTimeout(async () => {\n        try {\n          await this.executeScheduledEvent(id, scheduledEvent, emitFn);\n        } catch {\n          // Error is already handled in executeScheduledEvent, just prevent unhandled rejection\n        }\n      }, delay);\n\n      this.timers.set(id, timer);\n    }\n\n    return id;\n  }\n\n  /**\n   * Cancel a scheduled event\n   */\n  cancel(id: string): boolean {\n    const timer = this.timers.get(id);\n    if (timer) {\n      clearTimeout(timer);\n      this.timers.delete(id);\n    }\n\n    const event = this.scheduledEvents.get(id);\n    if (event) {\n      event.status = 'cancelled';\n      this.scheduledEvents.delete(id);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Cancel all scheduled events\n   */\n  cancelAll(): void {\n    for (const timer of this.timers.values()) {\n      clearTimeout(timer);\n    }\n    this.timers.clear();\n    this.scheduledEvents.clear();\n  }\n\n  /**\n   * Get scheduled events\n   */\n  getScheduledEvents(): ScheduledEvent[] {\n    return Array.from(this.scheduledEvents.values());\n  }\n\n  /**\n   * Get pending events\n   */\n  getPendingEvents(): ScheduledEvent[] {\n    return Array.from(this.scheduledEvents.values())\n      .filter(event => event.status === 'pending');\n  }\n\n  /**\n   * Execute a scheduled event\n   */\n  private async executeScheduledEvent(\n    id: string,\n    scheduledEvent: ScheduledEvent,\n    emitFn: (event: string, data: any) => void | Promise<void>\n  ): Promise<void> {\n    const event = this.scheduledEvents.get(id);\n    if (!event || event.status !== 'pending') return;\n\n    event.status = 'executing';\n\n    try {\n      await this.executeWithRetry(\n        () => emitFn(scheduledEvent.event, scheduledEvent.data),\n        scheduledEvent.options.retry\n      );\n\n      event.status = 'completed';\n    } catch (error) {\n      event.status = 'failed';\n      throw error;\n    } finally {\n      this.scheduledEvents.delete(id);\n      this.timers.delete(id);\n    }\n  }\n\n  /**\n   * Execute with retry logic\n   */\n  private async executeWithRetry(\n    fn: () => void | Promise<void>,\n    retryOptions?: any\n  ): Promise<void> {\n    if (!retryOptions) {\n      return fn();\n    }\n\n    const maxAttempts = retryOptions.maxAttempts || 3;\n    const delay = retryOptions.delay || 1000;\n    const backoff = retryOptions.backoff || 'linear';\n    const factor = retryOptions.factor || 2;\n    const maxDelay = retryOptions.maxDelay || 30000;\n\n    let lastError: Error | undefined;\n\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error as Error;\n\n        if (attempt < maxAttempts) {\n          let waitTime = delay;\n\n          if (backoff === 'exponential') {\n            waitTime = Math.min(delay * Math.pow(factor, attempt - 1), maxDelay);\n          } else if (backoff === 'linear') {\n            waitTime = Math.min(delay * attempt, maxDelay);\n          }\n\n          await this.sleep(waitTime);\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Schedule recurring event (simplified implementation)\n   */\n  private scheduleRecurring(\n    id: string,\n    scheduledEvent: ScheduledEvent,\n    emitFn: (event: string, data: any) => void | Promise<void>\n  ): void {\n    // This is a simplified implementation\n    // In production, you'd want to use a proper cron library\n    const interval = this.parseCronInterval(scheduledEvent.options.cron!);\n\n    if (interval > 0) {\n      const timer = setInterval(async () => {\n        const event = this.scheduledEvents.get(id);\n        if (!event) {\n          clearInterval(timer);\n          return;\n        }\n\n        try {\n          await emitFn(scheduledEvent.event, scheduledEvent.data);\n        } catch (error) {\n          // Log error but continue recurring\n          console.error(`Recurring event ${id} failed:`, error);\n        }\n      }, interval);\n\n      this.timers.set(id, timer as any);\n    }\n  }\n\n  /**\n   * Parse cron expression to interval (simplified)\n   */\n  private parseCronInterval(cron: string): number {\n    // Very simplified cron parsing - just for demo\n    // Real implementation would use a proper cron parser\n\n    // Handle some common patterns\n    if (cron === '* * * * *') return 60000; // Every minute\n    if (cron === '*/5 * * * *') return 5 * 60000; // Every 5 minutes\n    if (cron === '0 * * * *') return 60 * 60000; // Every hour\n    if (cron === '0 0 * * *') return 24 * 60 * 60000; // Daily\n\n    // Default to hourly\n    return 60 * 60000;\n  }\n\n  /**\n   * Sleep helper\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Generate unique ID\n   */\n  private generateId(): string {\n    return `scheduled_${Date.now()}_${++this.nextId}`;\n  }\n}", "import { EventEmitter } from './emitter.js';\nimport { EnhancedEventEmitter } from './enhanced-emitter.js';\n\nexport const isEventEmitter = (obj: any) => obj instanceof EventEmitter;\n\nexport const isEnhancedEventEmitter = (obj: any) => obj instanceof EnhancedEventEmitter;", "\n/* eslint-disable @typescript-eslint/no-unsafe-function-type */\n\nimport { EventEmitter } from './emitter.js';\nimport { EventHistory } from './history.js';\nimport { WildcardMatcher } from './wildcard.js';\nimport { EventScheduler } from './scheduler.js';\nimport { MetricsCollector } from './metrics.js';\n\nimport type {\n  EventMap,\n  ListenerFn,\n  EmitOptions,\n  EventFilter,\n  EventRecord,\n  BatchOptions,\n  EventMetadata,\n  EmitterMetrics,\n  MetricsOptions,\n  WildcardOptions,\n  ScheduleOptions,\n  ListenerOptions,\n  EventInterceptor,\n  ValidationSchema,\n  EventHistoryOptions,\n  ErrorHandlingOptions\n} from './types.js';\n\n/**\n * Enhanced EventEmitter with advanced features\n */\nexport class EnhancedEventEmitter<TEventMap extends EventMap = EventMap> extends EventEmitter {\n  // Feature modules\n  private wildcardMatcher: WildcardMatcher;\n  private history: EventHistory;\n  private scheduler: EventScheduler;\n  private metrics: MetricsCollector;\n\n  // Configuration\n  private wildcardEnabled: boolean;\n  private delimiter: string;\n\n  // Interceptors and middleware\n  private globalInterceptors: EventInterceptor[] = [];\n  private eventInterceptors: Map<string, EventInterceptor[]> = new Map();\n\n  // Validation schemas\n  private schemas: Map<string, ValidationSchema> = new Map();\n\n  // Batching configuration\n  private batchConfigs: Map<string, BatchOptions> = new Map();\n  private batchBuffers: Map<string, any[]> = new Map();\n  private batchTimers: Map<string, NodeJS.Timeout> = new Map();\n\n  // Throttle/Debounce configurations\n  private throttleConfigs: Map<string, { interval: number; lastEmit: number }> = new Map();\n  private debounceConfigs: Map<string, { delay: number; timer?: NodeJS.Timeout }> = new Map();\n\n  // Error handling\n  private errorHandlers: Map<string, ErrorHandlingOptions> = new Map();\n  private globalErrorHandler?: (error: Error, event: string, data: any, metadata?: EventMetadata) => void;\n\n  // Circuit breakers\n  private circuitBreakers: Map<string, {\n    failures: number;\n    lastFailure: number;\n    state: 'closed' | 'open' | 'half-open';\n    options: any;\n  }> = new Map();\n\n  constructor(options: WildcardOptions & { concurrency?: number } = {}) {\n    super(options.concurrency);\n\n    // Initialize wildcard support\n    this.delimiter = options.delimiter || '.';\n    this.wildcardEnabled = options.wildcard !== false;\n    this.wildcardMatcher = new WildcardMatcher(this.delimiter, '*', '**');\n\n    // Initialize feature modules\n    this.history = new EventHistory();\n    this.scheduler = new EventScheduler();\n    this.metrics = new MetricsCollector();\n  }\n\n  /**\n   * Type-safe emit for mapped events\n   */\n  emitTyped<K extends keyof TEventMap>(\n    event: K,\n    data: TEventMap[K],\n    options?: EmitOptions\n  ): boolean {\n    return this.emitEnhanced(event as string, data, options);\n  }\n\n  /**\n   * Type-safe on for mapped events\n   */\n  onTyped<K extends keyof TEventMap>(\n    event: K,\n    listener: ListenerFn<TEventMap[K]>,\n    options?: ListenerOptions\n  ): this {\n    return this.onEnhanced(event as string, listener, options);\n  }\n\n  /**\n   * Override emit to add throttle/debounce support\n   */\n  override emit(event: string | symbol, ...args: any[]): boolean {\n    const eventName = String(event);\n\n    // Check for throttle config\n    if (this.throttleConfigs.has(eventName)) {\n      const config = this.throttleConfigs.get(eventName)!;\n      const now = Date.now();\n      if (now - config.lastEmit < config.interval) {\n        return false; // Throttled\n      }\n      config.lastEmit = now;\n    }\n\n    // Check for debounce config\n    if (this.debounceConfigs.has(eventName)) {\n      const config = this.debounceConfigs.get(eventName)!;\n      if (config.timer) {\n        clearTimeout(config.timer);\n      }\n      config.timer = setTimeout(() => {\n        super.emit(event, ...args);\n        config.timer = undefined;\n      }, config.delay);\n      return false; // Debounced, will emit later\n    }\n\n    return super.emit(event, ...args);\n  }\n\n  /**\n   * Enhanced emit with metadata and options\n   */\n  emitEnhanced(event: string, data?: any, options?: EmitOptions): boolean {\n    const startTime = Date.now();\n    const metadata = this.createMetadata(options?.metadata);\n\n    try {\n      // Check for throttle config\n      if (this.throttleConfigs.has(event)) {\n        const config = this.throttleConfigs.get(event)!;\n        const now = Date.now();\n        if (now - config.lastEmit < config.interval) {\n          return false; // Throttled\n        }\n        config.lastEmit = now;\n      }\n\n      // Check for debounce config\n      if (this.debounceConfigs.has(event)) {\n        const config = this.debounceConfigs.get(event)!;\n        if (config.timer) {\n          clearTimeout(config.timer);\n        }\n        config.timer = setTimeout(() => {\n          // Emit the event after debounce delay\n          this.emitWithMetadata(event, data, metadata);\n        }, config.delay);\n        return false; // Debounced, will emit later\n      }\n\n      // Validate if schema exists\n      if (options?.validate !== false && this.schemas.has(event)) {\n        const schema = this.schemas.get(event)!;\n        const validation = schema.validate(data);\n        if (!validation.valid) {\n          throw new Error(`Validation failed: ${JSON.stringify(validation.errors)}`);\n        }\n      }\n\n      // Apply before interceptors\n      data = this.applyBeforeInterceptors(event, data, metadata);\n\n      // Check if event should be batched\n      if (this.batchConfigs.has(event)) {\n        this.addToBatch(event, data, metadata);\n        return true;\n      }\n\n      // Handle wildcard listeners\n      let handled = false;\n      if (this.wildcardEnabled) {\n        handled = this.emitWithWildcard(event, data, metadata);\n      } else {\n        handled = this.emitWithMetadata(event, data, metadata);\n      }\n\n      // Apply after interceptors\n      this.applyAfterInterceptors(event, data, metadata, undefined);\n\n      // Record metrics\n      const duration = Date.now() - startTime;\n      this.metrics.recordEmission(event, true, duration);\n\n      // Record history\n      if (this.history.isEnabled()) {\n        const record: EventRecord = {\n          event,\n          data,\n          metadata,\n          timestamp: Date.now(),\n          duration\n        };\n        this.history.record(record);\n      }\n\n      return handled;\n    } catch (error) {\n      // Handle errors\n      this.handleError(event, error as Error, data, metadata);\n\n      // Record failed metrics\n      this.metrics.recordEmission(event, false);\n\n      // Record error in history\n      if (this.history.isEnabled()) {\n        const record: EventRecord = {\n          event,\n          data,\n          metadata,\n          timestamp: Date.now(),\n          error: error as Error,\n          duration: Date.now() - startTime\n        };\n        this.history.record(record);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Enhanced on with options\n   */\n  onEnhanced(event: string, listener: Function, options?: ListenerOptions): this {\n    // Wrap listener with error boundary if requested\n    if (options?.errorBoundary) {\n      const originalListener = listener;\n      listener = async (...args: any[]) => {\n        try {\n          return await originalListener(...args);\n        } catch (error) {\n          if (options.onError) {\n            options.onError(error as Error, args[0], args[1]);\n          }\n          // Don't re-throw error when error boundary is enabled\n          return undefined;\n        }\n      };\n    }\n\n    // Add timeout if specified\n    if (options?.timeout) {\n      const originalListener = listener;\n      listener = async (...args: any[]) => Promise.race([\n        originalListener(...args),\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error('Listener timeout')), options.timeout)\n        )\n      ]);\n    }\n\n    return super.on(event, listener);\n  }\n\n  /**\n   * Emit with wildcard pattern matching\n   */\n  private emitWithWildcard(event: string, data: any, metadata: EventMetadata): boolean {\n    const allEvents = this.eventNames() as string[];\n    const matchingPatterns = allEvents.filter(pattern =>\n      this.wildcardMatcher.match(event, pattern)\n    );\n\n    let handled = false;\n\n    // First emit to wildcard patterns (excluding exact match)\n    for (const pattern of matchingPatterns) {\n      if (pattern !== event) {  // Skip exact match here\n        // Include the actual event name in metadata for wildcard handlers\n        const wildcardMetadata = { ...metadata, event };\n        if (super.emit(pattern, data, wildcardMetadata)) {\n          handled = true;\n        }\n      }\n    }\n\n    // Then emit to exact match if exists\n    if (super.emit(event, data, metadata)) {\n      handled = true;\n    }\n\n    return handled;\n  }\n\n  /**\n   * Emit with metadata\n   */\n  private emitWithMetadata(event: string, data: any, metadata: EventMetadata): boolean {\n    return super.emit(event, data, metadata);\n  }\n\n  /**\n   * Emit event with reduce pattern\n   */\n  override async emitReduce<T = any, R = any>(\n    event: string,\n    data: T,\n    initialValue: R,\n    metadata?: EventMetadata\n  ): Promise<R> {\n    const listeners = this.listeners(event);\n    if (listeners.length === 0) return initialValue;\n\n    let accumulator = initialValue;\n\n    for (const listener of listeners) {\n      try {\n        // Call listener with data, metadata, and accumulator\n        const result = await Promise.resolve(listener(data, metadata, accumulator));\n        accumulator = result !== undefined ? result : accumulator;\n      } catch (error) {\n        // Handle errors, continue with current accumulator\n        this.handleError(event, error as Error, data, metadata || ({} as EventMetadata));\n      }\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Add interceptor\n   */\n  addInterceptor(interceptor: EventInterceptor): this;\n  addInterceptor(event: string, interceptor: EventInterceptor): this;\n  addInterceptor(\n    eventOrInterceptor: string | EventInterceptor,\n    interceptor?: EventInterceptor\n  ): this {\n    if (typeof eventOrInterceptor === 'string') {\n      // Event-specific interceptor\n      const event = eventOrInterceptor;\n      let interceptors = this.eventInterceptors.get(event);\n      if (!interceptors) {\n        interceptors = [];\n        this.eventInterceptors.set(event, interceptors);\n      }\n      interceptors.push(interceptor!);\n    } else {\n      // Global interceptor\n      this.globalInterceptors.push(eventOrInterceptor);\n    }\n    return this;\n  }\n\n  /**\n   * Enable event history\n   */\n  enableHistory(options?: EventHistoryOptions): this {\n    this.history = new EventHistory(options);\n    this.history.enable();\n    return this;\n  }\n\n  /**\n   * Get event history\n   */\n  async getHistory(filter?: EventFilter): Promise<EventRecord[]> {\n    return this.history.getHistory(filter);\n  }\n\n  /**\n   * Clear event history\n   */\n  async clearHistory(): Promise<void> {\n    return this.history.clear();\n  }\n\n  /**\n   * Export event history\n   */\n  async exportHistory(): Promise<EventRecord[]> {\n    return this.history.export();\n  }\n\n  /**\n   * Import event history\n   */\n  async importHistory(records: EventRecord[]): Promise<void> {\n    return this.history.import(records);\n  }\n\n  /**\n   * Replay events from history\n   */\n  async replay(filter?: EventFilter): Promise<void> {\n    const records = await this.history.getHistory(filter);\n    for (const record of records) {\n      this.emit(record.event, record.data);\n    }\n  }\n\n  /**\n   * Schedule an event\n   */\n  schedule(event: string, data: any, options: ScheduleOptions): string {\n    return this.scheduler.schedule(event, data, options, (e, d) => {\n      this.emitEnhanced(e, d);\n    });\n  }\n\n  /**\n   * Cancel scheduled event\n   */\n  cancelSchedule(id: string): boolean {\n    return this.scheduler.cancel(id);\n  }\n\n  /**\n   * Get scheduled events\n   */\n  getScheduledEvents() {\n    return this.scheduler.getScheduledEvents();\n  }\n\n  /**\n   * Configure event batching\n   */\n  batch(event: string, options: BatchOptions): this {\n    this.batchConfigs.set(event, options);\n    return this;\n  }\n\n  /**\n   * Register validation schema\n   */\n  registerSchema(event: string, schema: ValidationSchema): this {\n    this.schemas.set(event, schema);\n    return this;\n  }\n\n  /**\n   * Enable metrics collection\n   */\n  enableMetrics(options?: MetricsOptions): this {\n    this.metrics = new MetricsCollector(options);\n    this.metrics.enable();\n    return this;\n  }\n\n  /**\n   * Get metrics\n   */\n  getMetrics(): EmitterMetrics {\n    return this.metrics.getMetrics();\n  }\n\n  /**\n   * Export metrics\n   */\n  exportMetrics(format: 'json' | 'prometheus' = 'json'): string {\n    return this.metrics.export(format);\n  }\n\n  /**\n   * Get metrics summary\n   */\n  getMetricsSummary(): string {\n    return this.metrics.getSummary();\n  }\n\n  /**\n   * Set global error handler\n   */\n  onError(handler: (error: Error, event: string, data: any, metadata?: EventMetadata) => void): this {\n    this.globalErrorHandler = handler;\n    return this;\n  }\n\n  /**\n   * Throttle event emission\n   */\n  throttle(event: string, interval: number): this {\n    this.throttleConfigs.set(event, { interval, lastEmit: 0 });\n    return this;\n  }\n\n  /**\n   * Debounce event emission\n   */\n  debounce(event: string, delay: number): this {\n    this.debounceConfigs.set(event, { delay });\n    return this;\n  }\n\n  /**\n   * Create metadata object\n   */\n  private createMetadata(partial?: Partial<EventMetadata>): EventMetadata {\n    return {\n      id: this.generateId(),\n      timestamp: Date.now(),\n      ...partial\n    };\n  }\n\n  /**\n   * Apply before interceptors\n   */\n  private applyBeforeInterceptors(event: string, data: any, metadata: EventMetadata): any {\n    // Apply global interceptors\n    for (const interceptor of this.globalInterceptors) {\n      if (interceptor.before) {\n        data = interceptor.before(event, data, metadata);\n      }\n    }\n\n    // Apply event-specific interceptors (including wildcard patterns)\n    for (const [pattern, interceptors] of this.eventInterceptors.entries()) {\n      // Check if the pattern matches the event (handles wildcards)\n      if (this.wildcardMatcher.match(event, pattern)) {\n        for (const interceptor of interceptors) {\n          if (interceptor.before) {\n            data = interceptor.before(event, data, metadata);\n          }\n        }\n      }\n    }\n\n    return data;\n  }\n\n  /**\n   * Apply after interceptors\n   */\n  private applyAfterInterceptors(event: string, data: any, metadata: EventMetadata, result?: any): void {\n    // Apply global interceptors\n    for (const interceptor of this.globalInterceptors) {\n      if (interceptor.after) {\n        interceptor.after(event, data, metadata, result);\n      }\n    }\n\n    // Apply event-specific interceptors (including wildcard patterns)\n    for (const [pattern, interceptors] of this.eventInterceptors.entries()) {\n      // Check if the pattern matches the event (handles wildcards)\n      if (this.wildcardMatcher.match(event, pattern)) {\n        for (const interceptor of interceptors) {\n          if (interceptor.after) {\n            interceptor.after(event, data, metadata, result);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle errors\n   */\n  private handleError(event: string, error: Error, data: any, metadata: EventMetadata): void {\n    // Apply error interceptors\n    for (const interceptor of this.globalInterceptors) {\n      if (interceptor.error) {\n        interceptor.error(event, error, metadata);\n      }\n    }\n\n    const eventInterceptors = this.eventInterceptors.get(event);\n    if (eventInterceptors) {\n      for (const interceptor of eventInterceptors) {\n        if (interceptor.error) {\n          interceptor.error(event, error, metadata);\n        }\n      }\n    }\n\n    // Call global error handler\n    if (this.globalErrorHandler) {\n      this.globalErrorHandler(error, event, data, metadata);\n    }\n  }\n\n  /**\n   * Add to batch buffer\n   */\n  private addToBatch(event: string, data: any, metadata: EventMetadata): void {\n    const config = this.batchConfigs.get(event)!;\n\n    // Initialize buffer if needed\n    if (!this.batchBuffers.has(event)) {\n      this.batchBuffers.set(event, []);\n    }\n\n    const buffer = this.batchBuffers.get(event)!;\n    buffer.push({ data, metadata });\n\n    // Check if should flush\n    if (config.maxSize && buffer.length >= config.maxSize) {\n      this.flushBatch(event);\n    } else if (config.maxWait && !this.batchTimers.has(event)) {\n      // Set timer for max wait\n      const timer = setTimeout(() => {\n        this.flushBatch(event);\n      }, config.maxWait);\n      this.batchTimers.set(event, timer);\n    }\n  }\n\n  /**\n   * Flush batch buffer\n   */\n  private flushBatch(event: string): void {\n    const buffer = this.batchBuffers.get(event);\n    if (!buffer || buffer.length === 0) return;\n\n    // Clear timer if exists\n    const timer = this.batchTimers.get(event);\n    if (timer) {\n      clearTimeout(timer);\n      this.batchTimers.delete(event);\n    }\n\n    // Emit batch event\n    super.emit(`${event}:batch`, buffer);\n\n    // Clear buffer\n    this.batchBuffers.set(event, []);\n  }\n\n  /**\n   * Generate unique ID\n   */\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Emit events sequentially (alias for emitSerial from base class)\n   * This method ensures that event handlers are executed one after another\n   */\n  emitSequential(event: string | symbol, ...args: any[]): Promise<any[]> {\n    return this.emitSerial(event, ...args);\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose(): void {\n    this.scheduler.cancelAll();\n    this.history.disable();\n    this.metrics.disable();\n\n    // Clear batch timers\n    for (const timer of this.batchTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.batchTimers.clear();\n\n    this.removeAllListeners();\n  }\n}", "/**\n * Browser WebSocket Client for Netron\n *\n * Uses native browser WebSocket API with Netron's packet protocol\n * Compatible with Titan WebSocket server\n */\n\nimport { EventEmitter } from '@omnitron-dev/eventemitter';\nimport { encodePacket, decodePacket, Packet } from '../packet/index.js';\n\nexport interface WebSocketClientOptions {\n  url: string;\n  protocols?: string | string[];\n  timeout?: number;\n  reconnect?: boolean;\n  reconnectInterval?: number;\n  maxReconnectAttempts?: number;\n}\n\n/**\n * Browser WebSocket Connection using Netron packet protocol\n */\nexport class BrowserWebSocketConnection extends EventEmitter {\n  private ws: WebSocket | null = null;\n  private url: string;\n  private protocols?: string | string[];\n  private reconnectEnabled: boolean;\n  private reconnectInterval: number;\n  private maxReconnectAttempts: number;\n  private reconnectAttempts = 0;\n  private reconnectTimeout?: number;\n  private isManualDisconnect = false;\n\n  constructor(options: WebSocketClientOptions) {\n    super();\n    this.url = options.url;\n    this.protocols = options.protocols;\n    this.reconnectEnabled = options.reconnect ?? true;\n    this.reconnectInterval = options.reconnectInterval ?? 1000;\n    this.maxReconnectAttempts = options.maxReconnectAttempts ?? Infinity;\n  }\n\n  /**\n   * Connect to WebSocket server\n   */\n  async connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        this.isManualDisconnect = false;\n\n        // Create WebSocket connection\n        this.ws = new WebSocket(this.url, this.protocols);\n        this.ws.binaryType = 'arraybuffer';\n\n        // Handle connection open\n        this.ws.addEventListener('open', () => {\n          this.reconnectAttempts = 0;\n          this.emit('connect');\n          resolve();\n        });\n\n        // Handle incoming messages\n        this.ws.addEventListener('message', (event: MessageEvent) => {\n          this.handleMessage(event.data);\n        });\n\n        // Handle errors\n        this.ws.addEventListener('error', (event: Event) => {\n          const error = new Error('WebSocket error');\n          this.emit('error', error);\n          reject(error);\n        });\n\n        // Handle close\n        this.ws.addEventListener('close', (event: CloseEvent) => {\n          this.emit('disconnect', event.reason);\n\n          // Attempt reconnection if enabled and not manually disconnected\n          if (this.reconnectEnabled && !this.isManualDisconnect) {\n            this.attemptReconnect();\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Handle incoming message (binary data)\n   */\n  private handleMessage(data: ArrayBuffer): void {\n    try {\n      // Decode packet from binary data\n      const packet = decodePacket(data);\n      this.emit('packet', packet);\n\n      // Also emit raw message for compatibility\n      this.emit('message', data, true); // true = isBinary\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Send a packet through WebSocket\n   */\n  async sendPacket(packet: Packet): Promise<void> {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected');\n    }\n\n    // Encode packet to binary\n    const buffer = encodePacket(packet);\n\n    // Send as ArrayBuffer\n    this.ws.send(buffer);\n  }\n\n  /**\n   * Send raw data through WebSocket\n   */\n  async send(data: ArrayBuffer | Uint8Array): Promise<void> {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected');\n    }\n\n    this.ws.send(data);\n  }\n\n  /**\n   * Disconnect from WebSocket server\n   */\n  async disconnect(): Promise<void> {\n    this.isManualDisconnect = true;\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = undefined;\n    }\n\n    if (this.ws) {\n      if (this.ws.readyState === WebSocket.OPEN ||\n          this.ws.readyState === WebSocket.CONNECTING) {\n        this.ws.close(1000, 'Manual disconnect');\n      }\n      this.ws = null;\n    }\n  }\n\n  /**\n   * Check if connected\n   */\n  isConnected(): boolean {\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\n  }\n\n  /**\n   * Attempt to reconnect to the server\n   */\n  private attemptReconnect(): void {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      this.emit('reconnect-failed');\n      return;\n    }\n\n    this.reconnectAttempts++;\n    const delay = this.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1);\n\n    this.reconnectTimeout = window.setTimeout(async () => {\n      try {\n        await this.connect();\n        this.emit('reconnect');\n      } catch (error) {\n        // Will trigger another reconnect attempt via close event\n      }\n    }, delay);\n  }\n\n  /**\n   * Get remote address (not available in browser WebSocket)\n   */\n  get remoteAddress(): string | undefined {\n    return this.url;\n  }\n\n  /**\n   * Get local address (not available in browser WebSocket)\n   */\n  get localAddress(): string | undefined {\n    return undefined;\n  }\n}\n", "/**\n * Browser Remote Peer - Client-Only Implementation\n *\n * This is a simplified, browser-compatible version of RemotePeer from Titan.\n * Contains ONLY client methods - no server-side functionality.\n */\n\nimport { EventEmitter } from '@omnitron-dev/eventemitter';\nimport { TimedMap } from '@omnitron-dev/common';\n\nimport { Definition } from './definition.js';\nimport { BrowserWebSocketConnection } from './clients/websocket-client.js';\nimport {\n  Packet,\n  TYPE_GET,\n  TYPE_SET,\n  TYPE_CALL,\n  TYPE_TASK,\n  TYPE_STREAM,\n  createPacket,\n  encodePacket,\n  decodePacket,\n} from './packet/index.js';\nimport { REQUEST_TIMEOUT } from './constants.js';\n\n/**\n * Simple logger interface for browser\n */\ninterface SimpleLogger {\n  debug(...args: any[]): void;\n  info(...args: any[]): void;\n  warn(...args: any[]): void;\n  error(...args: any[]): void;\n}\n\n/**\n * Event subscriber type\n */\nexport type EventSubscriber = (data: any) => void | Promise<void>;\n\n/**\n * Browser Remote Peer - represents connection to Titan server\n */\nexport class BrowserRemotePeer extends EventEmitter {\n  public id: string;\n  private logger: SimpleLogger;\n  private connection: BrowserWebSocketConnection;\n\n  /**\n   * Map of response handlers for pending requests\n   */\n  private responseHandlers: TimedMap<\n    number,\n    { successHandler: (response: any) => void; errorHandler?: (data: any) => void }\n  >;\n\n  /** Map of service definitions indexed by definition ID */\n  public definitions = new Map<string, Definition>();\n\n  /** Map of event subscribers indexed by event name */\n  public eventSubscribers = new Map<string, EventSubscriber[]>();\n\n  /**\n   * Creates a new Browser Remote Peer\n   */\n  constructor(\n    connection: BrowserWebSocketConnection,\n    id: string = '',\n    logger?: SimpleLogger,\n    requestTimeout?: number\n  ) {\n    super();\n    this.connection = connection;\n    this.id = id;\n    this.logger = logger || console;\n\n    // Initialize response handlers with timeout\n    this.responseHandlers = new TimedMap<\n      number,\n      { successHandler: (response: any) => void; errorHandler?: (data: any) => void }\n    >(requestTimeout ?? REQUEST_TIMEOUT, (packetId: number) => {\n      const handlers = this.responseHandlers.get(packetId);\n      if (handlers?.errorHandler) {\n        handlers.errorHandler(new Error('Request timeout exceeded'));\n      }\n      this.responseHandlers.delete(packetId);\n    });\n  }\n\n  /**\n   * Initialize the peer connection\n   */\n  async init(): Promise<void> {\n    this.logger.info('Initializing browser remote peer');\n\n    // Setup packet handler\n    this.connection.on('packet', (packet: Packet) => {\n      this.handlePacket(packet);\n    });\n\n    // Setup disconnect handler\n    this.connection.on('disconnect', () => {\n      this.cleanup();\n    });\n  }\n\n  /**\n   * Subscribe to an event from the remote peer\n   */\n  async subscribe(eventName: string, handler: EventSubscriber): Promise<void> {\n    const handlers = this.eventSubscribers.get(eventName);\n    if (!handlers) {\n      this.eventSubscribers.set(eventName, [handler]);\n      await this.runTask('subscribe', eventName);\n    } else if (!handlers.includes(handler)) {\n      handlers.push(handler);\n    }\n  }\n\n  /**\n   * Unsubscribe from an event\n   */\n  async unsubscribe(eventName: string, handler: EventSubscriber): Promise<void> {\n    const handlers = this.eventSubscribers.get(eventName);\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index >= 0) {\n        handlers.splice(index, 1);\n        if (handlers.length === 0) {\n          this.eventSubscribers.delete(eventName);\n          await this.runTask('unsubscribe', eventName);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get a value from a service definition\n   */\n  get(defId: string, name: string): Promise<any> {\n    const def = this.definitions.get(defId);\n    if (!def) {\n      throw new Error(`Unknown definition: ${defId}`);\n    }\n\n    return new Promise<any>((resolve, reject) => {\n      this.sendRequest(\n        TYPE_GET,\n        [defId, name],\n        (result) => {\n          resolve(this.processResult(def, result));\n        },\n        reject\n      ).catch(reject);\n    });\n  }\n\n  /**\n   * Set a value in a service definition\n   */\n  set(defId: string, name: string, value: any): Promise<void> {\n    const def = this.definitions.get(defId);\n    if (!def) {\n      throw new Error(`Unknown definition: ${defId}`);\n    }\n\n    return new Promise<void>((resolve, reject) => {\n      this.sendRequest(\n        TYPE_SET,\n        [defId, name, value],\n        () => {\n          resolve();\n        },\n        reject\n      ).catch(reject);\n    });\n  }\n\n  /**\n   * Call a method on a service definition\n   */\n  call(defId: string, method: string, args: any[]): Promise<any> {\n    const def = this.definitions.get(defId);\n    if (!def) {\n      throw new Error(`Unknown definition: ${defId}`);\n    }\n\n    args = this.processArgs(def, args);\n    return new Promise<any>((resolve, reject) => {\n      this.sendRequest(\n        TYPE_CALL,\n        [defId, method, ...args],\n        (result) => {\n          resolve(this.processResult(def, result));\n        },\n        reject\n      ).catch(reject);\n    });\n  }\n\n  /**\n   * Disconnect from the remote peer\n   */\n  async disconnect(): Promise<void> {\n    this.logger.info('Disconnecting browser remote peer');\n    await this.connection.disconnect();\n    this.cleanup();\n  }\n\n  /**\n   * Execute a task on the remote peer\n   */\n  runTask(name: string, ...args: any[]): Promise<any> {\n    return new Promise<any>((resolve, reject) => {\n      this.sendRequest(\n        TYPE_TASK,\n        [name, ...args],\n        (result) => {\n          resolve(result);\n        },\n        reject\n      ).catch(reject);\n    });\n  }\n\n  /**\n   * Send a request to the remote peer\n   */\n  private async sendRequest(\n    type: number,\n    data: any,\n    successHandler: (response: any) => void,\n    errorHandler?: (data: any) => void\n  ): Promise<void> {\n    const packet = createPacket(Packet.nextId(), 1, type, data);\n    this.responseHandlers.set(packet.id, {\n      successHandler,\n      errorHandler,\n    });\n\n    await this.sendPacket(packet);\n  }\n\n  /**\n   * Send a packet to the remote peer\n   */\n  private async sendPacket(packet: Packet): Promise<void> {\n    if (!this.connection.isConnected()) {\n      throw new Error('Connection is not open');\n    }\n\n    await this.connection.sendPacket(packet);\n  }\n\n  /**\n   * Handle incoming packets\n   */\n  private handlePacket(packet: Packet): void {\n    this.logger.debug('Handling packet:', packet.getType());\n\n    // If it's a response (impulse = 0), handle it\n    if (packet.getImpulse() === 0) {\n      this.handleResponse(packet);\n      return;\n    }\n\n    // Client only needs to handle stream packets from server\n    const pType = packet.getType();\n    if (pType === TYPE_STREAM) {\n      // Handle incoming stream data\n      this.emit('stream', packet);\n    }\n  }\n\n  /**\n   * Handle a response packet\n   */\n  private handleResponse(packet: Packet): void {\n    const id = packet.id;\n    const handlers = this.responseHandlers.get(id);\n\n    if (handlers) {\n      this.responseHandlers.delete(id);\n      const data = packet.data;\n\n      if (packet.getError() === 0) {\n        handlers.successHandler(data);\n      } else {\n        handlers.errorHandler?.(data);\n      }\n    }\n  }\n\n  /**\n   * Process arguments before sending\n   */\n  private processArgs(def: Definition, args: any[]): any[] {\n    // In browser, we don't need complex processing\n    // Just return args as-is\n    // TODO: Add stream reference processing if needed\n    return args;\n  }\n\n  /**\n   * Process result after receiving\n   */\n  private processResult(def: Definition, result: any): any {\n    // In browser, we don't need complex processing\n    // Just return result as-is\n    // TODO: Add service definition unwrapping if needed\n    return result;\n  }\n\n  /**\n   * Reference a service definition\n   */\n  refService(def: Definition, parentDef?: Definition): Definition {\n    const existingDef = this.definitions.get(def.id);\n    if (existingDef) {\n      return existingDef;\n    }\n\n    if (parentDef) {\n      def.parentId = parentDef.id;\n    }\n    this.definitions.set(def.id, def);\n    return def;\n  }\n\n  /**\n   * Clean up resources\n   */\n  private cleanup(): void {\n    this.responseHandlers.clear();\n    this.eventSubscribers.clear();\n    this.definitions.clear();\n  }\n}\n", "/**\n * Generates a standardized event name for service-related events.\n * This function creates a predictable naming pattern for service events\n * by prefixing the service name with 'svc:'.\n *\n * @param {string} serviceName - The name of the service to generate an event name for\n * @returns {string} A formatted event name in the format 'svc:serviceName'\n * @example\n * getServiceEventName('auth') // returns 'svc:auth'\n */\nexport const getServiceEventName = (serviceName: string) => `svc:${serviceName}`;\n\n/**\n * Generates a standardized event name for peer-related events.\n * This function creates a predictable naming pattern for peer events\n * by prefixing the peer ID with 'peer:'.\n *\n * @param {string} peerId - The unique identifier of the peer\n * @returns {string} A formatted event name in the format 'peer:peerId'\n * @example\n * getPeerEventName('peer-123') // returns 'peer:peer-123'\n */\nexport const getPeerEventName = (peerId: string) => `peer:${peerId}`;\n\n/**\n * Constructs a qualified name by combining a base name with an optional version.\n * This function is used to create unique identifiers for services and other\n * components that support versioning.\n *\n * @param {string} name - The base name to qualify\n * @param {string} [version] - Optional version string to append\n * @returns {string} A qualified name in the format 'name' or 'name@version'\n * @example\n * getQualifiedName('auth', '1.0.0') // returns 'auth@1.0.0'\n * getQualifiedName('auth') // returns 'auth'\n */\nexport const getQualifiedName = (name: string, version?: string) => `${name}${version ? `@${version}` : ''}`;\n"],
  "mappings": "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AA,YAAG;AAAA,YAAK;AAAA,YACrE;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAI;AAAA,YAAK;AAAA,YAAK;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAI;AAAA,YAAI;AAAA,YAAK;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAI;AAAA,YACnE;AAAA,YAAK;AAAA;AAAA,YAEL;AAAA,YAAI;AAAA,YAAG;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAI;AAAA,YAAK;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAK;AAAA,YACrE;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAI;AAAA,YAAK;AAAA,YAAK;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAI;AAAA,YAAI;AAAA,YAAK;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAI;AAAA,YACnE;AAAA,YAAK;AAAA;AAAA,YAEL;AAAA,YAAI;AAAA,YAAG;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAI;AAAA,YAAK;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAK;AAAA,YACrE;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAI;AAAA,YAAK;AAAA,YAAK;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAI;AAAA,YAAI;AAAA,YAAK;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAI;AAAA,YACnE;AAAA,YAAK;AAAA;AAAA,YAEL;AAAA,YAAI;AAAA,YAAG;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAI;AAAA,YAAK;AAAA,YAAK;AAAA,YAAI;AAAA,YAAG;AAAA,YAAK;AAAA,YACrE;AAAA,YAAG;AAAA,YAAK;AAAA,YAAI;AAAA,YAAI;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",
  "names": ["isFinite", "toString", "isSafeInteger", "len", "i", "len2", "Buffer", "fromString", "isBuffer", "compare", "toString", "equals", "i", "byteLength", "init_dist", "isString", "isNegative", "StreamType", "import_buffer", "init_dist", "keys", "init_dist", "init_dist", "init_dist", "uid", "init_packet", "serializer", "init_serializer", "init_dist", "init_packet", "init_dist", "init_serializer", "serializer", "init_packet", "init_packet"]
}
