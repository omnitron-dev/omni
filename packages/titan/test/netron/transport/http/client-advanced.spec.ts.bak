/**
 * Advanced test suite for HttpTransportClient
 * Target: Increase coverage from 8.51% to >96%
 *
 * This suite covers all critical paths in the client.ts file:
 * - Invoke with peer (lines 67-73)
 * - Invoke with connection fallback (lines 76-81)
 * - Direct HTTP request (lines 84-96)
 * - HTTP error handling (lines 124-171)
 * - Close method (lines 177-184)
 * - Metrics (lines 189-196)
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { HttpTransportClient } from '../../../../src/netron/transport/http/client.js';
import { HttpConnection } from '../../../../src/netron/transport/http/connection.js';
import { HttpRemotePeer } from '../../../../src/netron/transport/http/peer.js';
import { ConnectionState } from '../../../../src/netron/transport/types.js';
import type { INetron } from '../../../../src/netron/types.js';
import { NetronErrors } from '../../../../src/errors/index.js';

describe('HttpTransportClient - Advanced Coverage', () => {
  let client: HttpTransportClient;
  let mockFetch: jest.Mock;
  let mockNetron: INetron;

  beforeEach(() => {
    // Mock global fetch
    mockFetch = jest.fn();
    global.fetch = mockFetch;

    // Create mock logger
    const mockLogger = {
      child: jest.fn().mockReturnValue({
        info: jest.fn(),
        error: jest.fn(),
        warn: jest.fn(),
        debug: jest.fn(),
        trace: jest.fn(),
        fatal: jest.fn()
      }),
      info: jest.fn(),
      error: jest.fn(),
      warn: jest.fn(),
      debug: jest.fn(),
      trace: jest.fn(),
      fatal: jest.fn()
    };

    // Create mock Netron instance
    mockNetron = {
      id: 'test-netron',
      services: new Map(),
      logger: mockLogger,
      registerService: jest.fn(),
      unregisterService: jest.fn(),
      getService: jest.fn(),
      hasService: jest.fn(),
      listServices: jest.fn(),
      connect: jest.fn(),
      disconnect: jest.fn(),
      on: jest.fn(),
      once: jest.fn(),
      off: jest.fn(),
      emit: jest.fn()
    } as any;

    // Default successful discovery response
    mockFetch.mockResolvedValue({
      ok: true,
      status: 200,
      headers: {
        get: jest.fn((name: string) => {
          if (name === 'Content-Type') return 'application/json';
          if (name === 'X-Netron-Version') return '2.0';
          return null;
        })
      },
      json: jest.fn().mockResolvedValue({
        server: {
          version: '2.0.0',
          protocol: '2.0',
          features: ['batch', 'discovery'],
          metadata: {}
        },
        services: {
          'Calculator@1.0.0': {
            name: 'Calculator@1.0.0',
            version: '1.0.0',
            methods: ['add', 'subtract', 'multiply', 'divide']
          }
        },
        contracts: {},
        timestamp: Date.now()
      })
    });
  });

  afterEach(async () => {
    if (client) {
      await client.close();
    }
    delete (global as any).fetch;
    jest.clearAllMocks();

    // Wait for any pending setImmediate callbacks
    await new Promise(resolve => setImmediate(resolve));
  });

  describe('Constructor and Initialization', () => {
    it('should strip trailing slash from baseUrl', () => {
      client = new HttpTransportClient('http://localhost:3000/');
      expect(client.getMetrics().baseUrl).toBe('http://localhost:3000');
    });

    it('should preserve baseUrl without trailing slash', () => {
      client = new HttpTransportClient('http://localhost:3000');
      expect(client.getMetrics().baseUrl).toBe('http://localhost:3000');
    });

    it('should initialize without netron instance', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      const metrics = client.getMetrics();
      expect(metrics.connected).toBe(true);
      expect(metrics.hasPeer).toBe(false);
    });

    it('should initialize with netron instance and create peer', async () => {
      client = new HttpTransportClient('http://localhost:3000', mockNetron);
      await client.initialize();

      // Wait for async peer initialization
      await new Promise(resolve => setTimeout(resolve, 200));

      const metrics = client.getMetrics();
      expect(metrics.connected).toBe(true);
      expect(metrics.hasPeer).toBe(true);
    });
  });

  describe('Invoke Method - Peer Path (Lines 67-73)', () => {
    it('should use peer when available and service method exists', async () => {
      // For this test, we need to simulate peer being available
      // Since peer setup is complex, we'll test the path by injecting a mock peer
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Create a mock peer with queryInterface method
      const mockService = {
        add: jest.fn().mockResolvedValue(42)
      };

      const mockPeer = {
        queryInterface: jest.fn().mockResolvedValue(mockService),
        close: jest.fn()
      };

      // Inject the mock peer
      (client as any).peer = mockPeer;

      const result = await client.invoke('Calculator@1.0.0', 'add', [{ a: 20, b: 22 }]);

      expect(result).toBe(42);
      expect(mockPeer.queryInterface).toHaveBeenCalledWith('Calculator@1.0.0');
      expect(mockService.add).toHaveBeenCalledWith({ a: 20, b: 22 });
    });

    it('should handle peer method call errors', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Mock peer with service that throws
      const mockService = {
        divide: jest.fn().mockRejectedValue(new Error('Division by zero'))
      };

      const mockPeer = {
        queryInterface: jest.fn().mockResolvedValue(mockService),
        close: jest.fn()
      };

      (client as any).peer = mockPeer;

      await expect(
        client.invoke('Calculator@1.0.0', 'divide', [{ a: 10, b: 0 }])
      ).rejects.toThrow('Division by zero');
    });

    it('should use peer for multiple method calls with connection reuse', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      const mockService = {
        add: jest.fn()
          .mockResolvedValueOnce(30)
          .mockResolvedValueOnce(50)
      };

      const mockPeer = {
        queryInterface: jest.fn().mockResolvedValue(mockService),
        close: jest.fn()
      };

      (client as any).peer = mockPeer;

      const result1 = await client.invoke('Calculator@1.0.0', 'add', [{ a: 10, b: 20 }]);
      const result2 = await client.invoke('Calculator@1.0.0', 'add', [{ a: 25, b: 25 }]);

      expect(result1).toBe(30);
      expect(result2).toBe(50);
      expect(mockService.add).toHaveBeenCalledTimes(2);
      expect(mockPeer.queryInterface).toHaveBeenCalledTimes(2);
    });

    it('should fallback to connection when peer queryInterface returns null', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Mock peer that returns null
      const mockPeer = {
        queryInterface: jest.fn().mockResolvedValue(null),
        close: jest.fn()
      };

      (client as any).peer = mockPeer;

      // Mock connection to handle the fallback
      const mockConnectionService = {
        add: jest.fn().mockResolvedValue(100)
      };

      const mockConnection = (client as any).connection;
      mockConnection.queryInterface = jest.fn().mockResolvedValue(mockConnectionService);

      const result = await client.invoke('Calculator@1.0.0', 'add', [{ a: 60, b: 40 }]);
      expect(result).toBe(100);
      expect(mockPeer.queryInterface).toHaveBeenCalled();
      expect(mockConnection.queryInterface).toHaveBeenCalled();
    });

    it('should fallback when peer method is not a function', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Mock peer returning service without the requested method
      const mockService = {
        subtract: jest.fn(), // Has subtract but not multiply
        multiply: 'not a function' // Not a function!
      };

      const mockPeer = {
        queryInterface: jest.fn().mockResolvedValue(mockService),
        close: jest.fn()
      };

      (client as any).peer = mockPeer;

      // Mock connection fallback
      const mockConnection = (client as any).connection;
      const mockConnectionService = {
        multiply: jest.fn().mockResolvedValue(200)
      };

      mockConnection.queryInterface = jest.fn().mockResolvedValue(mockConnectionService);

      const result = await client.invoke('Calculator@1.0.0', 'multiply', [{ a: 10, b: 20 }]);
      expect(result).toBe(200);
      expect(mockConnection.queryInterface).toHaveBeenCalled();
    });
  });

  describe('Invoke Method - Connection Fallback (Lines 76-81)', () => {
    it('should fallback to connection when peer unavailable', async () => {
      // Create client without netron (no peer)
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Mock connection service
      const mockConnection = (client as any).connection;
      const mockConnectionService = {
        add: jest.fn().mockResolvedValue(150)
      };

      if (mockConnection) {
        mockConnection.queryInterface = jest.fn().mockResolvedValue(mockConnectionService);
      }

      const result = await client.invoke('Calculator@1.0.0', 'add', [{ a: 100, b: 50 }]);
      expect(result).toBe(150);
      expect(mockConnectionService.add).toHaveBeenCalledWith({ a: 100, b: 50 });
    });

    it('should create service proxy via connection', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      const mockConnection = (client as any).connection;
      const mockService = {
        subtract: jest.fn().mockResolvedValue(25),
        multiply: jest.fn().mockResolvedValue(500)
      };

      if (mockConnection) {
        mockConnection.queryInterface = jest.fn().mockResolvedValue(mockService);
      }

      // Call multiple methods via connection
      const result1 = await client.invoke('Calculator@1.0.0', 'subtract', [{ a: 75, b: 50 }]);
      const result2 = await client.invoke('Calculator@1.0.0', 'multiply', [{ a: 50, b: 10 }]);

      expect(result1).toBe(25);
      expect(result2).toBe(500);
      expect(mockService.subtract).toHaveBeenCalledTimes(1);
      expect(mockService.multiply).toHaveBeenCalledTimes(1);
    });

    it('should handle connection queryInterface returning null', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Mock fetch for direct HTTP fallback
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'test-id',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: 999
        })
      });

      const result = await client.invoke('Calculator@1.0.0', 'add', [{ a: 500, b: 499 }]);
      expect(result).toBe(999);
    });

    it('should handle connection method not being a function', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      const mockConnection = (client as any).connection;

      // Return service but without the requested method
      if (mockConnection) {
        mockConnection.queryInterface = jest.fn().mockResolvedValue({
          otherMethod: jest.fn()
        });
      }

      // Mock fetch for direct HTTP fallback
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'test-id',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: 777
        })
      });

      const result = await client.invoke('Calculator@1.0.0', 'requestedMethod', [{}]);
      expect(result).toBe(777);
    });
  });

  describe('Invoke Method - Direct HTTP Path (Lines 84-96)', () => {
    it('should make direct HTTP request via connection proxy', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Mock successful HTTP response - connection.queryInterface will create a proxy
      // that calls sendRequestMessage, which uses fetch
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'test-req-1',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: { result: 42 }
        })
      });

      const result = await client.invoke(
        'Calculator@1.0.0',
        'add',
        [{ a: 20, b: 22 }],
        {
          context: { userId: 'user-123', traceId: 'trace-456' },
          hints: { timeout: 5000, priority: 'high' }
        }
      );

      expect(result).toEqual({ result: 42 });
      expect(mockFetch).toHaveBeenCalledWith(
        'http://localhost:3000/netron/invoke',
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-Netron-Version': '2.0'
          })
        })
      );
    });

    it('should handle successful HTTP responses with valid JSON', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'req-2',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: { items: [1, 2, 3], total: 3 }
        })
      });

      const result = await client.invoke('Service@1.0.0', 'getItems', [{}]);
      expect(result).toEqual({ items: [1, 2, 3], total: 3 });
    });

    it('should throw error for unsuccessful response (success: false)', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'req-3',
          version: '2.0',
          timestamp: Date.now(),
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Invalid input parameters'
          }
        })
      });

      await expect(
        client.invoke('Service@1.0.0', 'validate', [{ data: 'invalid' }])
      ).rejects.toThrow(/Invalid input parameters/);
    });

    it('should throw error when response has no error message', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'req-4',
          version: '2.0',
          timestamp: Date.now(),
          success: false
        })
      });

      await expect(
        client.invoke('Service@1.0.0', 'method', [{}])
      ).rejects.toThrow(/Method invocation failed/);
    });
  });

  describe('HTTP Request Error Handling (Lines 124-171)', () => {
    it('should handle HTTP 4xx client errors', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();


      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 400,
        statusText: 'Bad Request',
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'req-5',
          version: '2.0',
          timestamp: Date.now(),
          success: false,
          error: {
            code: 'BAD_REQUEST',
            message: 'Invalid request format'
          }
        })
      });

      await expect(
        client.invoke('Service@1.0.0', 'method', [{ invalid: true }])
      ).rejects.toThrow(/Invalid request format/);
    });

    it('should handle HTTP 404 errors', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();


      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 404,
        statusText: 'Not Found',
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'req-6',
          version: '2.0',
          timestamp: Date.now(),
          success: false,
          error: {
            code: 'NOT_FOUND',
            message: 'Service not found'
          }
        })
      });

      await expect(
        client.invoke('NonExistent@1.0.0', 'method', [{}])
      ).rejects.toThrow(/Service not found/);
    });

    it('should handle HTTP 5xx server errors', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();


      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        headers: { get: jest.fn() },
        json: jest.fn().mockRejectedValue(new Error('Invalid JSON'))
      });

      await expect(
        client.invoke('Service@1.0.0', 'method', [{}])
      ).rejects.toThrow(/HTTP 500: Internal Server Error/);
    });

    it('should handle HTTP 503 service unavailable', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();


      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 503,
        statusText: 'Service Unavailable',
        headers: { get: jest.fn() },
        json: jest.fn().mockRejectedValue(new Error('Cannot parse response'))
      });

      await expect(
        client.invoke('Service@1.0.0', 'method', [{}])
      ).rejects.toThrow(/HTTP 503: Service Unavailable/);
    });

    it('should handle JSON parsing errors in error responses', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();


      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 400,
        statusText: 'Bad Request',
        headers: { get: jest.fn() },
        json: jest.fn().mockRejectedValue(new Error('JSON parse error'))
      });

      await expect(
        client.invoke('Service@1.0.0', 'method', [{}])
      ).rejects.toThrow(/HTTP 400: Bad Request/);
    });

    it('should handle request timeout (AbortError)', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();


      const abortError = new Error('The operation was aborted');
      (abortError as any).name = 'AbortError';
      mockFetch.mockRejectedValueOnce(abortError);

      await expect(
        client.invoke('Service@1.0.0', 'slowMethod', [{}], { hints: { timeout: 1000 } })
      ).rejects.toThrow(/Request timeout after/);
    });

    it('should handle network errors', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();


      mockFetch.mockRejectedValueOnce(new Error('Network connection failed'));

      await expect(
        client.invoke('Service@1.0.0', 'method', [{}])
      ).rejects.toThrow(/Network connection failed/);
    });

    it('should handle DNS resolution errors', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();


      mockFetch.mockRejectedValueOnce(new Error('getaddrinfo ENOTFOUND'));

      await expect(
        client.invoke('Service@1.0.0', 'method', [{}])
      ).rejects.toThrow(/getaddrinfo ENOTFOUND/);
    });

    it('should use custom timeout from hints', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'req-7',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: 'ok'
        })
      });

      await client.invoke('Service@1.0.0', 'method', [{}], {
        hints: { timeout: 10000 }
      });

      expect(mockFetch).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          signal: expect.any(AbortSignal)
        })
      );
    });

    it('should use options timeout when no hints timeout', async () => {
      client = new HttpTransportClient('http://localhost:3000', undefined, {
        timeout: 15000
      });
      await client.initialize();

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'req-8',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: 'ok'
        })
      });

      await client.invoke('Service@1.0.0', 'method', [{}]);

      expect(mockFetch).toHaveBeenCalled();
    });

    it('should use default timeout when no options or hints', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'req-9',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: 'ok'
        })
      });

      await client.invoke('Service@1.0.0', 'method', [{}]);

      expect(mockFetch).toHaveBeenCalled();
    });

    it('should include custom headers from options', async () => {
      client = new HttpTransportClient('http://localhost:3000', undefined, {
        headers: {
          'Authorization': 'Bearer test-token',
          'X-Custom-Header': 'custom-value'
        }
      });
      await client.initialize();

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'req-10',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: 'ok'
        })
      });

      await client.invoke('Service@1.0.0', 'method', [{}]);

      expect(mockFetch).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          headers: expect.objectContaining({
            'Authorization': 'Bearer test-token',
            'X-Custom-Header': 'custom-value'
          })
        })
      );
    });
  });

  describe('Close Method (Lines 177-184)', () => {
    it('should close peer connection when available', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Inject mock peer
      const mockConnection = (client as any).connection;
      const mockPeer = {
        queryInterface: jest.fn(),
        close: jest.fn().mockResolvedValue(undefined)
      };
      (client as any).peer = mockPeer;

      const connectionCloseSpy = jest.spyOn(mockConnection, 'close');

      await client.close();

      expect(mockPeer.close).toHaveBeenCalled();
      const mockConnection = (client as any).connection;
      expect(connectionCloseSpy).toHaveBeenCalled();
    });

    it('should close connection when peer not available', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      const connectionCloseSpy = jest.spyOn(mockConnection, 'close');

      await client.close();

      expect(connectionCloseSpy).toHaveBeenCalled();
      // Verify connection was actually closed
      expect(mockConnection.state).toBe(ConnectionState.DISCONNECTED);
    });

    it('should handle close when not initialized', async () => {
      client = new HttpTransportClient('http://localhost:3000');

      // Close without initialization
      await expect(client.close()).resolves.not.toThrow();
    });

      const mockConnection = (client as any).connection;
    it('should be idempotent - multiple close calls', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      await client.close();
      await client.close(); // Second close should not throw

      // Connection stays defined but is in DISCONNECTED state
      expect(mockConnection.state).toBe(ConnectionState.DISCONNECTED);
    });

    it('should close both peer and connection in correct order', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      const closeCalls: string[] = [];

      const mockConnection = (client as any).connection;
      // Inject mock peer
      const mockPeer = {
        queryInterface: jest.fn(),
        close: jest.fn().mockImplementation(async () => {
          closeCalls.push('peer');
        })
      };
      (client as any).peer = mockPeer;

      jest.spyOn(mockConnection, 'close').mockImplementation(async () => {
        closeCalls.push('connection');
      });

      await client.close();

      expect(closeCalls).toEqual(['peer', 'connection']);
    });
  });

  describe('Metrics (Lines 189-196)', () => {
    it('should return metrics with baseUrl', () => {
      client = new HttpTransportClient('http://localhost:3000');

      const metrics = client.getMetrics();
      expect(metrics.baseUrl).toBe('http://localhost:3000');
    });

    it('should return connected status before initialization', () => {
      client = new HttpTransportClient('http://localhost:3000');

      const metrics = client.getMetrics();
      expect(metrics.connected).toBe(false);
    });

    it('should return connected status after initialization', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      const metrics = client.getMetrics();
      expect(metrics.connected).toBe(true);
    });

    it('should return hasPeer false when no netron provided', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      const metrics = client.getMetrics();
      expect(metrics.hasPeer).toBe(false);
    });

    it('should return hasPeer true when peer is set', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Inject mock peer
      const mockPeer = {
        queryInterface: jest.fn(),
        close: jest.fn()
      };
      (client as any).peer = mockPeer;

      const metrics = client.getMetrics();
      expect(metrics.hasPeer).toBe(true);
    });

    it('should return connection metrics when available', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      const metrics = client.getMetrics();
      expect(metrics.connectionMetrics).toBeDefined();
      expect(metrics.connectionMetrics.baseUrl).toBe('http://localhost:3000');
    });

    it('should return undefined connectionMetrics when not initialized', () => {
      client = new HttpTransportClient('http://localhost:3000');

      const metrics = client.getMetrics();
      expect(metrics.connectionMetrics).toBeUndefined();
    });

    it('should update metrics after close', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      // Inject mock peer
      const mockPeer = {
        queryInterface: jest.fn(),
        close: jest.fn()
      };
      (client as any).peer = mockPeer;

      let metrics = client.getMetrics();
      expect(metrics.connected).toBe(true);
      expect(metrics.hasPeer).toBe(true);

      await client.close();

      metrics = client.getMetrics();
      // Connection object still exists, so connected is true
      // But the connection state should be DISCONNECTED
      expect(metrics.connectionMetrics.state).toBe(ConnectionState.DISCONNECTED);
    });
  });

  describe('Edge Cases and Integration', () => {
    it('should handle initialize being called multiple times', async () => {
      client = new HttpTransportClient('http://localhost:3000');

      await client.initialize();
      await client.initialize(); // Second call should be idempotent

      const metrics = client.getMetrics();
      expect(metrics.connected).toBe(true);
    });

    it('should handle invoke before initialization', async () => {
      client = new HttpTransportClient('http://localhost:3000');

      // Don't call initialize() - invoke should do it automatically
      // First mock is for discovery (will be called by HttpConnection initialization)
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: {
          get: jest.fn((name: string) => {
            if (name === 'Content-Type') return 'application/json';
            if (name === 'X-Netron-Version') return '2.0';
            return null;
          })
        },
        json: jest.fn().mockResolvedValue({
          server: { version: '2.0.0', protocol: '2.0' },
          services: {},
          timestamp: Date.now()
        })
      });

      // Second mock is for the actual invoke call
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'auto-init',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: 'initialized'
        })
      });

      const result = await client.invoke('Service@1.0.0', 'method', [{}]);
      expect(result).toBe('initialized');
    });

    it('should properly serialize request with context and hints', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'context-test',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: 'success'
        })
      });

      await client.invoke(
        'Service@1.0.0',
        'method',
        [{ param1: 'value1' }],
        {
          context: {
            userId: 'user-456',
            traceId: 'trace-789',
            tenantId: 'tenant-123'
          },
          hints: {
            timeout: 5000,
            priority: 'high',
            cache: { maxAge: 60000 }
          }
        }
      );

      expect(mockFetch).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          body: expect.stringContaining('user-456')
        })
      );
    });

    it('should handle empty args array', async () => {
      client = new HttpTransportClient('http://localhost:3000');
      await client.initialize();

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        headers: { get: jest.fn() },
        json: jest.fn().mockResolvedValue({
          id: 'empty-args',
          version: '2.0',
          timestamp: Date.now(),
          success: true,
          data: 'no-args'
        })
      });

      const result = await client.invoke('Service@1.0.0', 'noArgMethod', []);
      expect(result).toBe('no-args');
    });
  });
});
