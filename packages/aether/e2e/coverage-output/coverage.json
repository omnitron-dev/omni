[
  {
    "url": "http://localhost:3456/",
    "scriptId": "4",
    "source": "\n    // Global test state accessible to Playwright\n    window.testState = {\n      ready: true\n    };\n\n    console.log('Test page loaded and ready');\n  ",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 151,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:3456/netron-unified.js",
    "scriptId": "13",
    "source": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// e2e/stubs/process-shim.js\nvar process, setImmediate, clearImmediate;\nvar init_process_shim = __esm({\n  \"e2e/stubs/process-shim.js\"() {\n    \"use strict\";\n    process = {\n      env: { NODE_ENV: \"production\" },\n      platform: \"browser\",\n      version: \"v22.0.0\",\n      cwd: /* @__PURE__ */ __name(() => \"/\", \"cwd\"),\n      nextTick: /* @__PURE__ */ __name((fn) => Promise.resolve().then(fn), \"nextTick\")\n    };\n    setImmediate = /* @__PURE__ */ __name((fn, ...args) => {\n      return setTimeout(() => fn(...args), 0);\n    }, \"setImmediate\");\n    clearImmediate = /* @__PURE__ */ __name((id) => {\n      return clearTimeout(id);\n    }, \"clearImmediate\");\n    globalThis.process = process;\n    globalThis.setImmediate = setImmediate;\n    globalThis.clearImmediate = clearImmediate;\n  }\n});\n\n// ../common/dist/primitives.js\nvar init_primitives = __esm({\n  \"../common/dist/primitives.js\"() {\n    \"use strict\";\n    init_process_shim();\n  }\n});\n\n// ../common/dist/predicates.js\nvar objectProto, hasOwnProperty, toString, funcToString, objectCtorString, isWindows, linux, freebsd, openbsd, darwin, sunos, aix, isNodejs, isArray, isBuffer, isPlainObject, isNan, isFinite2, isInteger, isSafeInteger;\nvar init_predicates = __esm({\n  \"../common/dist/predicates.js\"() {\n    \"use strict\";\n    init_process_shim();\n    objectProto = Object.prototype;\n    ({ hasOwnProperty } = objectProto);\n    ({ toString } = objectProto);\n    funcToString = Function.prototype.toString;\n    objectCtorString = funcToString.call(Object);\n    isWindows = process.platform === \"win32\";\n    linux = process.platform === \"linux\";\n    freebsd = process.platform === \"freebsd\";\n    openbsd = process.platform === \"openbsd\";\n    darwin = process.platform === \"darwin\";\n    sunos = process.platform === \"sunos\";\n    aix = process.platform === \"aix\";\n    isNodejs = Object.prototype.toString.call(typeof process !== \"undefined\" ? process : 0) === \"[object process]\";\n    ({ isArray } = Array);\n    isBuffer = /* @__PURE__ */ __name((obj) => obj != null && (Boolean(obj.constructor) && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj) || Boolean(obj._isBuffer)), \"isBuffer\");\n    isPlainObject = /* @__PURE__ */ __name((value) => {\n      if (!value || typeof value !== \"object\") {\n        return false;\n      }\n      const proto = Object.getPrototypeOf(value);\n      if (proto === null) {\n        return true;\n      }\n      const hasObjectPrototype = proto === Object.prototype || Object.getPrototypeOf(proto) === null;\n      if (!hasObjectPrototype) {\n        return false;\n      }\n      const stringTag = objectProto.toString.call(value);\n      return stringTag === \"[object Object]\";\n    }, \"isPlainObject\");\n    isNan = Number.isNaN;\n    ({ isFinite: isFinite2 } = Number);\n    ({ isInteger } = Number);\n    ({ isSafeInteger } = Number);\n  }\n});\n\n// ../common/dist/omit.js\nvar init_omit = __esm({\n  \"../common/dist/omit.js\"() {\n    \"use strict\";\n    init_process_shim();\n    init_primitives();\n    init_predicates();\n  }\n});\n\n// ../common/dist/entries.js\nvar objectOwnProps;\nvar init_entries = __esm({\n  \"../common/dist/entries.js\"() {\n    \"use strict\";\n    init_process_shim();\n    init_predicates();\n    objectOwnProps = Object.getOwnPropertyNames(Object.getPrototypeOf({}));\n  }\n});\n\n// ../common/dist/promise.js\nvar init_promise = __esm({\n  \"../common/dist/promise.js\"() {\n    \"use strict\";\n    init_process_shim();\n    init_entries();\n    init_primitives();\n    init_predicates();\n  }\n});\n\n// ../common/dist/p-limit.js\nfunction pLimit(concurrency) {\n  validateConcurrency(concurrency);\n  const queue = new Queue();\n  let activeCount = 0;\n  let currentConcurrency = concurrency;\n  const resumeNext = /* @__PURE__ */ __name(() => {\n    if (activeCount < currentConcurrency && queue.size > 0) {\n      activeCount++;\n      const resolveFunction = queue.dequeue();\n      if (resolveFunction) {\n        resolveFunction();\n      }\n    }\n  }, \"resumeNext\");\n  const next = /* @__PURE__ */ __name(() => {\n    activeCount--;\n    resumeNext();\n  }, \"next\");\n  const run = /* @__PURE__ */ __name(async (function_, resolve, arguments_) => {\n    const result = (async () => function_(...arguments_))();\n    resolve(result);\n    try {\n      await result;\n    } catch {\n    }\n    next();\n  }, \"run\");\n  const enqueue = /* @__PURE__ */ __name((function_, resolve, arguments_) => {\n    queue.enqueue(() => {\n      run(function_, resolve, arguments_);\n    });\n    (async () => {\n      await Promise.resolve();\n      if (activeCount < currentConcurrency && queue.size > 0) {\n        resumeNext();\n      }\n    })();\n  }, \"enqueue\");\n  const generator = /* @__PURE__ */ __name((function_, ...arguments_) => new Promise((resolve) => {\n    enqueue(function_, resolve, arguments_);\n  }), \"generator\");\n  Object.defineProperties(generator, {\n    activeCount: {\n      get: /* @__PURE__ */ __name(() => activeCount, \"get\")\n    },\n    pendingCount: {\n      get: /* @__PURE__ */ __name(() => queue.size, \"get\")\n    },\n    clearQueue: {\n      value: /* @__PURE__ */ __name(() => {\n        queue.clear();\n      }, \"value\")\n    },\n    concurrency: {\n      get: /* @__PURE__ */ __name(() => currentConcurrency, \"get\"),\n      set: /* @__PURE__ */ __name((newConcurrency) => {\n        validateConcurrency(newConcurrency);\n        currentConcurrency = newConcurrency;\n        const processQueue = typeof queueMicrotask !== \"undefined\" ? queueMicrotask : (fn) => Promise.resolve().then(fn);\n        processQueue(() => {\n          while (activeCount < currentConcurrency && queue.size > 0) {\n            resumeNext();\n          }\n        });\n      }, \"set\")\n    },\n    map: {\n      async value(array, mapperFunction) {\n        const promises = array.map((value, index) => this(mapperFunction, value, index));\n        return Promise.all(promises);\n      }\n    }\n  });\n  return generator;\n}\nfunction validateConcurrency(concurrency) {\n  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n    throw new TypeError(\"Expected `concurrency` to be a number from 1 and up\");\n  }\n}\nvar Queue;\nvar init_p_limit = __esm({\n  \"../common/dist/p-limit.js\"() {\n    \"use strict\";\n    init_process_shim();\n    Queue = class {\n      static {\n        __name(this, \"Queue\");\n      }\n      constructor() {\n        this._size = 0;\n      }\n      enqueue(value) {\n        const node = { value, next: void 0 };\n        if (this.tail) {\n          this.tail.next = node;\n          this.tail = node;\n        } else {\n          this.head = this.tail = node;\n        }\n        this._size++;\n      }\n      dequeue() {\n        const node = this.head;\n        if (!node)\n          return void 0;\n        this.head = node.next;\n        if (!this.head) {\n          this.tail = void 0;\n        }\n        this._size--;\n        return node.value;\n      }\n      clear() {\n        this.head = this.tail = void 0;\n        this._size = 0;\n      }\n      get size() {\n        return this._size;\n      }\n    };\n    __name(pLimit, \"pLimit\");\n    __name(validateConcurrency, \"validateConcurrency\");\n  }\n});\n\n// ../common/dist/timed-map.js\nvar init_timed_map = __esm({\n  \"../common/dist/timed-map.js\"() {\n    \"use strict\";\n    init_process_shim();\n  }\n});\n\n// ../common/dist/list-buffer.js\nvar init_list_buffer = __esm({\n  \"../common/dist/list-buffer.js\"() {\n    \"use strict\";\n    init_process_shim();\n  }\n});\n\n// ../common/dist/index.js\nvar init_dist = __esm({\n  \"../common/dist/index.js\"() {\n    \"use strict\";\n    init_process_shim();\n    init_omit();\n    init_entries();\n    init_promise();\n    init_p_limit();\n    init_timed_map();\n    init_primitives();\n    init_predicates();\n    init_list_buffer();\n  }\n});\n\n// src/netron/uid.ts\nvar Uid, randomUUID;\nvar init_uid = __esm({\n  \"src/netron/uid.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    Uid = class {\n      static {\n        __name(this, \"Uid\");\n      }\n      id = 0;\n      /**\n       * Get the next sequential ID\n       * @returns The next numeric ID\n       */\n      next() {\n        return ++this.id;\n      }\n      /**\n       * Reset the UID counter to a specific value\n       * @param initialValue - The value to reset to (default: 0)\n       */\n      reset(initialValue = 0) {\n        this.id = initialValue;\n      }\n      /**\n       * Generate a random UUID using browser's native crypto API\n       * @returns A RFC4122 v4 compliant UUID string\n       */\n      static randomUUID() {\n        return crypto.randomUUID();\n      }\n    };\n    randomUUID = /* @__PURE__ */ __name(() => crypto.randomUUID(), \"randomUUID\");\n  }\n});\n\n// src/netron/packet/types.ts\nvar TYPE_STREAM, TYPE_STREAM_ERROR, TYPE_STREAM_CLOSE;\nvar init_types = __esm({\n  \"src/netron/packet/types.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    TYPE_STREAM = 5;\n    TYPE_STREAM_ERROR = 6;\n    TYPE_STREAM_CLOSE = 7;\n  }\n});\n\n// src/netron/packet/packet.ts\nvar getBit, clearBits, writeBits, readBits, IMPULSE_OFFSET, ERROR_OFFSET, TYPE_OFFSET, TYPE_SIZE, EOS_OFFSET, LIVE_OFFSET, uid, Packet;\nvar init_packet = __esm({\n  \"src/netron/packet/packet.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    init_uid();\n    init_types();\n    getBit = /* @__PURE__ */ __name((target, offset) => target >> offset & 1, \"getBit\");\n    clearBits = /* @__PURE__ */ __name((target, offset, count) => {\n      let result = target;\n      for (let i = offset; i < offset + count; ++i) {\n        result &= ~(1 << i);\n      }\n      return result;\n    }, \"clearBits\");\n    writeBits = /* @__PURE__ */ __name((target, val, offset, count) => {\n      let result = target;\n      for (let i = 0; i < count; ++i) {\n        if (val & 1 << i) {\n          result |= 1 << offset + i;\n        }\n      }\n      return result;\n    }, \"writeBits\");\n    readBits = /* @__PURE__ */ __name((target, offset, count) => {\n      let val = 0;\n      for (let i = 0; i < count; ++i) {\n        if (getBit(target, offset + i)) {\n          val |= 1 << i;\n        }\n      }\n      return val;\n    }, \"readBits\");\n    IMPULSE_OFFSET = 6;\n    ERROR_OFFSET = 7;\n    TYPE_OFFSET = 0;\n    TYPE_SIZE = 4;\n    EOS_OFFSET = 4;\n    LIVE_OFFSET = 5;\n    uid = new Uid();\n    Packet = class {\n      /**\n       * Creates a new Packet instance with the specified identifier.\n       * The identifier is used for tracking and correlation of packets in the network.\n       *\n       * @param {number} id - The unique identifier for this packet (uint32)\n       * @throws {Error} If the provided ID is not a valid unsigned 32-bit integer\n       */\n      constructor(id) {\n        this.id = id;\n      }\n      static {\n        __name(this, \"Packet\");\n      }\n      /** Control flags of the packet (uint8) containing various metadata bits */\n      flags = 0;\n      /** The actual payload data of the packet */\n      data;\n      /** Unique identifier for stream packets (uint32) */\n      streamId;\n      /** Chunk number for stream packets (uint32) */\n      streamIndex;\n      /**\n       * Sets the packet type in the control flags while preserving all other flags.\n       * The type field occupies 4 bits (0-3) in the flags byte and determines\n       * the primary purpose of the packet in the protocol.\n       *\n       * @param {PacketType} type - The type to set in the packet flags\n       * @throws {Error} If the type value exceeds the 4-bit range (0-15)\n       */\n      setType(type) {\n        this.flags = writeBits(clearBits(this.flags, TYPE_OFFSET, TYPE_SIZE), type, TYPE_OFFSET, TYPE_SIZE);\n      }\n      /**\n       * Retrieves the packet type from the control flags.\n       * This method extracts the 4-bit type field from the flags byte.\n       *\n       * @returns {PacketType} The type of the packet as specified in the flags\n       */\n      getType() {\n        return readBits(this.flags, TYPE_OFFSET, TYPE_SIZE);\n      }\n      /**\n       * Sets the impulse flag in the control flags.\n       * The impulse flag (bit 6) indicates whether this is a request (1) or response (0) packet.\n       * This flag is crucial for request-response pattern implementation in the protocol.\n       *\n       * @param {PacketImpulse} val - The value to set for the impulse flag (0 or 1)\n       * @throws {Error} If the value is not 0 or 1\n       */\n      setImpulse(val) {\n        this.flags = this.flags & ~(1 << IMPULSE_OFFSET) | val << IMPULSE_OFFSET;\n      }\n      /**\n       * Retrieves the impulse flag from the control flags.\n       *\n       * @returns {PacketImpulse} The value of the impulse flag (0 or 1)\n       */\n      getImpulse() {\n        return getBit(this.flags, IMPULSE_OFFSET);\n      }\n      /**\n       * Sets the error flag in the control flags.\n       * The error flag (bit 7) indicates whether this packet represents an error condition.\n       * When set, the packet's data typically contains error information.\n       *\n       * @param {0 | 1} val - The value to set for the error flag (0 or 1)\n       * @throws {Error} If the value is not 0 or 1\n       */\n      setError(val) {\n        this.flags = this.flags & ~(1 << ERROR_OFFSET) | val << ERROR_OFFSET;\n      }\n      /**\n       * Retrieves the error flag from the control flags.\n       *\n       * @returns {number} The value of the error flag (0 or 1)\n       */\n      getError() {\n        return getBit(this.flags, ERROR_OFFSET);\n      }\n      /**\n       * Sets comprehensive stream information in the packet.\n       * This method updates both the stream metadata fields and the corresponding control flags\n       * for stream-specific attributes (end-of-stream and live stream indicators).\n       *\n       * @param {number} streamId - The unique identifier for the stream (uint32)\n       * @param {number} streamIndex - The sequential position of this chunk in the stream (uint32)\n       * @param {boolean} isLast - Indicates if this is the final chunk in the stream\n       * @param {boolean} isLive - Indicates if this is a live streaming packet\n       * @throws {Error} If streamId or streamIndex are not valid unsigned 32-bit integers\n       */\n      setStreamInfo(streamId, streamIndex, isLast, isLive) {\n        this.streamId = streamId;\n        this.streamIndex = streamIndex;\n        this.flags = writeBits(writeBits(this.flags, isLast ? 1 : 0, EOS_OFFSET, 1), isLive ? 1 : 0, LIVE_OFFSET, 1);\n      }\n      /**\n       * Determines if this packet is part of a stream.\n       * This check is based on the packet type being set to TYPE_STREAM.\n       *\n       * @returns {boolean} True if the packet is a stream chunk, false otherwise\n       */\n      isStreamChunk() {\n        return this.getType() === TYPE_STREAM;\n      }\n      /**\n       * Checks if this packet represents the final chunk of a stream.\n       * This is determined by the end-of-stream flag (bit 4) in the control flags.\n       *\n       * @returns {boolean} True if the packet is the last chunk of a stream, false otherwise\n       */\n      isLastChunk() {\n        return getBit(this.flags, EOS_OFFSET) === 1;\n      }\n      /**\n       * Determines if this packet is part of a live stream.\n       * This is indicated by the live stream flag (bit 5) in the control flags.\n       *\n       * @returns {boolean} True if the stream is live, false otherwise\n       */\n      isLive() {\n        return getBit(this.flags, LIVE_OFFSET) === 1;\n      }\n      /**\n       * Generates a new unique packet identifier using the UID generator.\n       * This method is used to ensure unique packet identification across the network.\n       *\n       * @returns {number} A new unique packet identifier (uint32)\n       */\n      static nextId() {\n        return uid.next();\n      }\n      /**\n       * Resets the packet ID generator to its initial state.\n       * This method should be used with caution as it may cause ID collisions\n       * if packets with old IDs are still in transit.\n       */\n      static resetId() {\n        uid.reset();\n      }\n    };\n  }\n});\n\n// ../../node_modules/semver/internal/constants.js\nvar require_constants = __commonJS({\n  \"../../node_modules/semver/internal/constants.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SEMVER_SPEC_VERSION = \"2.0.0\";\n    var MAX_LENGTH = 256;\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */\n    9007199254740991;\n    var MAX_SAFE_COMPONENT_LENGTH = 16;\n    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;\n    var RELEASE_TYPES = [\n      \"major\",\n      \"premajor\",\n      \"minor\",\n      \"preminor\",\n      \"patch\",\n      \"prepatch\",\n      \"prerelease\"\n    ];\n    module.exports = {\n      MAX_LENGTH,\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_SAFE_INTEGER,\n      RELEASE_TYPES,\n      SEMVER_SPEC_VERSION,\n      FLAG_INCLUDE_PRERELEASE: 1,\n      FLAG_LOOSE: 2\n    };\n  }\n});\n\n// ../../node_modules/semver/internal/debug.js\nvar require_debug = __commonJS({\n  \"../../node_modules/semver/internal/debug.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var debug = typeof process === \"object\" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error(\"SEMVER\", ...args) : () => {\n    };\n    module.exports = debug;\n  }\n});\n\n// ../../node_modules/semver/internal/re.js\nvar require_re = __commonJS({\n  \"../../node_modules/semver/internal/re.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var {\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_LENGTH\n    } = require_constants();\n    var debug = require_debug();\n    exports = module.exports = {};\n    var re = exports.re = [];\n    var safeRe = exports.safeRe = [];\n    var src = exports.src = [];\n    var safeSrc = exports.safeSrc = [];\n    var t = exports.t = {};\n    var R = 0;\n    var LETTERDASHNUMBER = \"[a-zA-Z0-9-]\";\n    var safeRegexReplacements = [\n      [\"\\\\s\", 1],\n      [\"\\\\d\", MAX_LENGTH],\n      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]\n    ];\n    var makeSafeRegex = /* @__PURE__ */ __name((value) => {\n      for (const [token, max] of safeRegexReplacements) {\n        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);\n      }\n      return value;\n    }, \"makeSafeRegex\");\n    var createToken = /* @__PURE__ */ __name((name, value, isGlobal) => {\n      const safe = makeSafeRegex(value);\n      const index = R++;\n      debug(name, index, value);\n      t[name] = index;\n      src[index] = value;\n      safeSrc[index] = safe;\n      re[index] = new RegExp(value, isGlobal ? \"g\" : void 0);\n      safeRe[index] = new RegExp(safe, isGlobal ? \"g\" : void 0);\n    }, \"createToken\");\n    createToken(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\");\n    createToken(\"NUMERICIDENTIFIERLOOSE\", \"\\\\d+\");\n    createToken(\"NONNUMERICIDENTIFIER\", `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);\n    createToken(\"MAINVERSION\", `(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})`);\n    createToken(\"MAINVERSIONLOOSE\", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n    createToken(\"PRERELEASEIDENTIFIER\", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);\n    createToken(\"PRERELEASEIDENTIFIERLOOSE\", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);\n    createToken(\"PRERELEASE\", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n    createToken(\"PRERELEASELOOSE\", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n    createToken(\"BUILDIDENTIFIER\", `${LETTERDASHNUMBER}+`);\n    createToken(\"BUILD\", `(?:\\\\+(${src[t.BUILDIDENTIFIER]}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n    createToken(\"FULLPLAIN\", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);\n    createToken(\"FULL\", `^${src[t.FULLPLAIN]}$`);\n    createToken(\"LOOSEPLAIN\", `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);\n    createToken(\"LOOSE\", `^${src[t.LOOSEPLAIN]}$`);\n    createToken(\"GTLT\", \"((?:<|>)?=?)\");\n    createToken(\"XRANGEIDENTIFIERLOOSE\", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n    createToken(\"XRANGEIDENTIFIER\", `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n    createToken(\"XRANGEPLAIN\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGEPLAINLOOSE\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n    createToken(\"XRANGELOOSE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COERCEPLAIN\", `${\"(^|[^\\\\d])(\\\\d{1,\"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);\n    createToken(\"COERCE\", `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`);\n    createToken(\"COERCEFULL\", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\\\d])`);\n    createToken(\"COERCERTL\", src[t.COERCE], true);\n    createToken(\"COERCERTLFULL\", src[t.COERCEFULL], true);\n    createToken(\"LONETILDE\", \"(?:~>?)\");\n    createToken(\"TILDETRIM\", `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n    exports.tildeTrimReplace = \"$1~\";\n    createToken(\"TILDE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"TILDELOOSE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"LONECARET\", \"(?:\\\\^)\");\n    createToken(\"CARETTRIM\", `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n    exports.caretTrimReplace = \"$1^\";\n    createToken(\"CARET\", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"CARETLOOSE\", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COMPARATORLOOSE\", `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n    createToken(\"COMPARATOR\", `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n    createToken(\"COMPARATORTRIM\", `(\\\\s*)${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n    exports.comparatorTrimReplace = \"$1$2$3\";\n    createToken(\"HYPHENRANGE\", `^\\\\s*(${src[t.XRANGEPLAIN]})\\\\s+-\\\\s+(${src[t.XRANGEPLAIN]})\\\\s*$`);\n    createToken(\"HYPHENRANGELOOSE\", `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${src[t.XRANGEPLAINLOOSE]})\\\\s*$`);\n    createToken(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\");\n    createToken(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\");\n    createToken(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n  }\n});\n\n// ../../node_modules/semver/internal/parse-options.js\nvar require_parse_options = __commonJS({\n  \"../../node_modules/semver/internal/parse-options.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var looseOption = Object.freeze({ loose: true });\n    var emptyOpts = Object.freeze({});\n    var parseOptions = /* @__PURE__ */ __name((options) => {\n      if (!options) {\n        return emptyOpts;\n      }\n      if (typeof options !== \"object\") {\n        return looseOption;\n      }\n      return options;\n    }, \"parseOptions\");\n    module.exports = parseOptions;\n  }\n});\n\n// ../../node_modules/semver/internal/identifiers.js\nvar require_identifiers = __commonJS({\n  \"../../node_modules/semver/internal/identifiers.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var numeric = /^[0-9]+$/;\n    var compareIdentifiers = /* @__PURE__ */ __name((a, b) => {\n      const anum = numeric.test(a);\n      const bnum = numeric.test(b);\n      if (anum && bnum) {\n        a = +a;\n        b = +b;\n      }\n      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n    }, \"compareIdentifiers\");\n    var rcompareIdentifiers = /* @__PURE__ */ __name((a, b) => compareIdentifiers(b, a), \"rcompareIdentifiers\");\n    module.exports = {\n      compareIdentifiers,\n      rcompareIdentifiers\n    };\n  }\n});\n\n// ../../node_modules/semver/classes/semver.js\nvar require_semver = __commonJS({\n  \"../../node_modules/semver/classes/semver.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var debug = require_debug();\n    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();\n    var { safeRe: re, t } = require_re();\n    var parseOptions = require_parse_options();\n    var { compareIdentifiers } = require_identifiers();\n    var SemVer = class _SemVer {\n      static {\n        __name(this, \"SemVer\");\n      }\n      constructor(version, options) {\n        options = parseOptions(options);\n        if (version instanceof _SemVer) {\n          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {\n            return version;\n          } else {\n            version = version.version;\n          }\n        } else if (typeof version !== \"string\") {\n          throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`);\n        }\n        if (version.length > MAX_LENGTH) {\n          throw new TypeError(\n            `version is longer than ${MAX_LENGTH} characters`\n          );\n        }\n        debug(\"SemVer\", version, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease;\n        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n        if (!m) {\n          throw new TypeError(`Invalid Version: ${version}`);\n        }\n        this.raw = version;\n        this.major = +m[1];\n        this.minor = +m[2];\n        this.patch = +m[3];\n        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n          throw new TypeError(\"Invalid major version\");\n        }\n        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n          throw new TypeError(\"Invalid minor version\");\n        }\n        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n          throw new TypeError(\"Invalid patch version\");\n        }\n        if (!m[4]) {\n          this.prerelease = [];\n        } else {\n          this.prerelease = m[4].split(\".\").map((id) => {\n            if (/^[0-9]+$/.test(id)) {\n              const num = +id;\n              if (num >= 0 && num < MAX_SAFE_INTEGER) {\n                return num;\n              }\n            }\n            return id;\n          });\n        }\n        this.build = m[5] ? m[5].split(\".\") : [];\n        this.format();\n      }\n      format() {\n        this.version = `${this.major}.${this.minor}.${this.patch}`;\n        if (this.prerelease.length) {\n          this.version += `-${this.prerelease.join(\".\")}`;\n        }\n        return this.version;\n      }\n      toString() {\n        return this.version;\n      }\n      compare(other) {\n        debug(\"SemVer.compare\", this.version, this.options, other);\n        if (!(other instanceof _SemVer)) {\n          if (typeof other === \"string\" && other === this.version) {\n            return 0;\n          }\n          other = new _SemVer(other, this.options);\n        }\n        if (other.version === this.version) {\n          return 0;\n        }\n        return this.compareMain(other) || this.comparePre(other);\n      }\n      compareMain(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n      }\n      comparePre(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        if (this.prerelease.length && !other.prerelease.length) {\n          return -1;\n        } else if (!this.prerelease.length && other.prerelease.length) {\n          return 1;\n        } else if (!this.prerelease.length && !other.prerelease.length) {\n          return 0;\n        }\n        let i = 0;\n        do {\n          const a = this.prerelease[i];\n          const b = other.prerelease[i];\n          debug(\"prerelease compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      compareBuild(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        let i = 0;\n        do {\n          const a = this.build[i];\n          const b = other.build[i];\n          debug(\"build compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      // preminor will bump the version up to the next minor release, and immediately\n      // down to pre-release. premajor and prepatch work the same way.\n      inc(release, identifier, identifierBase) {\n        if (release.startsWith(\"pre\")) {\n          if (!identifier && identifierBase === false) {\n            throw new Error(\"invalid increment argument: identifier is empty\");\n          }\n          if (identifier) {\n            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);\n            if (!match || match[1] !== identifier) {\n              throw new Error(`invalid identifier: ${identifier}`);\n            }\n          }\n        }\n        switch (release) {\n          case \"premajor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor = 0;\n            this.major++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"preminor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"prepatch\":\n            this.prerelease.length = 0;\n            this.inc(\"patch\", identifier, identifierBase);\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          // If the input is a non-prerelease version, this acts the same as\n          // prepatch.\n          case \"prerelease\":\n            if (this.prerelease.length === 0) {\n              this.inc(\"patch\", identifier, identifierBase);\n            }\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"release\":\n            if (this.prerelease.length === 0) {\n              throw new Error(`version ${this.raw} is not a prerelease`);\n            }\n            this.prerelease.length = 0;\n            break;\n          case \"major\":\n            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n              this.major++;\n            }\n            this.minor = 0;\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"minor\":\n            if (this.patch !== 0 || this.prerelease.length === 0) {\n              this.minor++;\n            }\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"patch\":\n            if (this.prerelease.length === 0) {\n              this.patch++;\n            }\n            this.prerelease = [];\n            break;\n          // This probably shouldn't be used publicly.\n          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n          case \"pre\": {\n            const base = Number(identifierBase) ? 1 : 0;\n            if (this.prerelease.length === 0) {\n              this.prerelease = [base];\n            } else {\n              let i = this.prerelease.length;\n              while (--i >= 0) {\n                if (typeof this.prerelease[i] === \"number\") {\n                  this.prerelease[i]++;\n                  i = -2;\n                }\n              }\n              if (i === -1) {\n                if (identifier === this.prerelease.join(\".\") && identifierBase === false) {\n                  throw new Error(\"invalid increment argument: identifier already exists\");\n                }\n                this.prerelease.push(base);\n              }\n            }\n            if (identifier) {\n              let prerelease = [identifier, base];\n              if (identifierBase === false) {\n                prerelease = [identifier];\n              }\n              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n                if (isNaN(this.prerelease[1])) {\n                  this.prerelease = prerelease;\n                }\n              } else {\n                this.prerelease = prerelease;\n              }\n            }\n            break;\n          }\n          default:\n            throw new Error(`invalid increment argument: ${release}`);\n        }\n        this.raw = this.format();\n        if (this.build.length) {\n          this.raw += `+${this.build.join(\".\")}`;\n        }\n        return this;\n      }\n    };\n    module.exports = SemVer;\n  }\n});\n\n// ../../node_modules/semver/functions/parse.js\nvar require_parse = __commonJS({\n  \"../../node_modules/semver/functions/parse.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var parse = /* @__PURE__ */ __name((version, options, throwErrors = false) => {\n      if (version instanceof SemVer) {\n        return version;\n      }\n      try {\n        return new SemVer(version, options);\n      } catch (er) {\n        if (!throwErrors) {\n          return null;\n        }\n        throw er;\n      }\n    }, \"parse\");\n    module.exports = parse;\n  }\n});\n\n// ../../node_modules/semver/functions/valid.js\nvar require_valid = __commonJS({\n  \"../../node_modules/semver/functions/valid.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var parse = require_parse();\n    var valid = /* @__PURE__ */ __name((version, options) => {\n      const v = parse(version, options);\n      return v ? v.version : null;\n    }, \"valid\");\n    module.exports = valid;\n  }\n});\n\n// ../../node_modules/semver/functions/clean.js\nvar require_clean = __commonJS({\n  \"../../node_modules/semver/functions/clean.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var parse = require_parse();\n    var clean = /* @__PURE__ */ __name((version, options) => {\n      const s = parse(version.trim().replace(/^[=v]+/, \"\"), options);\n      return s ? s.version : null;\n    }, \"clean\");\n    module.exports = clean;\n  }\n});\n\n// ../../node_modules/semver/functions/inc.js\nvar require_inc = __commonJS({\n  \"../../node_modules/semver/functions/inc.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var inc = /* @__PURE__ */ __name((version, release, options, identifier, identifierBase) => {\n      if (typeof options === \"string\") {\n        identifierBase = identifier;\n        identifier = options;\n        options = void 0;\n      }\n      try {\n        return new SemVer(\n          version instanceof SemVer ? version.version : version,\n          options\n        ).inc(release, identifier, identifierBase).version;\n      } catch (er) {\n        return null;\n      }\n    }, \"inc\");\n    module.exports = inc;\n  }\n});\n\n// ../../node_modules/semver/functions/diff.js\nvar require_diff = __commonJS({\n  \"../../node_modules/semver/functions/diff.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var parse = require_parse();\n    var diff = /* @__PURE__ */ __name((version1, version2) => {\n      const v1 = parse(version1, null, true);\n      const v2 = parse(version2, null, true);\n      const comparison = v1.compare(v2);\n      if (comparison === 0) {\n        return null;\n      }\n      const v1Higher = comparison > 0;\n      const highVersion = v1Higher ? v1 : v2;\n      const lowVersion = v1Higher ? v2 : v1;\n      const highHasPre = !!highVersion.prerelease.length;\n      const lowHasPre = !!lowVersion.prerelease.length;\n      if (lowHasPre && !highHasPre) {\n        if (!lowVersion.patch && !lowVersion.minor) {\n          return \"major\";\n        }\n        if (lowVersion.compareMain(highVersion) === 0) {\n          if (lowVersion.minor && !lowVersion.patch) {\n            return \"minor\";\n          }\n          return \"patch\";\n        }\n      }\n      const prefix = highHasPre ? \"pre\" : \"\";\n      if (v1.major !== v2.major) {\n        return prefix + \"major\";\n      }\n      if (v1.minor !== v2.minor) {\n        return prefix + \"minor\";\n      }\n      if (v1.patch !== v2.patch) {\n        return prefix + \"patch\";\n      }\n      return \"prerelease\";\n    }, \"diff\");\n    module.exports = diff;\n  }\n});\n\n// ../../node_modules/semver/functions/major.js\nvar require_major = __commonJS({\n  \"../../node_modules/semver/functions/major.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var major = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).major, \"major\");\n    module.exports = major;\n  }\n});\n\n// ../../node_modules/semver/functions/minor.js\nvar require_minor = __commonJS({\n  \"../../node_modules/semver/functions/minor.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var minor = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).minor, \"minor\");\n    module.exports = minor;\n  }\n});\n\n// ../../node_modules/semver/functions/patch.js\nvar require_patch = __commonJS({\n  \"../../node_modules/semver/functions/patch.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var patch = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).patch, \"patch\");\n    module.exports = patch;\n  }\n});\n\n// ../../node_modules/semver/functions/prerelease.js\nvar require_prerelease = __commonJS({\n  \"../../node_modules/semver/functions/prerelease.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var parse = require_parse();\n    var prerelease = /* @__PURE__ */ __name((version, options) => {\n      const parsed = parse(version, options);\n      return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n    }, \"prerelease\");\n    module.exports = prerelease;\n  }\n});\n\n// ../../node_modules/semver/functions/compare.js\nvar require_compare = __commonJS({\n  \"../../node_modules/semver/functions/compare.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var compare2 = /* @__PURE__ */ __name((a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose)), \"compare\");\n    module.exports = compare2;\n  }\n});\n\n// ../../node_modules/semver/functions/rcompare.js\nvar require_rcompare = __commonJS({\n  \"../../node_modules/semver/functions/rcompare.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compare2 = require_compare();\n    var rcompare = /* @__PURE__ */ __name((a, b, loose) => compare2(b, a, loose), \"rcompare\");\n    module.exports = rcompare;\n  }\n});\n\n// ../../node_modules/semver/functions/compare-loose.js\nvar require_compare_loose = __commonJS({\n  \"../../node_modules/semver/functions/compare-loose.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compare2 = require_compare();\n    var compareLoose = /* @__PURE__ */ __name((a, b) => compare2(a, b, true), \"compareLoose\");\n    module.exports = compareLoose;\n  }\n});\n\n// ../../node_modules/semver/functions/compare-build.js\nvar require_compare_build = __commonJS({\n  \"../../node_modules/semver/functions/compare-build.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var compareBuild = /* @__PURE__ */ __name((a, b, loose) => {\n      const versionA = new SemVer(a, loose);\n      const versionB = new SemVer(b, loose);\n      return versionA.compare(versionB) || versionA.compareBuild(versionB);\n    }, \"compareBuild\");\n    module.exports = compareBuild;\n  }\n});\n\n// ../../node_modules/semver/functions/sort.js\nvar require_sort = __commonJS({\n  \"../../node_modules/semver/functions/sort.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compareBuild = require_compare_build();\n    var sort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b) => compareBuild(a, b, loose)), \"sort\");\n    module.exports = sort;\n  }\n});\n\n// ../../node_modules/semver/functions/rsort.js\nvar require_rsort = __commonJS({\n  \"../../node_modules/semver/functions/rsort.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compareBuild = require_compare_build();\n    var rsort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b) => compareBuild(b, a, loose)), \"rsort\");\n    module.exports = rsort;\n  }\n});\n\n// ../../node_modules/semver/functions/gt.js\nvar require_gt = __commonJS({\n  \"../../node_modules/semver/functions/gt.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compare2 = require_compare();\n    var gt = /* @__PURE__ */ __name((a, b, loose) => compare2(a, b, loose) > 0, \"gt\");\n    module.exports = gt;\n  }\n});\n\n// ../../node_modules/semver/functions/lt.js\nvar require_lt = __commonJS({\n  \"../../node_modules/semver/functions/lt.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compare2 = require_compare();\n    var lt = /* @__PURE__ */ __name((a, b, loose) => compare2(a, b, loose) < 0, \"lt\");\n    module.exports = lt;\n  }\n});\n\n// ../../node_modules/semver/functions/eq.js\nvar require_eq = __commonJS({\n  \"../../node_modules/semver/functions/eq.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compare2 = require_compare();\n    var eq = /* @__PURE__ */ __name((a, b, loose) => compare2(a, b, loose) === 0, \"eq\");\n    module.exports = eq;\n  }\n});\n\n// ../../node_modules/semver/functions/neq.js\nvar require_neq = __commonJS({\n  \"../../node_modules/semver/functions/neq.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compare2 = require_compare();\n    var neq = /* @__PURE__ */ __name((a, b, loose) => compare2(a, b, loose) !== 0, \"neq\");\n    module.exports = neq;\n  }\n});\n\n// ../../node_modules/semver/functions/gte.js\nvar require_gte = __commonJS({\n  \"../../node_modules/semver/functions/gte.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compare2 = require_compare();\n    var gte = /* @__PURE__ */ __name((a, b, loose) => compare2(a, b, loose) >= 0, \"gte\");\n    module.exports = gte;\n  }\n});\n\n// ../../node_modules/semver/functions/lte.js\nvar require_lte = __commonJS({\n  \"../../node_modules/semver/functions/lte.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var compare2 = require_compare();\n    var lte = /* @__PURE__ */ __name((a, b, loose) => compare2(a, b, loose) <= 0, \"lte\");\n    module.exports = lte;\n  }\n});\n\n// ../../node_modules/semver/functions/cmp.js\nvar require_cmp = __commonJS({\n  \"../../node_modules/semver/functions/cmp.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var eq = require_eq();\n    var neq = require_neq();\n    var gt = require_gt();\n    var gte = require_gte();\n    var lt = require_lt();\n    var lte = require_lte();\n    var cmp = /* @__PURE__ */ __name((a, op, b, loose) => {\n      switch (op) {\n        case \"===\":\n          if (typeof a === \"object\") {\n            a = a.version;\n          }\n          if (typeof b === \"object\") {\n            b = b.version;\n          }\n          return a === b;\n        case \"!==\":\n          if (typeof a === \"object\") {\n            a = a.version;\n          }\n          if (typeof b === \"object\") {\n            b = b.version;\n          }\n          return a !== b;\n        case \"\":\n        case \"=\":\n        case \"==\":\n          return eq(a, b, loose);\n        case \"!=\":\n          return neq(a, b, loose);\n        case \">\":\n          return gt(a, b, loose);\n        case \">=\":\n          return gte(a, b, loose);\n        case \"<\":\n          return lt(a, b, loose);\n        case \"<=\":\n          return lte(a, b, loose);\n        default:\n          throw new TypeError(`Invalid operator: ${op}`);\n      }\n    }, \"cmp\");\n    module.exports = cmp;\n  }\n});\n\n// ../../node_modules/semver/functions/coerce.js\nvar require_coerce = __commonJS({\n  \"../../node_modules/semver/functions/coerce.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var parse = require_parse();\n    var { safeRe: re, t } = require_re();\n    var coerce = /* @__PURE__ */ __name((version, options) => {\n      if (version instanceof SemVer) {\n        return version;\n      }\n      if (typeof version === \"number\") {\n        version = String(version);\n      }\n      if (typeof version !== \"string\") {\n        return null;\n      }\n      options = options || {};\n      let match = null;\n      if (!options.rtl) {\n        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);\n      } else {\n        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];\n        let next;\n        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n          if (!match || next.index + next[0].length !== match.index + match[0].length) {\n            match = next;\n          }\n          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;\n        }\n        coerceRtlRegex.lastIndex = -1;\n      }\n      if (match === null) {\n        return null;\n      }\n      const major = match[2];\n      const minor = match[3] || \"0\";\n      const patch = match[4] || \"0\";\n      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : \"\";\n      const build = options.includePrerelease && match[6] ? `+${match[6]}` : \"\";\n      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);\n    }, \"coerce\");\n    module.exports = coerce;\n  }\n});\n\n// ../../node_modules/semver/internal/lrucache.js\nvar require_lrucache = __commonJS({\n  \"../../node_modules/semver/internal/lrucache.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var LRUCache = class {\n      static {\n        __name(this, \"LRUCache\");\n      }\n      constructor() {\n        this.max = 1e3;\n        this.map = /* @__PURE__ */ new Map();\n      }\n      get(key) {\n        const value = this.map.get(key);\n        if (value === void 0) {\n          return void 0;\n        } else {\n          this.map.delete(key);\n          this.map.set(key, value);\n          return value;\n        }\n      }\n      delete(key) {\n        return this.map.delete(key);\n      }\n      set(key, value) {\n        const deleted = this.delete(key);\n        if (!deleted && value !== void 0) {\n          if (this.map.size >= this.max) {\n            const firstKey = this.map.keys().next().value;\n            this.delete(firstKey);\n          }\n          this.map.set(key, value);\n        }\n        return this;\n      }\n    };\n    module.exports = LRUCache;\n  }\n});\n\n// ../../node_modules/semver/classes/range.js\nvar require_range = __commonJS({\n  \"../../node_modules/semver/classes/range.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SPACE_CHARACTERS = /\\s+/g;\n    var Range = class _Range {\n      static {\n        __name(this, \"Range\");\n      }\n      constructor(range, options) {\n        options = parseOptions(options);\n        if (range instanceof _Range) {\n          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n            return range;\n          } else {\n            return new _Range(range.raw, options);\n          }\n        }\n        if (range instanceof Comparator) {\n          this.raw = range.value;\n          this.set = [[range]];\n          this.formatted = void 0;\n          return this;\n        }\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease;\n        this.raw = range.trim().replace(SPACE_CHARACTERS, \" \");\n        this.set = this.raw.split(\"||\").map((r) => this.parseRange(r.trim())).filter((c) => c.length);\n        if (!this.set.length) {\n          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);\n        }\n        if (this.set.length > 1) {\n          const first = this.set[0];\n          this.set = this.set.filter((c) => !isNullSet(c[0]));\n          if (this.set.length === 0) {\n            this.set = [first];\n          } else if (this.set.length > 1) {\n            for (const c of this.set) {\n              if (c.length === 1 && isAny(c[0])) {\n                this.set = [c];\n                break;\n              }\n            }\n          }\n        }\n        this.formatted = void 0;\n      }\n      get range() {\n        if (this.formatted === void 0) {\n          this.formatted = \"\";\n          for (let i = 0; i < this.set.length; i++) {\n            if (i > 0) {\n              this.formatted += \"||\";\n            }\n            const comps = this.set[i];\n            for (let k = 0; k < comps.length; k++) {\n              if (k > 0) {\n                this.formatted += \" \";\n              }\n              this.formatted += comps[k].toString().trim();\n            }\n          }\n        }\n        return this.formatted;\n      }\n      format() {\n        return this.range;\n      }\n      toString() {\n        return this.range;\n      }\n      parseRange(range) {\n        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);\n        const memoKey = memoOpts + \":\" + range;\n        const cached = cache.get(memoKey);\n        if (cached) {\n          return cached;\n        }\n        const loose = this.options.loose;\n        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];\n        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));\n        debug(\"hyphen replace\", range);\n        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);\n        debug(\"comparator trim\", range);\n        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);\n        debug(\"tilde trim\", range);\n        range = range.replace(re[t.CARETTRIM], caretTrimReplace);\n        debug(\"caret trim\", range);\n        let rangeList = range.split(\" \").map((comp) => parseComparator(comp, this.options)).join(\" \").split(/\\s+/).map((comp) => replaceGTE0(comp, this.options));\n        if (loose) {\n          rangeList = rangeList.filter((comp) => {\n            debug(\"loose invalid filter\", comp, this.options);\n            return !!comp.match(re[t.COMPARATORLOOSE]);\n          });\n        }\n        debug(\"range list\", rangeList);\n        const rangeMap = /* @__PURE__ */ new Map();\n        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));\n        for (const comp of comparators) {\n          if (isNullSet(comp)) {\n            return [comp];\n          }\n          rangeMap.set(comp.value, comp);\n        }\n        if (rangeMap.size > 1 && rangeMap.has(\"\")) {\n          rangeMap.delete(\"\");\n        }\n        const result = [...rangeMap.values()];\n        cache.set(memoKey, result);\n        return result;\n      }\n      intersects(range, options) {\n        if (!(range instanceof _Range)) {\n          throw new TypeError(\"a Range is required\");\n        }\n        return this.set.some((thisComparators) => {\n          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {\n            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options);\n              });\n            });\n          });\n        });\n      }\n      // if ANY of the sets match ALL of its comparators, then pass\n      test(version) {\n        if (!version) {\n          return false;\n        }\n        if (typeof version === \"string\") {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n        for (let i = 0; i < this.set.length; i++) {\n          if (testSet(this.set[i], version, this.options)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n    module.exports = Range;\n    var LRU = require_lrucache();\n    var cache = new LRU();\n    var parseOptions = require_parse_options();\n    var Comparator = require_comparator();\n    var debug = require_debug();\n    var SemVer = require_semver();\n    var {\n      safeRe: re,\n      t,\n      comparatorTrimReplace,\n      tildeTrimReplace,\n      caretTrimReplace\n    } = require_re();\n    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();\n    var isNullSet = /* @__PURE__ */ __name((c) => c.value === \"<0.0.0-0\", \"isNullSet\");\n    var isAny = /* @__PURE__ */ __name((c) => c.value === \"\", \"isAny\");\n    var isSatisfiable = /* @__PURE__ */ __name((comparators, options) => {\n      let result = true;\n      const remainingComparators = comparators.slice();\n      let testComparator = remainingComparators.pop();\n      while (result && remainingComparators.length) {\n        result = remainingComparators.every((otherComparator) => {\n          return testComparator.intersects(otherComparator, options);\n        });\n        testComparator = remainingComparators.pop();\n      }\n      return result;\n    }, \"isSatisfiable\");\n    var parseComparator = /* @__PURE__ */ __name((comp, options) => {\n      debug(\"comp\", comp, options);\n      comp = replaceCarets(comp, options);\n      debug(\"caret\", comp);\n      comp = replaceTildes(comp, options);\n      debug(\"tildes\", comp);\n      comp = replaceXRanges(comp, options);\n      debug(\"xrange\", comp);\n      comp = replaceStars(comp, options);\n      debug(\"stars\", comp);\n      return comp;\n    }, \"parseComparator\");\n    var isX = /* @__PURE__ */ __name((id) => !id || id.toLowerCase() === \"x\" || id === \"*\", \"isX\");\n    var replaceTildes = /* @__PURE__ */ __name((comp, options) => {\n      return comp.trim().split(/\\s+/).map((c) => replaceTilde(c, options)).join(\" \");\n    }, \"replaceTildes\");\n    var replaceTilde = /* @__PURE__ */ __name((comp, options) => {\n      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];\n      return comp.replace(r, (_, M, m, p, pr) => {\n        debug(\"tilde\", comp, _, M, m, p, pr);\n        let ret;\n        if (isX(M)) {\n          ret = \"\";\n        } else if (isX(m)) {\n          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;\n        } else if (isX(p)) {\n          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;\n        } else if (pr) {\n          debug(\"replaceTilde pr\", pr);\n          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n        } else {\n          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;\n        }\n        debug(\"tilde return\", ret);\n        return ret;\n      });\n    }, \"replaceTilde\");\n    var replaceCarets = /* @__PURE__ */ __name((comp, options) => {\n      return comp.trim().split(/\\s+/).map((c) => replaceCaret(c, options)).join(\" \");\n    }, \"replaceCarets\");\n    var replaceCaret = /* @__PURE__ */ __name((comp, options) => {\n      debug(\"caret\", comp, options);\n      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];\n      const z = options.includePrerelease ? \"-0\" : \"\";\n      return comp.replace(r, (_, M, m, p, pr) => {\n        debug(\"caret\", comp, _, M, m, p, pr);\n        let ret;\n        if (isX(M)) {\n          ret = \"\";\n        } else if (isX(m)) {\n          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;\n        } else if (isX(p)) {\n          if (M === \"0\") {\n            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;\n          } else {\n            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;\n          }\n        } else if (pr) {\n          debug(\"replaceCaret pr\", pr);\n          if (M === \"0\") {\n            if (m === \"0\") {\n              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;\n            } else {\n              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n            }\n          } else {\n            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;\n          }\n        } else {\n          debug(\"no pr\");\n          if (M === \"0\") {\n            if (m === \"0\") {\n              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;\n            } else {\n              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;\n            }\n          } else {\n            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;\n          }\n        }\n        debug(\"caret return\", ret);\n        return ret;\n      });\n    }, \"replaceCaret\");\n    var replaceXRanges = /* @__PURE__ */ __name((comp, options) => {\n      debug(\"replaceXRanges\", comp, options);\n      return comp.split(/\\s+/).map((c) => replaceXRange(c, options)).join(\" \");\n    }, \"replaceXRanges\");\n    var replaceXRange = /* @__PURE__ */ __name((comp, options) => {\n      comp = comp.trim();\n      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];\n      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n        debug(\"xRange\", comp, ret, gtlt, M, m, p, pr);\n        const xM = isX(M);\n        const xm = xM || isX(m);\n        const xp = xm || isX(p);\n        const anyX = xp;\n        if (gtlt === \"=\" && anyX) {\n          gtlt = \"\";\n        }\n        pr = options.includePrerelease ? \"-0\" : \"\";\n        if (xM) {\n          if (gtlt === \">\" || gtlt === \"<\") {\n            ret = \"<0.0.0-0\";\n          } else {\n            ret = \"*\";\n          }\n        } else if (gtlt && anyX) {\n          if (xm) {\n            m = 0;\n          }\n          p = 0;\n          if (gtlt === \">\") {\n            gtlt = \">=\";\n            if (xm) {\n              M = +M + 1;\n              m = 0;\n              p = 0;\n            } else {\n              m = +m + 1;\n              p = 0;\n            }\n          } else if (gtlt === \"<=\") {\n            gtlt = \"<\";\n            if (xm) {\n              M = +M + 1;\n            } else {\n              m = +m + 1;\n            }\n          }\n          if (gtlt === \"<\") {\n            pr = \"-0\";\n          }\n          ret = `${gtlt + M}.${m}.${p}${pr}`;\n        } else if (xm) {\n          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;\n        } else if (xp) {\n          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;\n        }\n        debug(\"xRange return\", ret);\n        return ret;\n      });\n    }, \"replaceXRange\");\n    var replaceStars = /* @__PURE__ */ __name((comp, options) => {\n      debug(\"replaceStars\", comp, options);\n      return comp.trim().replace(re[t.STAR], \"\");\n    }, \"replaceStars\");\n    var replaceGTE0 = /* @__PURE__ */ __name((comp, options) => {\n      debug(\"replaceGTE0\", comp, options);\n      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], \"\");\n    }, \"replaceGTE0\");\n    var hyphenReplace = /* @__PURE__ */ __name((incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {\n      if (isX(fM)) {\n        from = \"\";\n      } else if (isX(fm)) {\n        from = `>=${fM}.0.0${incPr ? \"-0\" : \"\"}`;\n      } else if (isX(fp)) {\n        from = `>=${fM}.${fm}.0${incPr ? \"-0\" : \"\"}`;\n      } else if (fpr) {\n        from = `>=${from}`;\n      } else {\n        from = `>=${from}${incPr ? \"-0\" : \"\"}`;\n      }\n      if (isX(tM)) {\n        to = \"\";\n      } else if (isX(tm)) {\n        to = `<${+tM + 1}.0.0-0`;\n      } else if (isX(tp)) {\n        to = `<${tM}.${+tm + 1}.0-0`;\n      } else if (tpr) {\n        to = `<=${tM}.${tm}.${tp}-${tpr}`;\n      } else if (incPr) {\n        to = `<${tM}.${tm}.${+tp + 1}-0`;\n      } else {\n        to = `<=${to}`;\n      }\n      return `${from} ${to}`.trim();\n    }, \"hyphenReplace\");\n    var testSet = /* @__PURE__ */ __name((set, version, options) => {\n      for (let i = 0; i < set.length; i++) {\n        if (!set[i].test(version)) {\n          return false;\n        }\n      }\n      if (version.prerelease.length && !options.includePrerelease) {\n        for (let i = 0; i < set.length; i++) {\n          debug(set[i].semver);\n          if (set[i].semver === Comparator.ANY) {\n            continue;\n          }\n          if (set[i].semver.prerelease.length > 0) {\n            const allowed = set[i].semver;\n            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      return true;\n    }, \"testSet\");\n  }\n});\n\n// ../../node_modules/semver/classes/comparator.js\nvar require_comparator = __commonJS({\n  \"../../node_modules/semver/classes/comparator.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var ANY = Symbol(\"SemVer ANY\");\n    var Comparator = class _Comparator {\n      static {\n        __name(this, \"Comparator\");\n      }\n      static get ANY() {\n        return ANY;\n      }\n      constructor(comp, options) {\n        options = parseOptions(options);\n        if (comp instanceof _Comparator) {\n          if (comp.loose === !!options.loose) {\n            return comp;\n          } else {\n            comp = comp.value;\n          }\n        }\n        comp = comp.trim().split(/\\s+/).join(\" \");\n        debug(\"comparator\", comp, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.parse(comp);\n        if (this.semver === ANY) {\n          this.value = \"\";\n        } else {\n          this.value = this.operator + this.semver.version;\n        }\n        debug(\"comp\", this);\n      }\n      parse(comp) {\n        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n        const m = comp.match(r);\n        if (!m) {\n          throw new TypeError(`Invalid comparator: ${comp}`);\n        }\n        this.operator = m[1] !== void 0 ? m[1] : \"\";\n        if (this.operator === \"=\") {\n          this.operator = \"\";\n        }\n        if (!m[2]) {\n          this.semver = ANY;\n        } else {\n          this.semver = new SemVer(m[2], this.options.loose);\n        }\n      }\n      toString() {\n        return this.value;\n      }\n      test(version) {\n        debug(\"Comparator.test\", version, this.options.loose);\n        if (this.semver === ANY || version === ANY) {\n          return true;\n        }\n        if (typeof version === \"string\") {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n        return cmp(version, this.operator, this.semver, this.options);\n      }\n      intersects(comp, options) {\n        if (!(comp instanceof _Comparator)) {\n          throw new TypeError(\"a Comparator is required\");\n        }\n        if (this.operator === \"\") {\n          if (this.value === \"\") {\n            return true;\n          }\n          return new Range(comp.value, options).test(this.value);\n        } else if (comp.operator === \"\") {\n          if (comp.value === \"\") {\n            return true;\n          }\n          return new Range(this.value, options).test(comp.semver);\n        }\n        options = parseOptions(options);\n        if (options.includePrerelease && (this.value === \"<0.0.0-0\" || comp.value === \"<0.0.0-0\")) {\n          return false;\n        }\n        if (!options.includePrerelease && (this.value.startsWith(\"<0.0.0\") || comp.value.startsWith(\"<0.0.0\"))) {\n          return false;\n        }\n        if (this.operator.startsWith(\">\") && comp.operator.startsWith(\">\")) {\n          return true;\n        }\n        if (this.operator.startsWith(\"<\") && comp.operator.startsWith(\"<\")) {\n          return true;\n        }\n        if (this.semver.version === comp.semver.version && this.operator.includes(\"=\") && comp.operator.includes(\"=\")) {\n          return true;\n        }\n        if (cmp(this.semver, \"<\", comp.semver, options) && this.operator.startsWith(\">\") && comp.operator.startsWith(\"<\")) {\n          return true;\n        }\n        if (cmp(this.semver, \">\", comp.semver, options) && this.operator.startsWith(\"<\") && comp.operator.startsWith(\">\")) {\n          return true;\n        }\n        return false;\n      }\n    };\n    module.exports = Comparator;\n    var parseOptions = require_parse_options();\n    var { safeRe: re, t } = require_re();\n    var cmp = require_cmp();\n    var debug = require_debug();\n    var SemVer = require_semver();\n    var Range = require_range();\n  }\n});\n\n// ../../node_modules/semver/functions/satisfies.js\nvar require_satisfies = __commonJS({\n  \"../../node_modules/semver/functions/satisfies.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var Range = require_range();\n    var satisfies = /* @__PURE__ */ __name((version, range, options) => {\n      try {\n        range = new Range(range, options);\n      } catch (er) {\n        return false;\n      }\n      return range.test(version);\n    }, \"satisfies\");\n    module.exports = satisfies;\n  }\n});\n\n// ../../node_modules/semver/ranges/to-comparators.js\nvar require_to_comparators = __commonJS({\n  \"../../node_modules/semver/ranges/to-comparators.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var Range = require_range();\n    var toComparators = /* @__PURE__ */ __name((range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(\" \").trim().split(\" \")), \"toComparators\");\n    module.exports = toComparators;\n  }\n});\n\n// ../../node_modules/semver/ranges/max-satisfying.js\nvar require_max_satisfying = __commonJS({\n  \"../../node_modules/semver/ranges/max-satisfying.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var Range = require_range();\n    var maxSatisfying = /* @__PURE__ */ __name((versions, range, options) => {\n      let max = null;\n      let maxSV = null;\n      let rangeObj = null;\n      try {\n        rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n      versions.forEach((v) => {\n        if (rangeObj.test(v)) {\n          if (!max || maxSV.compare(v) === -1) {\n            max = v;\n            maxSV = new SemVer(max, options);\n          }\n        }\n      });\n      return max;\n    }, \"maxSatisfying\");\n    module.exports = maxSatisfying;\n  }\n});\n\n// ../../node_modules/semver/ranges/min-satisfying.js\nvar require_min_satisfying = __commonJS({\n  \"../../node_modules/semver/ranges/min-satisfying.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var Range = require_range();\n    var minSatisfying = /* @__PURE__ */ __name((versions, range, options) => {\n      let min = null;\n      let minSV = null;\n      let rangeObj = null;\n      try {\n        rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n      versions.forEach((v) => {\n        if (rangeObj.test(v)) {\n          if (!min || minSV.compare(v) === 1) {\n            min = v;\n            minSV = new SemVer(min, options);\n          }\n        }\n      });\n      return min;\n    }, \"minSatisfying\");\n    module.exports = minSatisfying;\n  }\n});\n\n// ../../node_modules/semver/ranges/min-version.js\nvar require_min_version = __commonJS({\n  \"../../node_modules/semver/ranges/min-version.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var Range = require_range();\n    var gt = require_gt();\n    var minVersion = /* @__PURE__ */ __name((range, loose) => {\n      range = new Range(range, loose);\n      let minver = new SemVer(\"0.0.0\");\n      if (range.test(minver)) {\n        return minver;\n      }\n      minver = new SemVer(\"0.0.0-0\");\n      if (range.test(minver)) {\n        return minver;\n      }\n      minver = null;\n      for (let i = 0; i < range.set.length; ++i) {\n        const comparators = range.set[i];\n        let setMin = null;\n        comparators.forEach((comparator) => {\n          const compver = new SemVer(comparator.semver.version);\n          switch (comparator.operator) {\n            case \">\":\n              if (compver.prerelease.length === 0) {\n                compver.patch++;\n              } else {\n                compver.prerelease.push(0);\n              }\n              compver.raw = compver.format();\n            /* fallthrough */\n            case \"\":\n            case \">=\":\n              if (!setMin || gt(compver, setMin)) {\n                setMin = compver;\n              }\n              break;\n            case \"<\":\n            case \"<=\":\n              break;\n            /* istanbul ignore next */\n            default:\n              throw new Error(`Unexpected operation: ${comparator.operator}`);\n          }\n        });\n        if (setMin && (!minver || gt(minver, setMin))) {\n          minver = setMin;\n        }\n      }\n      if (minver && range.test(minver)) {\n        return minver;\n      }\n      return null;\n    }, \"minVersion\");\n    module.exports = minVersion;\n  }\n});\n\n// ../../node_modules/semver/ranges/valid.js\nvar require_valid2 = __commonJS({\n  \"../../node_modules/semver/ranges/valid.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var Range = require_range();\n    var validRange = /* @__PURE__ */ __name((range, options) => {\n      try {\n        return new Range(range, options).range || \"*\";\n      } catch (er) {\n        return null;\n      }\n    }, \"validRange\");\n    module.exports = validRange;\n  }\n});\n\n// ../../node_modules/semver/ranges/outside.js\nvar require_outside = __commonJS({\n  \"../../node_modules/semver/ranges/outside.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var SemVer = require_semver();\n    var Comparator = require_comparator();\n    var { ANY } = Comparator;\n    var Range = require_range();\n    var satisfies = require_satisfies();\n    var gt = require_gt();\n    var lt = require_lt();\n    var lte = require_lte();\n    var gte = require_gte();\n    var outside = /* @__PURE__ */ __name((version, range, hilo, options) => {\n      version = new SemVer(version, options);\n      range = new Range(range, options);\n      let gtfn, ltefn, ltfn, comp, ecomp;\n      switch (hilo) {\n        case \">\":\n          gtfn = gt;\n          ltefn = lte;\n          ltfn = lt;\n          comp = \">\";\n          ecomp = \">=\";\n          break;\n        case \"<\":\n          gtfn = lt;\n          ltefn = gte;\n          ltfn = gt;\n          comp = \"<\";\n          ecomp = \"<=\";\n          break;\n        default:\n          throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n      }\n      if (satisfies(version, range, options)) {\n        return false;\n      }\n      for (let i = 0; i < range.set.length; ++i) {\n        const comparators = range.set[i];\n        let high = null;\n        let low = null;\n        comparators.forEach((comparator) => {\n          if (comparator.semver === ANY) {\n            comparator = new Comparator(\">=0.0.0\");\n          }\n          high = high || comparator;\n          low = low || comparator;\n          if (gtfn(comparator.semver, high.semver, options)) {\n            high = comparator;\n          } else if (ltfn(comparator.semver, low.semver, options)) {\n            low = comparator;\n          }\n        });\n        if (high.operator === comp || high.operator === ecomp) {\n          return false;\n        }\n        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n          return false;\n        } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n          return false;\n        }\n      }\n      return true;\n    }, \"outside\");\n    module.exports = outside;\n  }\n});\n\n// ../../node_modules/semver/ranges/gtr.js\nvar require_gtr = __commonJS({\n  \"../../node_modules/semver/ranges/gtr.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var outside = require_outside();\n    var gtr = /* @__PURE__ */ __name((version, range, options) => outside(version, range, \">\", options), \"gtr\");\n    module.exports = gtr;\n  }\n});\n\n// ../../node_modules/semver/ranges/ltr.js\nvar require_ltr = __commonJS({\n  \"../../node_modules/semver/ranges/ltr.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var outside = require_outside();\n    var ltr = /* @__PURE__ */ __name((version, range, options) => outside(version, range, \"<\", options), \"ltr\");\n    module.exports = ltr;\n  }\n});\n\n// ../../node_modules/semver/ranges/intersects.js\nvar require_intersects = __commonJS({\n  \"../../node_modules/semver/ranges/intersects.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var Range = require_range();\n    var intersects = /* @__PURE__ */ __name((r1, r2, options) => {\n      r1 = new Range(r1, options);\n      r2 = new Range(r2, options);\n      return r1.intersects(r2, options);\n    }, \"intersects\");\n    module.exports = intersects;\n  }\n});\n\n// ../../node_modules/semver/ranges/simplify.js\nvar require_simplify = __commonJS({\n  \"../../node_modules/semver/ranges/simplify.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var satisfies = require_satisfies();\n    var compare2 = require_compare();\n    module.exports = (versions, range, options) => {\n      const set = [];\n      let first = null;\n      let prev = null;\n      const v = versions.sort((a, b) => compare2(a, b, options));\n      for (const version of v) {\n        const included = satisfies(version, range, options);\n        if (included) {\n          prev = version;\n          if (!first) {\n            first = version;\n          }\n        } else {\n          if (prev) {\n            set.push([first, prev]);\n          }\n          prev = null;\n          first = null;\n        }\n      }\n      if (first) {\n        set.push([first, null]);\n      }\n      const ranges = [];\n      for (const [min, max] of set) {\n        if (min === max) {\n          ranges.push(min);\n        } else if (!max && min === v[0]) {\n          ranges.push(\"*\");\n        } else if (!max) {\n          ranges.push(`>=${min}`);\n        } else if (min === v[0]) {\n          ranges.push(`<=${max}`);\n        } else {\n          ranges.push(`${min} - ${max}`);\n        }\n      }\n      const simplified = ranges.join(\" || \");\n      const original = typeof range.raw === \"string\" ? range.raw : String(range);\n      return simplified.length < original.length ? simplified : range;\n    };\n  }\n});\n\n// ../../node_modules/semver/ranges/subset.js\nvar require_subset = __commonJS({\n  \"../../node_modules/semver/ranges/subset.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var Range = require_range();\n    var Comparator = require_comparator();\n    var { ANY } = Comparator;\n    var satisfies = require_satisfies();\n    var compare2 = require_compare();\n    var subset = /* @__PURE__ */ __name((sub, dom, options = {}) => {\n      if (sub === dom) {\n        return true;\n      }\n      sub = new Range(sub, options);\n      dom = new Range(dom, options);\n      let sawNonNull = false;\n      OUTER: for (const simpleSub of sub.set) {\n        for (const simpleDom of dom.set) {\n          const isSub = simpleSubset(simpleSub, simpleDom, options);\n          sawNonNull = sawNonNull || isSub !== null;\n          if (isSub) {\n            continue OUTER;\n          }\n        }\n        if (sawNonNull) {\n          return false;\n        }\n      }\n      return true;\n    }, \"subset\");\n    var minimumVersionWithPreRelease = [new Comparator(\">=0.0.0-0\")];\n    var minimumVersion = [new Comparator(\">=0.0.0\")];\n    var simpleSubset = /* @__PURE__ */ __name((sub, dom, options) => {\n      if (sub === dom) {\n        return true;\n      }\n      if (sub.length === 1 && sub[0].semver === ANY) {\n        if (dom.length === 1 && dom[0].semver === ANY) {\n          return true;\n        } else if (options.includePrerelease) {\n          sub = minimumVersionWithPreRelease;\n        } else {\n          sub = minimumVersion;\n        }\n      }\n      if (dom.length === 1 && dom[0].semver === ANY) {\n        if (options.includePrerelease) {\n          return true;\n        } else {\n          dom = minimumVersion;\n        }\n      }\n      const eqSet = /* @__PURE__ */ new Set();\n      let gt, lt;\n      for (const c of sub) {\n        if (c.operator === \">\" || c.operator === \">=\") {\n          gt = higherGT(gt, c, options);\n        } else if (c.operator === \"<\" || c.operator === \"<=\") {\n          lt = lowerLT(lt, c, options);\n        } else {\n          eqSet.add(c.semver);\n        }\n      }\n      if (eqSet.size > 1) {\n        return null;\n      }\n      let gtltComp;\n      if (gt && lt) {\n        gtltComp = compare2(gt.semver, lt.semver, options);\n        if (gtltComp > 0) {\n          return null;\n        } else if (gtltComp === 0 && (gt.operator !== \">=\" || lt.operator !== \"<=\")) {\n          return null;\n        }\n      }\n      for (const eq of eqSet) {\n        if (gt && !satisfies(eq, String(gt), options)) {\n          return null;\n        }\n        if (lt && !satisfies(eq, String(lt), options)) {\n          return null;\n        }\n        for (const c of dom) {\n          if (!satisfies(eq, String(c), options)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      let higher, lower;\n      let hasDomLT, hasDomGT;\n      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;\n      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;\n      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === \"<\" && needDomLTPre.prerelease[0] === 0) {\n        needDomLTPre = false;\n      }\n      for (const c of dom) {\n        hasDomGT = hasDomGT || c.operator === \">\" || c.operator === \">=\";\n        hasDomLT = hasDomLT || c.operator === \"<\" || c.operator === \"<=\";\n        if (gt) {\n          if (needDomGTPre) {\n            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {\n              needDomGTPre = false;\n            }\n          }\n          if (c.operator === \">\" || c.operator === \">=\") {\n            higher = higherGT(gt, c, options);\n            if (higher === c && higher !== gt) {\n              return false;\n            }\n          } else if (gt.operator === \">=\" && !satisfies(gt.semver, String(c), options)) {\n            return false;\n          }\n        }\n        if (lt) {\n          if (needDomLTPre) {\n            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {\n              needDomLTPre = false;\n            }\n          }\n          if (c.operator === \"<\" || c.operator === \"<=\") {\n            lower = lowerLT(lt, c, options);\n            if (lower === c && lower !== lt) {\n              return false;\n            }\n          } else if (lt.operator === \"<=\" && !satisfies(lt.semver, String(c), options)) {\n            return false;\n          }\n        }\n        if (!c.operator && (lt || gt) && gtltComp !== 0) {\n          return false;\n        }\n      }\n      if (gt && hasDomLT && !lt && gtltComp !== 0) {\n        return false;\n      }\n      if (lt && hasDomGT && !gt && gtltComp !== 0) {\n        return false;\n      }\n      if (needDomGTPre || needDomLTPre) {\n        return false;\n      }\n      return true;\n    }, \"simpleSubset\");\n    var higherGT = /* @__PURE__ */ __name((a, b, options) => {\n      if (!a) {\n        return b;\n      }\n      const comp = compare2(a.semver, b.semver, options);\n      return comp > 0 ? a : comp < 0 ? b : b.operator === \">\" && a.operator === \">=\" ? b : a;\n    }, \"higherGT\");\n    var lowerLT = /* @__PURE__ */ __name((a, b, options) => {\n      if (!a) {\n        return b;\n      }\n      const comp = compare2(a.semver, b.semver, options);\n      return comp < 0 ? a : comp > 0 ? b : b.operator === \"<\" && a.operator === \"<=\" ? b : a;\n    }, \"lowerLT\");\n    module.exports = subset;\n  }\n});\n\n// ../../node_modules/semver/index.js\nvar require_semver2 = __commonJS({\n  \"../../node_modules/semver/index.js\"(exports, module) {\n    \"use strict\";\n    init_process_shim();\n    var internalRe = require_re();\n    var constants = require_constants();\n    var SemVer = require_semver();\n    var identifiers = require_identifiers();\n    var parse = require_parse();\n    var valid = require_valid();\n    var clean = require_clean();\n    var inc = require_inc();\n    var diff = require_diff();\n    var major = require_major();\n    var minor = require_minor();\n    var patch = require_patch();\n    var prerelease = require_prerelease();\n    var compare2 = require_compare();\n    var rcompare = require_rcompare();\n    var compareLoose = require_compare_loose();\n    var compareBuild = require_compare_build();\n    var sort = require_sort();\n    var rsort = require_rsort();\n    var gt = require_gt();\n    var lt = require_lt();\n    var eq = require_eq();\n    var neq = require_neq();\n    var gte = require_gte();\n    var lte = require_lte();\n    var cmp = require_cmp();\n    var coerce = require_coerce();\n    var Comparator = require_comparator();\n    var Range = require_range();\n    var satisfies = require_satisfies();\n    var toComparators = require_to_comparators();\n    var maxSatisfying = require_max_satisfying();\n    var minSatisfying = require_min_satisfying();\n    var minVersion = require_min_version();\n    var validRange = require_valid2();\n    var outside = require_outside();\n    var gtr = require_gtr();\n    var ltr = require_ltr();\n    var intersects = require_intersects();\n    var simplifyRange = require_simplify();\n    var subset = require_subset();\n    module.exports = {\n      parse,\n      valid,\n      clean,\n      inc,\n      diff,\n      major,\n      minor,\n      patch,\n      prerelease,\n      compare: compare2,\n      rcompare,\n      compareLoose,\n      compareBuild,\n      sort,\n      rsort,\n      gt,\n      lt,\n      eq,\n      neq,\n      gte,\n      lte,\n      cmp,\n      coerce,\n      Comparator,\n      Range,\n      satisfies,\n      toComparators,\n      maxSatisfying,\n      minSatisfying,\n      minVersion,\n      validRange,\n      outside,\n      gtr,\n      ltr,\n      intersects,\n      simplifyRange,\n      subset,\n      SemVer,\n      re: internalRe.re,\n      src: internalRe.src,\n      tokens: internalRe.t,\n      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n      RELEASE_TYPES: constants.RELEASE_TYPES,\n      compareIdentifiers: identifiers.compareIdentifiers,\n      rcompareIdentifiers: identifiers.rcompareIdentifiers\n    };\n  }\n});\n\n// src/netron/reference.ts\nvar Reference;\nvar init_reference = __esm({\n  \"src/netron/reference.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    Reference = class {\n      /**\n       * Creates a new instance of Reference.\n       * The constructor initializes a reference to a service definition using its unique identifier.\n       * This identifier is used by the Netron framework to locate and resolve the actual service\n       * definition when needed.\n       *\n       * @param {string} defId - The unique identifier of the service definition.\n       * This identifier must match the ID of an existing service definition in the Netron network.\n       *\n       * @throws {Error} If the provided defId is not a valid string or is empty.\n       *\n       * @example\n       * // Creating a reference to a specific service\n       * const authServiceRef = new Reference('authentication-service');\n       */\n      constructor(defId) {\n        this.defId = defId;\n        if (!defId || typeof defId !== \"string\") {\n          throw new Error(\"Service definition ID must be a non-empty string\");\n        }\n      }\n      static {\n        __name(this, \"Reference\");\n      }\n    };\n  }\n});\n\n// e2e/stubs/stream.js\nvar Readable, Writable;\nvar init_stream = __esm({\n  \"e2e/stubs/stream.js\"() {\n    \"use strict\";\n    init_process_shim();\n    Readable = class {\n      static {\n        __name(this, \"Readable\");\n      }\n      constructor() {\n      }\n    };\n    Writable = class {\n      static {\n        __name(this, \"Writable\");\n      }\n      constructor() {\n      }\n    };\n  }\n});\n\n// src/netron/readable-stream.ts\nvar MAX_BUFFER_SIZE, NetronReadableStream;\nvar init_readable_stream = __esm({\n  \"src/netron/readable-stream.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    init_stream();\n    MAX_BUFFER_SIZE = 1e4;\n    NetronReadableStream = class _NetronReadableStream extends Readable {\n      static {\n        __name(this, \"NetronReadableStream\");\n      }\n      /** The remote peer this stream is associated with */\n      peer;\n      /** Internal buffer for storing out-of-order packets */\n      buffer = /* @__PURE__ */ new Map();\n      /** Next expected packet index for ordered delivery */\n      expectedIndex = 0;\n      /** Timeout handle for stream inactivity detection */\n      timeout;\n      /** Unique identifier for this stream */\n      id;\n      /** Whether the stream has been closed */\n      isClosed = false;\n      /** Whether all data has been successfully received */\n      isComplete = false;\n      /** Whether this is a live streaming connection */\n      isLive;\n      /**\n       * Creates a new NetronReadableStream instance.\n       *\n       * @param {NetronReadableStreamOptions} options - Configuration options for the stream\n       * @throws {Error} If stream initialization fails\n       */\n      constructor({ peer, streamId, isLive = false, ...opts }) {\n        super({ ...opts, objectMode: true });\n        this.peer = peer;\n        this.id = streamId;\n        this.isLive = isLive;\n        this.peer.logger.info({ streamId: this.id, isLive }, \"Creating readable stream\");\n        this.peer.readableStreams.set(this.id, this);\n        if (!this.isLive) {\n          this.resetTimeout();\n        }\n        this.on(\"close\", this.cleanup);\n        this.on(\"error\", this.handleError);\n      }\n      /**\n       * Processes incoming data packets and manages ordered delivery.\n       * This method implements the core packet handling logic, including:\n       * - Buffer overflow protection\n       * - Packet reordering\n       * - Flow control\n       * - Stream completion detection\n       *\n       * @param {Packet} packet - The incoming data packet\n       * @returns {void}\n       * @throws {Error} If buffer overflow occurs or stream is closed\n       */\n      onPacket(packet) {\n        if (this.isClosed) {\n          this.peer.logger.warn({ streamId: this.id }, \"Received packet for closed stream\");\n          return;\n        }\n        this.resetTimeout();\n        if (this.buffer.size > MAX_BUFFER_SIZE) {\n          this.peer.logger.error({ streamId: this.id, size: this.buffer.size }, \"Stream buffer overflow\");\n          this.destroy(new Error(`Buffer overflow: more than ${MAX_BUFFER_SIZE} packets buffered`));\n          return;\n        }\n        this.peer.logger.debug({ streamId: this.id, index: packet.streamIndex }, \"Processing packet\");\n        if (!packet.isLastChunk() || packet.data !== null) {\n          this.buffer.set(packet.streamIndex, packet.data);\n        }\n        while (this.buffer.has(this.expectedIndex)) {\n          const chunk = this.buffer.get(this.expectedIndex);\n          this.buffer.delete(this.expectedIndex);\n          this.expectedIndex++;\n          if (!this.push(chunk)) {\n            this.peer.logger.debug({ streamId: this.id }, \"Stream backpressure detected\");\n            break;\n          }\n        }\n        if (packet.isLastChunk()) {\n          this.peer.logger.info({ streamId: this.id }, \"Received last chunk\");\n          this.isComplete = true;\n          this.push(null);\n        }\n      }\n      /**\n       * Implementation of the Readable stream's _read method.\n       * This method is called when the stream's internal buffer is ready to accept more data.\n       * In our implementation, data is pushed in onPacket, so this method is intentionally empty.\n       *\n       * @returns {void}\n       */\n      _read() {\n      }\n      /**\n       * Resets the stream's inactivity timeout.\n       * This method implements automatic stream cleanup for non-live streams\n       * that have been inactive for too long.\n       *\n       * @returns {void}\n       */\n      resetTimeout() {\n        if (this.isLive) return;\n        if (this.timeout) clearTimeout(this.timeout);\n        const timeoutDuration = this.peer.netron.options?.streamTimeout ?? 6e4;\n        this.peer.logger.debug({ streamId: this.id, timeoutDuration }, \"Resetting stream timeout\");\n        this.timeout = setTimeout(() => {\n          const message = `Stream ${this.id} inactive for ${timeoutDuration}ms, closing.`;\n          this.peer.logger.warn(message);\n          this.destroy(new Error(message));\n        }, timeoutDuration);\n      }\n      /**\n       * Closes the stream and releases associated resources.\n       * This method implements graceful stream termination with support for\n       * both normal and forced closure scenarios.\n       *\n       * @param {boolean} [force=false] - Whether to force stream closure\n       * @returns {void}\n       */\n      closeStream(force = false) {\n        if (this.isClosed) {\n          this.peer.logger.warn({ streamId: this.id }, \"Attempt to close already closed stream\");\n          return;\n        }\n        if (this.isLive && !force) {\n          this.peer.logger.warn({ streamId: this.id }, \"Attempt to close live stream\");\n          return;\n        }\n        this.peer.logger.info({ streamId: this.id, force }, \"Closing stream\");\n        this.push(null);\n        if (this.isLive && force) {\n          this.destroy();\n        }\n      }\n      /**\n       * Forces immediate stream closure due to remote stream termination.\n       * This method is called when receiving an explicit close packet from the remote peer.\n       * It immediately closes the stream and emits appropriate events.\n       *\n       * @param {string} [reason] - Optional reason for the forced closure\n       * @returns {void}\n       */\n      forceClose(reason) {\n        if (this.isClosed) {\n          this.peer.logger.warn({ streamId: this.id }, \"Attempt to force close already closed stream\");\n          return;\n        }\n        this.peer.logger.info({ streamId: this.id, reason }, \"Force closing stream\");\n        this.isClosed = true;\n        this.isComplete = true;\n        this.push(null);\n        process.nextTick(() => {\n          this.emit(\"close\");\n          this.cleanup();\n        });\n      }\n      /**\n       * Performs cleanup operations when the stream is closed.\n       * This method ensures proper resource deallocation and stream deregistration.\n       *\n       * @returns {void}\n       */\n      cleanup = /* @__PURE__ */ __name(() => {\n        this.peer.logger.debug({ streamId: this.id }, \"Cleaning up stream resources\");\n        if (this.timeout) clearTimeout(this.timeout);\n        this.peer.readableStreams.delete(this.id);\n        this.buffer.clear();\n      }, \"cleanup\");\n      /**\n       * Handles stream error events.\n       * This method implements error logging and cleanup for stream errors.\n       *\n       * @param {Error} error - The error that occurred\n       * @returns {void}\n       */\n      handleError = /* @__PURE__ */ __name((error) => {\n        this.peer.logger.error({ streamId: this.id, error }, \"Stream error occurred\");\n        this.cleanup();\n      }, \"handleError\");\n      /**\n       * Overrides the standard destroy method to ensure proper cleanup.\n       * This method implements a robust stream termination process that\n       * guarantees resource cleanup and error propagation.\n       *\n       * @param {Error} [error] - Optional error to propagate\n       * @returns {this}\n       */\n      destroy(error) {\n        if (this.isClosed) {\n          this.peer.logger.warn({ streamId: this.id }, \"Attempt to destroy already closed stream\");\n          return this;\n        }\n        this.peer.logger.info({ streamId: this.id, error }, \"Destroying stream\");\n        this.isClosed = true;\n        super.destroy(error);\n        this.cleanup();\n        return this;\n      }\n      /**\n       * Factory method for creating new NetronReadableStream instances.\n       * This method provides a convenient way to create stream instances\n       * with default configuration.\n       *\n       * @param {RemotePeer} peer - The remote peer for this stream\n       * @param {number} streamId - Unique identifier for the stream\n       * @param {boolean} [isLive=false] - Whether this is a live stream\n       * @returns {NetronReadableStream}\n       */\n      static create(peer, streamId, isLive = false) {\n        return new _NetronReadableStream({ peer, streamId, isLive });\n      }\n    };\n  }\n});\n\n// ../../node_modules/long/index.js\nfunction Long(low, high, unsigned) {\n  this.low = low | 0;\n  this.high = high | 0;\n  this.unsigned = !!unsigned;\n}\nfunction isLong(obj) {\n  return (obj && obj[\"__isLong__\"]) === true;\n}\nfunction ctz32(value) {\n  var c = Math.clz32(value & -value);\n  return value ? 31 - c : c;\n}\nfunction fromInt(value, unsigned) {\n  var obj, cachedObj, cache;\n  if (unsigned) {\n    value >>>= 0;\n    if (cache = 0 <= value && value < 256) {\n      cachedObj = UINT_CACHE[value];\n      if (cachedObj) return cachedObj;\n    }\n    obj = fromBits(value, 0, true);\n    if (cache) UINT_CACHE[value] = obj;\n    return obj;\n  } else {\n    value |= 0;\n    if (cache = -128 <= value && value < 128) {\n      cachedObj = INT_CACHE[value];\n      if (cachedObj) return cachedObj;\n    }\n    obj = fromBits(value, value < 0 ? -1 : 0, false);\n    if (cache) INT_CACHE[value] = obj;\n    return obj;\n  }\n}\nfunction fromNumber(value, unsigned) {\n  if (isNaN(value)) return unsigned ? UZERO : ZERO;\n  if (unsigned) {\n    if (value < 0) return UZERO;\n    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n  } else {\n    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n  }\n  if (value < 0) return fromNumber(-value, unsigned).neg();\n  return fromBits(\n    value % TWO_PWR_32_DBL | 0,\n    value / TWO_PWR_32_DBL | 0,\n    unsigned\n  );\n}\nfunction fromBits(lowBits, highBits, unsigned) {\n  return new Long(lowBits, highBits, unsigned);\n}\nfunction fromString(str, unsigned, radix) {\n  if (str.length === 0) throw Error(\"empty string\");\n  if (typeof unsigned === \"number\") {\n    radix = unsigned;\n    unsigned = false;\n  } else {\n    unsigned = !!unsigned;\n  }\n  if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n    return unsigned ? UZERO : ZERO;\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n  var p;\n  if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n  else if (p === 0) {\n    return fromString(str.substring(1), unsigned, radix).neg();\n  }\n  var radixToPower = fromNumber(pow_dbl(radix, 8));\n  var result = ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = fromNumber(pow_dbl(radix, size));\n      result = result.mul(power).add(fromNumber(value));\n    } else {\n      result = result.mul(radixToPower);\n      result = result.add(fromNumber(value));\n    }\n  }\n  result.unsigned = unsigned;\n  return result;\n}\nfunction fromValue(val, unsigned) {\n  if (typeof val === \"number\") return fromNumber(val, unsigned);\n  if (typeof val === \"string\") return fromString(val, unsigned);\n  return fromBits(\n    val.low,\n    val.high,\n    typeof unsigned === \"boolean\" ? unsigned : val.unsigned\n  );\n}\nvar wasm, INT_CACHE, UINT_CACHE, pow_dbl, TWO_PWR_16_DBL, TWO_PWR_24_DBL, TWO_PWR_32_DBL, TWO_PWR_64_DBL, TWO_PWR_63_DBL, TWO_PWR_24, ZERO, UZERO, ONE, UONE, NEG_ONE, MAX_VALUE, MAX_UNSIGNED_VALUE, MIN_VALUE, LongPrototype, long_default;\nvar init_long = __esm({\n  \"../../node_modules/long/index.js\"() {\n    init_process_shim();\n    wasm = null;\n    try {\n      wasm = new WebAssembly.Instance(\n        new WebAssembly.Module(\n          new Uint8Array([\n            // \\0asm\n            0,\n            97,\n            115,\n            109,\n            // version 1\n            1,\n            0,\n            0,\n            0,\n            // section \"type\"\n            1,\n            13,\n            2,\n            // 0, () => i32\n            96,\n            0,\n            1,\n            127,\n            // 1, (i32, i32, i32, i32) => i32\n            96,\n            4,\n            127,\n            127,\n            127,\n            127,\n            1,\n            127,\n            // section \"function\"\n            3,\n            7,\n            6,\n            // 0, type 0\n            0,\n            // 1, type 1\n            1,\n            // 2, type 1\n            1,\n            // 3, type 1\n            1,\n            // 4, type 1\n            1,\n            // 5, type 1\n            1,\n            // section \"global\"\n            6,\n            6,\n            1,\n            // 0, \"high\", mutable i32\n            127,\n            1,\n            65,\n            0,\n            11,\n            // section \"export\"\n            7,\n            50,\n            6,\n            // 0, \"mul\"\n            3,\n            109,\n            117,\n            108,\n            0,\n            1,\n            // 1, \"div_s\"\n            5,\n            100,\n            105,\n            118,\n            95,\n            115,\n            0,\n            2,\n            // 2, \"div_u\"\n            5,\n            100,\n            105,\n            118,\n            95,\n            117,\n            0,\n            3,\n            // 3, \"rem_s\"\n            5,\n            114,\n            101,\n            109,\n            95,\n            115,\n            0,\n            4,\n            // 4, \"rem_u\"\n            5,\n            114,\n            101,\n            109,\n            95,\n            117,\n            0,\n            5,\n            // 5, \"get_high\"\n            8,\n            103,\n            101,\n            116,\n            95,\n            104,\n            105,\n            103,\n            104,\n            0,\n            0,\n            // section \"code\"\n            10,\n            191,\n            1,\n            6,\n            // 0, \"get_high\"\n            4,\n            0,\n            35,\n            0,\n            11,\n            // 1, \"mul\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            126,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 2, \"div_s\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            127,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 3, \"div_u\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            128,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 4, \"rem_s\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            129,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 5, \"rem_u\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            130,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11\n          ])\n        ),\n        {}\n      ).exports;\n    } catch {\n    }\n    __name(Long, \"Long\");\n    Long.prototype.__isLong__;\n    Object.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n    __name(isLong, \"isLong\");\n    __name(ctz32, \"ctz32\");\n    Long.isLong = isLong;\n    INT_CACHE = {};\n    UINT_CACHE = {};\n    __name(fromInt, \"fromInt\");\n    Long.fromInt = fromInt;\n    __name(fromNumber, \"fromNumber\");\n    Long.fromNumber = fromNumber;\n    __name(fromBits, \"fromBits\");\n    Long.fromBits = fromBits;\n    pow_dbl = Math.pow;\n    __name(fromString, \"fromString\");\n    Long.fromString = fromString;\n    __name(fromValue, \"fromValue\");\n    Long.fromValue = fromValue;\n    TWO_PWR_16_DBL = 1 << 16;\n    TWO_PWR_24_DBL = 1 << 24;\n    TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n    TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n    TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n    TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n    ZERO = fromInt(0);\n    Long.ZERO = ZERO;\n    UZERO = fromInt(0, true);\n    Long.UZERO = UZERO;\n    ONE = fromInt(1);\n    Long.ONE = ONE;\n    UONE = fromInt(1, true);\n    Long.UONE = UONE;\n    NEG_ONE = fromInt(-1);\n    Long.NEG_ONE = NEG_ONE;\n    MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);\n    Long.MAX_VALUE = MAX_VALUE;\n    MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);\n    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n    MIN_VALUE = fromBits(0, 2147483648 | 0, false);\n    Long.MIN_VALUE = MIN_VALUE;\n    LongPrototype = Long.prototype;\n    LongPrototype.toInt = /* @__PURE__ */ __name(function toInt() {\n      return this.unsigned ? this.low >>> 0 : this.low;\n    }, \"toInt\");\n    LongPrototype.toNumber = /* @__PURE__ */ __name(function toNumber() {\n      if (this.unsigned)\n        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }, \"toNumber\");\n    LongPrototype.toString = /* @__PURE__ */ __name(function toString2(radix) {\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n      if (this.isZero()) return \"0\";\n      if (this.isNegative()) {\n        if (this.eq(MIN_VALUE)) {\n          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n          return div.toString(radix) + rem1.toInt().toString(radix);\n        } else return \"-\" + this.neg().toString(radix);\n      }\n      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n      var result = \"\";\n      while (true) {\n        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero()) return digits + result;\n        else {\n          while (digits.length < 6) digits = \"0\" + digits;\n          result = \"\" + digits + result;\n        }\n      }\n    }, \"toString\");\n    LongPrototype.getHighBits = /* @__PURE__ */ __name(function getHighBits() {\n      return this.high;\n    }, \"getHighBits\");\n    LongPrototype.getHighBitsUnsigned = /* @__PURE__ */ __name(function getHighBitsUnsigned() {\n      return this.high >>> 0;\n    }, \"getHighBitsUnsigned\");\n    LongPrototype.getLowBits = /* @__PURE__ */ __name(function getLowBits() {\n      return this.low;\n    }, \"getLowBits\");\n    LongPrototype.getLowBitsUnsigned = /* @__PURE__ */ __name(function getLowBitsUnsigned() {\n      return this.low >>> 0;\n    }, \"getLowBitsUnsigned\");\n    LongPrototype.getNumBitsAbs = /* @__PURE__ */ __name(function getNumBitsAbs() {\n      if (this.isNegative())\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n      var val = this.high != 0 ? this.high : this.low;\n      for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;\n      return this.high != 0 ? bit + 33 : bit + 1;\n    }, \"getNumBitsAbs\");\n    LongPrototype.isSafeInteger = /* @__PURE__ */ __name(function isSafeInteger2() {\n      var top11Bits = this.high >> 21;\n      if (!top11Bits) return true;\n      if (this.unsigned) return false;\n      return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);\n    }, \"isSafeInteger\");\n    LongPrototype.isZero = /* @__PURE__ */ __name(function isZero() {\n      return this.high === 0 && this.low === 0;\n    }, \"isZero\");\n    LongPrototype.eqz = LongPrototype.isZero;\n    LongPrototype.isNegative = /* @__PURE__ */ __name(function isNegative() {\n      return !this.unsigned && this.high < 0;\n    }, \"isNegative\");\n    LongPrototype.isPositive = /* @__PURE__ */ __name(function isPositive() {\n      return this.unsigned || this.high >= 0;\n    }, \"isPositive\");\n    LongPrototype.isOdd = /* @__PURE__ */ __name(function isOdd() {\n      return (this.low & 1) === 1;\n    }, \"isOdd\");\n    LongPrototype.isEven = /* @__PURE__ */ __name(function isEven() {\n      return (this.low & 1) === 0;\n    }, \"isEven\");\n    LongPrototype.equals = /* @__PURE__ */ __name(function equals(other) {\n      if (!isLong(other)) other = fromValue(other);\n      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n        return false;\n      return this.high === other.high && this.low === other.low;\n    }, \"equals\");\n    LongPrototype.eq = LongPrototype.equals;\n    LongPrototype.notEquals = /* @__PURE__ */ __name(function notEquals(other) {\n      return !this.eq(\n        /* validates */\n        other\n      );\n    }, \"notEquals\");\n    LongPrototype.neq = LongPrototype.notEquals;\n    LongPrototype.ne = LongPrototype.notEquals;\n    LongPrototype.lessThan = /* @__PURE__ */ __name(function lessThan(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) < 0;\n    }, \"lessThan\");\n    LongPrototype.lt = LongPrototype.lessThan;\n    LongPrototype.lessThanOrEqual = /* @__PURE__ */ __name(function lessThanOrEqual(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) <= 0;\n    }, \"lessThanOrEqual\");\n    LongPrototype.lte = LongPrototype.lessThanOrEqual;\n    LongPrototype.le = LongPrototype.lessThanOrEqual;\n    LongPrototype.greaterThan = /* @__PURE__ */ __name(function greaterThan(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) > 0;\n    }, \"greaterThan\");\n    LongPrototype.gt = LongPrototype.greaterThan;\n    LongPrototype.greaterThanOrEqual = /* @__PURE__ */ __name(function greaterThanOrEqual(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) >= 0;\n    }, \"greaterThanOrEqual\");\n    LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n    LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n    LongPrototype.compare = /* @__PURE__ */ __name(function compare(other) {\n      if (!isLong(other)) other = fromValue(other);\n      if (this.eq(other)) return 0;\n      var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n      if (thisNeg && !otherNeg) return -1;\n      if (!thisNeg && otherNeg) return 1;\n      if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    }, \"compare\");\n    LongPrototype.comp = LongPrototype.compare;\n    LongPrototype.negate = /* @__PURE__ */ __name(function negate() {\n      if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n      return this.not().add(ONE);\n    }, \"negate\");\n    LongPrototype.neg = LongPrototype.negate;\n    LongPrototype.add = /* @__PURE__ */ __name(function add(addend) {\n      if (!isLong(addend)) addend = fromValue(addend);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = addend.high >>> 16;\n      var b32 = addend.high & 65535;\n      var b16 = addend.low >>> 16;\n      var b00 = addend.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 + b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 + b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 + b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 + b48;\n      c48 &= 65535;\n      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }, \"add\");\n    LongPrototype.subtract = /* @__PURE__ */ __name(function subtract(subtrahend) {\n      if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n      return this.add(subtrahend.neg());\n    }, \"subtract\");\n    LongPrototype.sub = LongPrototype.subtract;\n    LongPrototype.multiply = /* @__PURE__ */ __name(function multiply(multiplier) {\n      if (this.isZero()) return this;\n      if (!isLong(multiplier)) multiplier = fromValue(multiplier);\n      if (wasm) {\n        var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n        return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n      }\n      if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n      if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n      if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n      if (this.isNegative()) {\n        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n        else return this.neg().mul(multiplier).neg();\n      } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = multiplier.high >>> 16;\n      var b32 = multiplier.high & 65535;\n      var b16 = multiplier.low >>> 16;\n      var b00 = multiplier.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 * b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 * b00;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c16 += a00 * b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 * b00;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a16 * b16;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a00 * b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n      c48 &= 65535;\n      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }, \"multiply\");\n    LongPrototype.mul = LongPrototype.multiply;\n    LongPrototype.divide = /* @__PURE__ */ __name(function divide(divisor) {\n      if (!isLong(divisor)) divisor = fromValue(divisor);\n      if (divisor.isZero()) throw Error(\"division by zero\");\n      if (wasm) {\n        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {\n          return this;\n        }\n        var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(\n          this.low,\n          this.high,\n          divisor.low,\n          divisor.high\n        );\n        return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n      }\n      if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n      var approx, rem, res;\n      if (!this.unsigned) {\n        if (this.eq(MIN_VALUE)) {\n          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n            return MIN_VALUE;\n          else if (divisor.eq(MIN_VALUE)) return ONE;\n          else {\n            var halfThis = this.shr(1);\n            approx = halfThis.div(divisor).shl(1);\n            if (approx.eq(ZERO)) {\n              return divisor.isNegative() ? ONE : NEG_ONE;\n            } else {\n              rem = this.sub(divisor.mul(approx));\n              res = approx.add(rem.div(divisor));\n              return res;\n            }\n          }\n        } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n        if (this.isNegative()) {\n          if (divisor.isNegative()) return this.neg().div(divisor.neg());\n          return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n        res = ZERO;\n      } else {\n        if (!divisor.unsigned) divisor = divisor.toUnsigned();\n        if (divisor.gt(this)) return UZERO;\n        if (divisor.gt(this.shru(1)))\n          return UONE;\n        res = UZERO;\n      }\n      rem = this;\n      while (rem.gte(divisor)) {\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\n          approx -= delta;\n          approxRes = fromNumber(approx, this.unsigned);\n          approxRem = approxRes.mul(divisor);\n        }\n        if (approxRes.isZero()) approxRes = ONE;\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n      }\n      return res;\n    }, \"divide\");\n    LongPrototype.div = LongPrototype.divide;\n    LongPrototype.modulo = /* @__PURE__ */ __name(function modulo(divisor) {\n      if (!isLong(divisor)) divisor = fromValue(divisor);\n      if (wasm) {\n        var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(\n          this.low,\n          this.high,\n          divisor.low,\n          divisor.high\n        );\n        return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n      }\n      return this.sub(this.div(divisor).mul(divisor));\n    }, \"modulo\");\n    LongPrototype.mod = LongPrototype.modulo;\n    LongPrototype.rem = LongPrototype.modulo;\n    LongPrototype.not = /* @__PURE__ */ __name(function not() {\n      return fromBits(~this.low, ~this.high, this.unsigned);\n    }, \"not\");\n    LongPrototype.countLeadingZeros = /* @__PURE__ */ __name(function countLeadingZeros() {\n      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n    }, \"countLeadingZeros\");\n    LongPrototype.clz = LongPrototype.countLeadingZeros;\n    LongPrototype.countTrailingZeros = /* @__PURE__ */ __name(function countTrailingZeros() {\n      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n    }, \"countTrailingZeros\");\n    LongPrototype.ctz = LongPrototype.countTrailingZeros;\n    LongPrototype.and = /* @__PURE__ */ __name(function and(other) {\n      if (!isLong(other)) other = fromValue(other);\n      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    }, \"and\");\n    LongPrototype.or = /* @__PURE__ */ __name(function or(other) {\n      if (!isLong(other)) other = fromValue(other);\n      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    }, \"or\");\n    LongPrototype.xor = /* @__PURE__ */ __name(function xor(other) {\n      if (!isLong(other)) other = fromValue(other);\n      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    }, \"xor\");\n    LongPrototype.shiftLeft = /* @__PURE__ */ __name(function shiftLeft(numBits) {\n      if (isLong(numBits)) numBits = numBits.toInt();\n      if ((numBits &= 63) === 0) return this;\n      else if (numBits < 32)\n        return fromBits(\n          this.low << numBits,\n          this.high << numBits | this.low >>> 32 - numBits,\n          this.unsigned\n        );\n      else return fromBits(0, this.low << numBits - 32, this.unsigned);\n    }, \"shiftLeft\");\n    LongPrototype.shl = LongPrototype.shiftLeft;\n    LongPrototype.shiftRight = /* @__PURE__ */ __name(function shiftRight(numBits) {\n      if (isLong(numBits)) numBits = numBits.toInt();\n      if ((numBits &= 63) === 0) return this;\n      else if (numBits < 32)\n        return fromBits(\n          this.low >>> numBits | this.high << 32 - numBits,\n          this.high >> numBits,\n          this.unsigned\n        );\n      else\n        return fromBits(\n          this.high >> numBits - 32,\n          this.high >= 0 ? 0 : -1,\n          this.unsigned\n        );\n    }, \"shiftRight\");\n    LongPrototype.shr = LongPrototype.shiftRight;\n    LongPrototype.shiftRightUnsigned = /* @__PURE__ */ __name(function shiftRightUnsigned(numBits) {\n      if (isLong(numBits)) numBits = numBits.toInt();\n      if ((numBits &= 63) === 0) return this;\n      if (numBits < 32)\n        return fromBits(\n          this.low >>> numBits | this.high << 32 - numBits,\n          this.high >>> numBits,\n          this.unsigned\n        );\n      if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n      return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n    }, \"shiftRightUnsigned\");\n    LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n    LongPrototype.rotateLeft = /* @__PURE__ */ __name(function rotateLeft(numBits) {\n      var b;\n      if (isLong(numBits)) numBits = numBits.toInt();\n      if ((numBits &= 63) === 0) return this;\n      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n      if (numBits < 32) {\n        b = 32 - numBits;\n        return fromBits(\n          this.low << numBits | this.high >>> b,\n          this.high << numBits | this.low >>> b,\n          this.unsigned\n        );\n      }\n      numBits -= 32;\n      b = 32 - numBits;\n      return fromBits(\n        this.high << numBits | this.low >>> b,\n        this.low << numBits | this.high >>> b,\n        this.unsigned\n      );\n    }, \"rotateLeft\");\n    LongPrototype.rotl = LongPrototype.rotateLeft;\n    LongPrototype.rotateRight = /* @__PURE__ */ __name(function rotateRight(numBits) {\n      var b;\n      if (isLong(numBits)) numBits = numBits.toInt();\n      if ((numBits &= 63) === 0) return this;\n      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n      if (numBits < 32) {\n        b = 32 - numBits;\n        return fromBits(\n          this.high << b | this.low >>> numBits,\n          this.low << b | this.high >>> numBits,\n          this.unsigned\n        );\n      }\n      numBits -= 32;\n      b = 32 - numBits;\n      return fromBits(\n        this.low << b | this.high >>> numBits,\n        this.high << b | this.low >>> numBits,\n        this.unsigned\n      );\n    }, \"rotateRight\");\n    LongPrototype.rotr = LongPrototype.rotateRight;\n    LongPrototype.toSigned = /* @__PURE__ */ __name(function toSigned() {\n      if (!this.unsigned) return this;\n      return fromBits(this.low, this.high, false);\n    }, \"toSigned\");\n    LongPrototype.toUnsigned = /* @__PURE__ */ __name(function toUnsigned() {\n      if (this.unsigned) return this;\n      return fromBits(this.low, this.high, true);\n    }, \"toUnsigned\");\n    LongPrototype.toBytes = /* @__PURE__ */ __name(function toBytes(le) {\n      return le ? this.toBytesLE() : this.toBytesBE();\n    }, \"toBytes\");\n    LongPrototype.toBytesLE = /* @__PURE__ */ __name(function toBytesLE() {\n      var hi = this.high, lo = this.low;\n      return [\n        lo & 255,\n        lo >>> 8 & 255,\n        lo >>> 16 & 255,\n        lo >>> 24,\n        hi & 255,\n        hi >>> 8 & 255,\n        hi >>> 16 & 255,\n        hi >>> 24\n      ];\n    }, \"toBytesLE\");\n    LongPrototype.toBytesBE = /* @__PURE__ */ __name(function toBytesBE() {\n      var hi = this.high, lo = this.low;\n      return [\n        hi >>> 24,\n        hi >>> 16 & 255,\n        hi >>> 8 & 255,\n        hi & 255,\n        lo >>> 24,\n        lo >>> 16 & 255,\n        lo >>> 8 & 255,\n        lo & 255\n      ];\n    }, \"toBytesBE\");\n    Long.fromBytes = /* @__PURE__ */ __name(function fromBytes(bytes, unsigned, le) {\n      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    }, \"fromBytes\");\n    Long.fromBytesLE = /* @__PURE__ */ __name(function fromBytesLE(bytes, unsigned) {\n      return new Long(\n        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,\n        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,\n        unsigned\n      );\n    }, \"fromBytesLE\");\n    Long.fromBytesBE = /* @__PURE__ */ __name(function fromBytesBE(bytes, unsigned) {\n      return new Long(\n        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],\n        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],\n        unsigned\n      );\n    }, \"fromBytesBE\");\n    if (typeof BigInt === \"function\") {\n      Long.fromBigInt = /* @__PURE__ */ __name(function fromBigInt(value, unsigned) {\n        var lowBits = Number(BigInt.asIntN(32, value));\n        var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));\n        return fromBits(lowBits, highBits, unsigned);\n      }, \"fromBigInt\");\n      Long.fromValue = /* @__PURE__ */ __name(function fromValueWithBigInt(value, unsigned) {\n        if (typeof value === \"bigint\") return Long.fromBigInt(value, unsigned);\n        return fromValue(value, unsigned);\n      }, \"fromValueWithBigInt\");\n      LongPrototype.toBigInt = /* @__PURE__ */ __name(function toBigInt() {\n        var lowBigInt = BigInt(this.low >>> 0);\n        var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);\n        return highBigInt << BigInt(32) | lowBigInt;\n      }, \"toBigInt\");\n    }\n    long_default = Long;\n  }\n});\n\n// ../../node_modules/base64-js/index.js\nvar require_base64_js = __commonJS({\n  \"../../node_modules/base64-js/index.js\"(exports) {\n    \"use strict\";\n    init_process_shim();\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for (i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n    var i;\n    var len;\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n    function getLens(b64) {\n      var len2 = b64.length;\n      if (len2 % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      }\n      var validLen = b64.indexOf(\"=\");\n      if (validLen === -1) validLen = len2;\n      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    }\n    __name(getLens, \"getLens\");\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    __name(byteLength, \"byteLength\");\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    __name(_byteLength, \"_byteLength\");\n    function toByteArray(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0;\n      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i2;\n      for (i2 = 0; i2 < len2; i2 += 4) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      return arr;\n    }\n    __name(toByteArray, \"toByteArray\");\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n    }\n    __name(tripletToBase64, \"tripletToBase64\");\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n      for (var i2 = start; i2 < end; i2 += 3) {\n        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n        output.push(tripletToBase64(tmp));\n      }\n      return output.join(\"\");\n    }\n    __name(encodeChunk, \"encodeChunk\");\n    function fromByteArray(uint8) {\n      var tmp;\n      var len2 = uint8.length;\n      var extraBytes = len2 % 3;\n      var parts = [];\n      var maxChunkLength = 16383;\n      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n      }\n      if (extraBytes === 1) {\n        tmp = uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n        );\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n        );\n      }\n      return parts.join(\"\");\n    }\n    __name(fromByteArray, \"fromByteArray\");\n  }\n});\n\n// ../../node_modules/ieee754/index.js\nvar require_ieee754 = __commonJS({\n  \"../../node_modules/ieee754/index.js\"(exports) {\n    init_process_shim();\n    exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n      var e, m;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? nBytes - 1 : 0;\n      var d = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n      i += d;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n    };\n    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m, c;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE ? 0 : nBytes - 1;\n      var d = isLE ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n      }\n      e = e << mLen | m;\n      eLen += mLen;\n      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n      }\n      buffer[offset + i - d] |= s * 128;\n    };\n  }\n});\n\n// ../../node_modules/buffer/index.js\nvar require_buffer = __commonJS({\n  \"../../node_modules/buffer/index.js\"(exports) {\n    \"use strict\";\n    init_process_shim();\n    var base64 = require_base64_js();\n    var ieee754 = require_ieee754();\n    var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n    exports.Buffer = Buffer4;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    var K_MAX_LENGTH = 2147483647;\n    exports.kMaxLength = K_MAX_LENGTH;\n    Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();\n    if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\n        \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n      );\n    }\n    function typedArraySupport() {\n      try {\n        const arr = new Uint8Array(1);\n        const proto = { foo: /* @__PURE__ */ __name(function() {\n          return 42;\n        }, \"foo\") };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n      } catch (e) {\n        return false;\n      }\n    }\n    __name(typedArraySupport, \"typedArraySupport\");\n    Object.defineProperty(Buffer4.prototype, \"parent\", {\n      enumerable: true,\n      get: /* @__PURE__ */ __name(function() {\n        if (!Buffer4.isBuffer(this)) return void 0;\n        return this.buffer;\n      }, \"get\")\n    });\n    Object.defineProperty(Buffer4.prototype, \"offset\", {\n      enumerable: true,\n      get: /* @__PURE__ */ __name(function() {\n        if (!Buffer4.isBuffer(this)) return void 0;\n        return this.byteOffset;\n      }, \"get\")\n    });\n    function createBuffer(length) {\n      if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n      }\n      const buf = new Uint8Array(length);\n      Object.setPrototypeOf(buf, Buffer4.prototype);\n      return buf;\n    }\n    __name(createBuffer, \"createBuffer\");\n    function Buffer4(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number'\n          );\n        }\n        return allocUnsafe(arg);\n      }\n      return from(arg, encodingOrOffset, length);\n    }\n    __name(Buffer4, \"Buffer\");\n    Buffer4.poolSize = 8192;\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\") {\n        return fromString2(value, encodingOrOffset);\n      }\n      if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n      }\n      if (value == null) {\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof value === \"number\") {\n        throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number'\n        );\n      }\n      const valueOf = value.valueOf && value.valueOf();\n      if (valueOf != null && valueOf !== value) {\n        return Buffer4.from(valueOf, encodingOrOffset, length);\n      }\n      const b = fromObject(value);\n      if (b) return b;\n      if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer4.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n      }\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n      );\n    }\n    __name(from, \"from\");\n    Buffer4.from = function(value, encodingOrOffset, length) {\n      return from(value, encodingOrOffset, length);\n    };\n    Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);\n    Object.setPrototypeOf(Buffer4, Uint8Array);\n    function assertSize(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n      } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      }\n    }\n    __name(assertSize, \"assertSize\");\n    function alloc(size, fill, encoding) {\n      assertSize(size);\n      if (size <= 0) {\n        return createBuffer(size);\n      }\n      if (fill !== void 0) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n      }\n      return createBuffer(size);\n    }\n    __name(alloc, \"alloc\");\n    Buffer4.alloc = function(size, fill, encoding) {\n      return alloc(size, fill, encoding);\n    };\n    function allocUnsafe(size) {\n      assertSize(size);\n      return createBuffer(size < 0 ? 0 : checked(size) | 0);\n    }\n    __name(allocUnsafe, \"allocUnsafe\");\n    Buffer4.allocUnsafe = function(size) {\n      return allocUnsafe(size);\n    };\n    Buffer4.allocUnsafeSlow = function(size) {\n      return allocUnsafe(size);\n    };\n    function fromString2(string, encoding) {\n      if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n      }\n      if (!Buffer4.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      const length = byteLength(string, encoding) | 0;\n      let buf = createBuffer(length);\n      const actual = buf.write(string, encoding);\n      if (actual !== length) {\n        buf = buf.slice(0, actual);\n      }\n      return buf;\n    }\n    __name(fromString2, \"fromString\");\n    function fromArrayLike(array) {\n      const length = array.length < 0 ? 0 : checked(array.length) | 0;\n      const buf = createBuffer(length);\n      for (let i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n      }\n      return buf;\n    }\n    __name(fromArrayLike, \"fromArrayLike\");\n    function fromArrayView(arrayView) {\n      if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n      }\n      return fromArrayLike(arrayView);\n    }\n    __name(fromArrayView, \"fromArrayView\");\n    function fromArrayBuffer(array, byteOffset, length) {\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      }\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      }\n      let buf;\n      if (byteOffset === void 0 && length === void 0) {\n        buf = new Uint8Array(array);\n      } else if (length === void 0) {\n        buf = new Uint8Array(array, byteOffset);\n      } else {\n        buf = new Uint8Array(array, byteOffset, length);\n      }\n      Object.setPrototypeOf(buf, Buffer4.prototype);\n      return buf;\n    }\n    __name(fromArrayBuffer, \"fromArrayBuffer\");\n    function fromObject(obj) {\n      if (Buffer4.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = createBuffer(len);\n        if (buf.length === 0) {\n          return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n      }\n      if (obj.length !== void 0) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n          return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n      }\n      if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n      }\n    }\n    __name(fromObject, \"fromObject\");\n    function checked(length) {\n      if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n      }\n      return length | 0;\n    }\n    __name(checked, \"checked\");\n    function SlowBuffer(length) {\n      if (+length != length) {\n        length = 0;\n      }\n      return Buffer4.alloc(+length);\n    }\n    __name(SlowBuffer, \"SlowBuffer\");\n    Buffer4.isBuffer = /* @__PURE__ */ __name(function isBuffer2(b) {\n      return b != null && b._isBuffer === true && b !== Buffer4.prototype;\n    }, \"isBuffer\");\n    Buffer4.compare = /* @__PURE__ */ __name(function compare2(a, b) {\n      if (isInstance(a, Uint8Array)) a = Buffer4.from(a, a.offset, a.byteLength);\n      if (isInstance(b, Uint8Array)) b = Buffer4.from(b, b.offset, b.byteLength);\n      if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b)) {\n        throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n        );\n      }\n      if (a === b) return 0;\n      let x = a.length;\n      let y = b.length;\n      for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n          x = a[i];\n          y = b[i];\n          break;\n        }\n      }\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    }, \"compare\");\n    Buffer4.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return true;\n        default:\n          return false;\n      }\n    }, \"isEncoding\");\n    Buffer4.concat = /* @__PURE__ */ __name(function concat(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n      if (list.length === 0) {\n        return Buffer4.alloc(0);\n      }\n      let i;\n      if (length === void 0) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n      const buffer = Buffer4.allocUnsafe(length);\n      let pos = 0;\n      for (i = 0; i < list.length; ++i) {\n        let buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n          if (pos + buf.length > buffer.length) {\n            if (!Buffer4.isBuffer(buf)) buf = Buffer4.from(buf);\n            buf.copy(buffer, pos);\n          } else {\n            Uint8Array.prototype.set.call(\n              buffer,\n              buf,\n              pos\n            );\n          }\n        } else if (!Buffer4.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n          buf.copy(buffer, pos);\n        }\n        pos += buf.length;\n      }\n      return buffer;\n    }, \"concat\");\n    function byteLength(string, encoding) {\n      if (Buffer4.isBuffer(string)) {\n        return string.length;\n      }\n      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n      }\n      if (typeof string !== \"string\") {\n        throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n        );\n      }\n      const len = string.length;\n      const mustMatch = arguments.length > 2 && arguments[2] === true;\n      if (!mustMatch && len === 0) return 0;\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes(string).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n          case \"hex\":\n            return len >>> 1;\n          case \"base64\":\n            return base64ToBytes(string).length;\n          default:\n            if (loweredCase) {\n              return mustMatch ? -1 : utf8ToBytes(string).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    __name(byteLength, \"byteLength\");\n    Buffer4.byteLength = byteLength;\n    function slowToString(encoding, start, end) {\n      let loweredCase = false;\n      if (start === void 0 || start < 0) {\n        start = 0;\n      }\n      if (start > this.length) {\n        return \"\";\n      }\n      if (end === void 0 || end > this.length) {\n        end = this.length;\n      }\n      if (end <= 0) {\n        return \"\";\n      }\n      end >>>= 0;\n      start >>>= 0;\n      if (end <= start) {\n        return \"\";\n      }\n      if (!encoding) encoding = \"utf8\";\n      while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n          case \"base64\":\n            return base64Slice(this, start, end);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    __name(slowToString, \"slowToString\");\n    Buffer4.prototype._isBuffer = true;\n    function swap(b, n, m) {\n      const i = b[n];\n      b[n] = b[m];\n      b[m] = i;\n    }\n    __name(swap, \"swap\");\n    Buffer4.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {\n      const len = this.length;\n      if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      }\n      for (let i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n      return this;\n    }, \"swap16\");\n    Buffer4.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {\n      const len = this.length;\n      if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      }\n      for (let i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n      return this;\n    }, \"swap32\");\n    Buffer4.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {\n      const len = this.length;\n      if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      }\n      for (let i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n      return this;\n    }, \"swap64\");\n    Buffer4.prototype.toString = /* @__PURE__ */ __name(function toString3() {\n      const length = this.length;\n      if (length === 0) return \"\";\n      if (arguments.length === 0) return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    }, \"toString\");\n    Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;\n    Buffer4.prototype.equals = /* @__PURE__ */ __name(function equals2(b) {\n      if (!Buffer4.isBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n      if (this === b) return true;\n      return Buffer4.compare(this, b) === 0;\n    }, \"equals\");\n    Buffer4.prototype.inspect = /* @__PURE__ */ __name(function inspect() {\n      let str = \"\";\n      const max = exports.INSPECT_MAX_BYTES;\n      str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n      if (this.length > max) str += \" ... \";\n      return \"<Buffer \" + str + \">\";\n    }, \"inspect\");\n    if (customInspectSymbol) {\n      Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;\n    }\n    Buffer4.prototype.compare = /* @__PURE__ */ __name(function compare2(target, start, end, thisStart, thisEnd) {\n      if (isInstance(target, Uint8Array)) {\n        target = Buffer4.from(target, target.offset, target.byteLength);\n      }\n      if (!Buffer4.isBuffer(target)) {\n        throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n        );\n      }\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = target ? target.length : 0;\n      }\n      if (thisStart === void 0) {\n        thisStart = 0;\n      }\n      if (thisEnd === void 0) {\n        thisEnd = this.length;\n      }\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n      }\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n      if (start >= end) {\n        return 1;\n      }\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target) return 0;\n      let x = thisEnd - thisStart;\n      let y = end - start;\n      const len = Math.min(x, y);\n      const thisCopy = this.slice(thisStart, thisEnd);\n      const targetCopy = target.slice(start, end);\n      for (let i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x = thisCopy[i];\n          y = targetCopy[i];\n          break;\n        }\n      }\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    }, \"compare\");\n    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n      if (buffer.length === 0) return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n      } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n      }\n      byteOffset = +byteOffset;\n      if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n      }\n      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n      if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n      }\n      if (typeof val === \"string\") {\n        val = Buffer4.from(val, encoding);\n      }\n      if (Buffer4.isBuffer(val)) {\n        if (val.length === 0) {\n          return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n          }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n      }\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    __name(bidirectionalIndexOf, \"bidirectionalIndexOf\");\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      let indexSize = 1;\n      let arrLength = arr.length;\n      let valLength = val.length;\n      if (encoding !== void 0) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n      function read(buf, i2) {\n        if (indexSize === 1) {\n          return buf[i2];\n        } else {\n          return buf.readUInt16BE(i2 * indexSize);\n        }\n      }\n      __name(read, \"read\");\n      let i;\n      if (dir) {\n        let foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n          let found = true;\n          for (let j = 0; j < valLength; j++) {\n            if (read(arr, i + j) !== read(val, j)) {\n              found = false;\n              break;\n            }\n          }\n          if (found) return i;\n        }\n      }\n      return -1;\n    }\n    __name(arrayIndexOf, \"arrayIndexOf\");\n    Buffer4.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    }, \"includes\");\n    Buffer4.prototype.indexOf = /* @__PURE__ */ __name(function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    }, \"indexOf\");\n    Buffer4.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    }, \"lastIndexOf\");\n    function hexWrite(buf, string, offset, length) {\n      offset = Number(offset) || 0;\n      const remaining = buf.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      const strLen = string.length;\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n      let i;\n      for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n      }\n      return i;\n    }\n    __name(hexWrite, \"hexWrite\");\n    function utf8Write(buf, string, offset, length) {\n      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    __name(utf8Write, \"utf8Write\");\n    function asciiWrite(buf, string, offset, length) {\n      return blitBuffer(asciiToBytes(string), buf, offset, length);\n    }\n    __name(asciiWrite, \"asciiWrite\");\n    function base64Write(buf, string, offset, length) {\n      return blitBuffer(base64ToBytes(string), buf, offset, length);\n    }\n    __name(base64Write, \"base64Write\");\n    function ucs2Write(buf, string, offset, length) {\n      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    __name(ucs2Write, \"ucs2Write\");\n    Buffer4.prototype.write = /* @__PURE__ */ __name(function write(string, offset, length, encoding) {\n      if (offset === void 0) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n      } else if (length === void 0 && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n      } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n          length = length >>> 0;\n          if (encoding === void 0) encoding = \"utf8\";\n        } else {\n          encoding = length;\n          length = void 0;\n        }\n      } else {\n        throw new Error(\n          \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n        );\n      }\n      const remaining = this.length - offset;\n      if (length === void 0 || length > remaining) length = remaining;\n      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      }\n      if (!encoding) encoding = \"utf8\";\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"hex\":\n            return hexWrite(this, string, offset, length);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Write(this, string, offset, length);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return asciiWrite(this, string, offset, length);\n          case \"base64\":\n            return base64Write(this, string, offset, length);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return ucs2Write(this, string, offset, length);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }, \"write\");\n    Buffer4.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    }, \"toJSON\");\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n    __name(base64Slice, \"base64Slice\");\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      const res = [];\n      let i = start;\n      while (i < end) {\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          let secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 128) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 192) === 128) {\n                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                if (tempCodePoint > 127) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          codePoint = 65533;\n          bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n          codePoint -= 65536;\n          res.push(codePoint >>> 10 & 1023 | 55296);\n          codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      return decodeCodePointsArray(res);\n    }\n    __name(utf8Slice, \"utf8Slice\");\n    var MAX_ARGUMENTS_LENGTH = 4096;\n    function decodeCodePointsArray(codePoints) {\n      const len = codePoints.length;\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n      }\n      let res = \"\";\n      let i = 0;\n      while (i < len) {\n        res += String.fromCharCode.apply(\n          String,\n          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n        );\n      }\n      return res;\n    }\n    __name(decodeCodePointsArray, \"decodeCodePointsArray\");\n    function asciiSlice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n      }\n      return ret;\n    }\n    __name(asciiSlice, \"asciiSlice\");\n    function latin1Slice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n      return ret;\n    }\n    __name(latin1Slice, \"latin1Slice\");\n    function hexSlice(buf, start, end) {\n      const len = buf.length;\n      if (!start || start < 0) start = 0;\n      if (!end || end < 0 || end > len) end = len;\n      let out = \"\";\n      for (let i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n      }\n      return out;\n    }\n    __name(hexSlice, \"hexSlice\");\n    function utf16leSlice(buf, start, end) {\n      const bytes = buf.slice(start, end);\n      let res = \"\";\n      for (let i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n      return res;\n    }\n    __name(utf16leSlice, \"utf16leSlice\");\n    Buffer4.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {\n      const len = this.length;\n      start = ~~start;\n      end = end === void 0 ? len : ~~end;\n      if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n      if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n      if (end < start) end = start;\n      const newBuf = this.subarray(start, end);\n      Object.setPrototypeOf(newBuf, Buffer4.prototype);\n      return newBuf;\n    }, \"slice\");\n    function checkOffset(offset, ext, length) {\n      if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n      if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    __name(checkOffset, \"checkOffset\");\n    Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      return val;\n    }, \"readUIntLE\");\n    Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        checkOffset(offset, byteLength2, this.length);\n      }\n      let val = this[offset + --byteLength2];\n      let mul = 1;\n      while (byteLength2 > 0 && (mul *= 256)) {\n        val += this[offset + --byteLength2] * mul;\n      }\n      return val;\n    }, \"readUIntBE\");\n    Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      return this[offset];\n    }, \"readUInt8\");\n    Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] | this[offset + 1] << 8;\n    }, \"readUInt16LE\");\n    Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] << 8 | this[offset + 1];\n    }, \"readUInt16BE\");\n    Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n    }, \"readUInt32LE\");\n    Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n    }, \"readUInt32BE\");\n    Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n      return BigInt(lo) + (BigInt(hi) << BigInt(32));\n    }, \"readBigUInt64LE\"));\n    Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n      return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    }, \"readBigUInt64BE\"));\n    Buffer4.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    }, \"readIntLE\");\n    Buffer4.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let i = byteLength2;\n      let mul = 1;\n      let val = this[offset + --i];\n      while (i > 0 && (mul *= 256)) {\n        val += this[offset + --i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    }, \"readIntBE\");\n    Buffer4.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      if (!(this[offset] & 128)) return this[offset];\n      return (255 - this[offset] + 1) * -1;\n    }, \"readInt8\");\n    Buffer4.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      const val = this[offset] | this[offset + 1] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    }, \"readInt16LE\");\n    Buffer4.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      const val = this[offset + 1] | this[offset] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    }, \"readInt16BE\");\n    Buffer4.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n    }, \"readInt32LE\");\n    Buffer4.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n    }, \"readInt32BE\");\n    Buffer4.prototype.readBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n    }, \"readBigInt64LE\"));\n    Buffer4.prototype.readBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = (first << 24) + // Overflow\n      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n    }, \"readBigInt64BE\"));\n    Buffer4.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, true, 23, 4);\n    }, \"readFloatLE\");\n    Buffer4.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, false, 23, 4);\n    }, \"readFloatBE\");\n    Buffer4.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, true, 52, 8);\n    }, \"readDoubleLE\");\n    Buffer4.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, false, 52, 8);\n    }, \"readDoubleBE\");\n    function checkInt(buf, value, offset, ext, max, min) {\n      if (!Buffer4.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    }\n    __name(checkInt, \"checkInt\");\n    Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let mul = 1;\n      let i = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    }, \"writeUIntLE\");\n    Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    }, \"writeUIntBE\");\n    Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);\n      this[offset] = value & 255;\n      return offset + 1;\n    }, \"writeUInt8\");\n    Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    }, \"writeUInt16LE\");\n    Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    }, \"writeUInt16BE\");\n    Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset + 3] = value >>> 24;\n      this[offset + 2] = value >>> 16;\n      this[offset + 1] = value >>> 8;\n      this[offset] = value & 255;\n      return offset + 4;\n    }, \"writeUInt32LE\");\n    Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    }, \"writeUInt32BE\");\n    function wrtBigUInt64LE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      return offset;\n    }\n    __name(wrtBigUInt64LE, \"wrtBigUInt64LE\");\n    function wrtBigUInt64BE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset + 7] = lo;\n      lo = lo >> 8;\n      buf[offset + 6] = lo;\n      lo = lo >> 8;\n      buf[offset + 5] = lo;\n      lo = lo >> 8;\n      buf[offset + 4] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset + 3] = hi;\n      hi = hi >> 8;\n      buf[offset + 2] = hi;\n      hi = hi >> 8;\n      buf[offset + 1] = hi;\n      hi = hi >> 8;\n      buf[offset] = hi;\n      return offset + 8;\n    }\n    __name(wrtBigUInt64BE, \"wrtBigUInt64BE\");\n    Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    }, \"writeBigUInt64LE\"));\n    Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    }, \"writeBigUInt64BE\"));\n    Buffer4.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = 0;\n      let mul = 1;\n      let sub = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    }, \"writeIntLE\");\n    Buffer4.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      let sub = 0;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    }, \"writeIntBE\");\n    Buffer4.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);\n      if (value < 0) value = 255 + value + 1;\n      this[offset] = value & 255;\n      return offset + 1;\n    }, \"writeInt8\");\n    Buffer4.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    }, \"writeInt16LE\");\n    Buffer4.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    }, \"writeInt16BE\");\n    Buffer4.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      this[offset + 2] = value >>> 16;\n      this[offset + 3] = value >>> 24;\n      return offset + 4;\n    }, \"writeInt32LE\");\n    Buffer4.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      if (value < 0) value = 4294967295 + value + 1;\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    }, \"writeInt32BE\");\n    Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    }, \"writeBigInt64LE\"));\n    Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    }, \"writeBigInt64BE\"));\n    function checkIEEE754(buf, value, offset, ext, max, min) {\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n      if (offset < 0) throw new RangeError(\"Index out of range\");\n    }\n    __name(checkIEEE754, \"checkIEEE754\");\n    function writeFloat(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      return offset + 4;\n    }\n    __name(writeFloat, \"writeFloat\");\n    Buffer4.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, true, noAssert);\n    }, \"writeFloatLE\");\n    Buffer4.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, false, noAssert);\n    }, \"writeFloatBE\");\n    function writeDouble(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      return offset + 8;\n    }\n    __name(writeDouble, \"writeDouble\");\n    Buffer4.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, true, noAssert);\n    }, \"writeDoubleLE\");\n    Buffer4.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, false, noAssert);\n    }, \"writeDoubleBE\");\n    Buffer4.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start, end) {\n      if (!Buffer4.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n      if (!start) start = 0;\n      if (!end && end !== 0) end = this.length;\n      if (targetStart >= target.length) targetStart = target.length;\n      if (!targetStart) targetStart = 0;\n      if (end > 0 && end < start) end = start;\n      if (end === start) return 0;\n      if (target.length === 0 || this.length === 0) return 0;\n      if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n      }\n      if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n      if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n      if (end > this.length) end = this.length;\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      const len = end - start;\n      if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        this.copyWithin(targetStart, start, end);\n      } else {\n        Uint8Array.prototype.set.call(\n          target,\n          this.subarray(start, end),\n          targetStart\n        );\n      }\n      return len;\n    }, \"copy\");\n    Buffer4.prototype.fill = /* @__PURE__ */ __name(function fill(val, start, end, encoding) {\n      if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = this.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer4.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n          const code = val.charCodeAt(0);\n          if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n            val = code;\n          }\n        }\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n      } else if (typeof val === \"boolean\") {\n        val = Number(val);\n      }\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return this;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? this.length : end >>> 0;\n      if (!val) val = 0;\n      let i;\n      if (typeof val === \"number\") {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) {\n          throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n      return this;\n    }, \"fill\");\n    var errors = {};\n    function E(sym, getMessage, Base) {\n      errors[sym] = class NodeError extends Base {\n        static {\n          __name(this, \"NodeError\");\n        }\n        constructor() {\n          super();\n          Object.defineProperty(this, \"message\", {\n            value: getMessage.apply(this, arguments),\n            writable: true,\n            configurable: true\n          });\n          this.name = `${this.name} [${sym}]`;\n          this.stack;\n          delete this.name;\n        }\n        get code() {\n          return sym;\n        }\n        set code(value) {\n          Object.defineProperty(this, \"code\", {\n            configurable: true,\n            enumerable: true,\n            value,\n            writable: true\n          });\n        }\n        toString() {\n          return `${this.name} [${sym}]: ${this.message}`;\n        }\n      };\n    }\n    __name(E, \"E\");\n    E(\n      \"ERR_BUFFER_OUT_OF_BOUNDS\",\n      function(name) {\n        if (name) {\n          return `${name} is outside of buffer bounds`;\n        }\n        return \"Attempt to access memory outside buffer bounds\";\n      },\n      RangeError\n    );\n    E(\n      \"ERR_INVALID_ARG_TYPE\",\n      function(name, actual) {\n        return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n      },\n      TypeError\n    );\n    E(\n      \"ERR_OUT_OF_RANGE\",\n      function(str, range, input) {\n        let msg = `The value of \"${str}\" is out of range.`;\n        let received = input;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        }\n        msg += ` It must be ${range}. Received ${received}`;\n        return msg;\n      },\n      RangeError\n    );\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    __name(addNumericalSeparator, \"addNumericalSeparator\");\n    function checkBounds(buf, offset, byteLength2) {\n      validateNumber(offset, \"offset\");\n      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n        boundsError(offset, buf.length - (byteLength2 + 1));\n      }\n    }\n    __name(checkBounds, \"checkBounds\");\n    function checkIntBI(value, min, max, buf, offset, byteLength2) {\n      if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength2 > 3) {\n          if (min === 0 || min === BigInt(0)) {\n            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n          } else {\n            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n          }\n        } else {\n          range = `>= ${min}${n} and <= ${max}${n}`;\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n      }\n      checkBounds(buf, offset, byteLength2);\n    }\n    __name(checkIntBI, \"checkIntBI\");\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n    }\n    __name(validateNumber, \"validateNumber\");\n    function boundsError(value, length, type) {\n      if (Math.floor(value) !== value) {\n        validateNumber(value, type);\n        throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n      }\n      if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n      }\n      throw new errors.ERR_OUT_OF_RANGE(\n        type || \"offset\",\n        `>= ${type ? 1 : 0} and <= ${length}`,\n        value\n      );\n    }\n    __name(boundsError, \"boundsError\");\n    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n    function base64clean(str) {\n      str = str.split(\"=\")[0];\n      str = str.trim().replace(INVALID_BASE64_RE, \"\");\n      if (str.length < 2) return \"\";\n      while (str.length % 4 !== 0) {\n        str = str + \"=\";\n      }\n      return str;\n    }\n    __name(base64clean, \"base64clean\");\n    function utf8ToBytes(string, units) {\n      units = units || Infinity;\n      let codePoint;\n      const length = string.length;\n      let leadSurrogate = null;\n      const bytes = [];\n      for (let i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n          if (!leadSurrogate) {\n            if (codePoint > 56319) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            } else if (i + 1 === length) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            }\n            leadSurrogate = codePoint;\n            continue;\n          }\n          if (codePoint < 56320) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n            leadSurrogate = codePoint;\n            continue;\n          }\n          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n          if ((units -= 1) < 0) break;\n          bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n          if ((units -= 2) < 0) break;\n          bytes.push(\n            codePoint >> 6 | 192,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 65536) {\n          if ((units -= 3) < 0) break;\n          bytes.push(\n            codePoint >> 12 | 224,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 1114112) {\n          if ((units -= 4) < 0) break;\n          bytes.push(\n            codePoint >> 18 | 240,\n            codePoint >> 12 & 63 | 128,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else {\n          throw new Error(\"Invalid code point\");\n        }\n      }\n      return bytes;\n    }\n    __name(utf8ToBytes, \"utf8ToBytes\");\n    function asciiToBytes(str) {\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        byteArray.push(str.charCodeAt(i) & 255);\n      }\n      return byteArray;\n    }\n    __name(asciiToBytes, \"asciiToBytes\");\n    function utf16leToBytes(str, units) {\n      let c, hi, lo;\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n      return byteArray;\n    }\n    __name(utf16leToBytes, \"utf16leToBytes\");\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n    __name(base64ToBytes, \"base64ToBytes\");\n    function blitBuffer(src, dst, offset, length) {\n      let i;\n      for (i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n      }\n      return i;\n    }\n    __name(blitBuffer, \"blitBuffer\");\n    function isInstance(obj, type) {\n      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n    }\n    __name(isInstance, \"isInstance\");\n    function numberIsNaN(obj) {\n      return obj !== obj;\n    }\n    __name(numberIsNaN, \"numberIsNaN\");\n    var hexSliceLookupTable = (function() {\n      const alphabet = \"0123456789abcdef\";\n      const table = new Array(256);\n      for (let i = 0; i < 16; ++i) {\n        const i16 = i * 16;\n        for (let j = 0; j < 16; ++j) {\n          table[i16 + j] = alphabet[i] + alphabet[j];\n        }\n      }\n      return table;\n    })();\n    function defineBigIntMethod(fn) {\n      return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n    }\n    __name(defineBigIntMethod, \"defineBigIntMethod\");\n    function BufferBigIntNotDefined() {\n      throw new Error(\"BigInt not supported\");\n    }\n    __name(BufferBigIntNotDefined, \"BufferBigIntNotDefined\");\n  }\n});\n\n// ../smartbuffer/dist/index.js\nvar import_buffer, EMPTY_BUFFER, _isString, isSmartBuffer, SmartBuffer;\nvar init_dist2 = __esm({\n  \"../smartbuffer/dist/index.js\"() {\n    \"use strict\";\n    init_process_shim();\n    init_long();\n    import_buffer = __toESM(require_buffer(), 1);\n    EMPTY_BUFFER = import_buffer.Buffer.allocUnsafe(0);\n    _isString = /* @__PURE__ */ __name((value) => typeof value === \"string\" || value instanceof String, \"_isString\");\n    isSmartBuffer = /* @__PURE__ */ __name((obj) => obj instanceof SmartBuffer, \"isSmartBuffer\");\n    SmartBuffer = class _SmartBuffer {\n      static {\n        __name(this, \"SmartBuffer\");\n      }\n      static {\n        this.EMPTY_BUFFER = EMPTY_BUFFER;\n      }\n      static {\n        this.DEFAULT_CAPACITY = 64;\n      }\n      static {\n        this.DEFAULT_NOASSERT = false;\n      }\n      static {\n        this.MAX_VARINT32_BYTES = 5;\n      }\n      static {\n        this.MAX_VARINT64_BYTES = 10;\n      }\n      static {\n        this.METRICS_CHARS = \"c\";\n      }\n      static {\n        this.METRICS_BYTES = \"b\";\n      }\n      constructor(capacity, noAssert = _SmartBuffer.DEFAULT_NOASSERT) {\n        this.woffset = 0;\n        this.roffset = 0;\n        let lCapacity = capacity === void 0 || Number.isNaN(capacity) ? _SmartBuffer.DEFAULT_CAPACITY : capacity;\n        if (!noAssert) {\n          lCapacity |= 0;\n          if (lCapacity < 0) {\n            throw new TypeError(\"Illegal capacity\");\n          }\n          noAssert = Boolean(noAssert);\n        }\n        this.buffer = lCapacity === 0 ? EMPTY_BUFFER : import_buffer.Buffer.allocUnsafe(lCapacity);\n        this.noAssert = noAssert;\n      }\n      get length() {\n        return this.woffset - this.roffset;\n      }\n      get capacity() {\n        return this.buffer.length;\n      }\n      readBitSet(offset) {\n        let loffset = offset ?? this.roffset;\n        const ret = this.readVarint32(loffset);\n        const bits = ret.value;\n        let bytes = bits >> 3;\n        let bit = 0;\n        const value = [];\n        let k;\n        loffset += ret.length;\n        while (bytes--) {\n          k = this.readInt8(loffset++);\n          value[bit++] = Boolean(k & 1);\n          value[bit++] = Boolean(k & 2);\n          value[bit++] = Boolean(k & 4);\n          value[bit++] = Boolean(k & 8);\n          value[bit++] = Boolean(k & 16);\n          value[bit++] = Boolean(k & 32);\n          value[bit++] = Boolean(k & 64);\n          value[bit++] = Boolean(k & 128);\n        }\n        if (bit < bits) {\n          let m = 0;\n          k = this.readInt8(loffset++);\n          while (bit < bits) {\n            value[bit++] = Boolean(k >> m++ & 1);\n          }\n        }\n        if (offset === void 0) {\n          this.roffset = loffset;\n        }\n        return value;\n      }\n      read(length, offset) {\n        let loffset = offset ?? this.roffset;\n        if (!this.noAssert) {\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + length > this.buffer.length) {\n            throw new TypeError(`Illegal offset: 0 <= ${loffset} (${length}) <= ${this.buffer.length}`);\n          }\n        }\n        const slice = this.slice(offset, loffset + length);\n        if (offset === void 0) {\n          this.roffset += length;\n        }\n        return slice;\n      }\n      readInt8(offset) {\n        const loffset = this._checkRead(1, offset);\n        let value = this.buffer[loffset];\n        if ((value & 128) === 128) {\n          value = -(255 - value + 1);\n        }\n        return value;\n      }\n      readUInt8(offset) {\n        const loffset = this._checkRead(1, offset);\n        return this.buffer[loffset];\n      }\n      readInt16LE(offset) {\n        const loffset = this._checkRead(2, offset);\n        let value = 0;\n        value = this.buffer[loffset];\n        value |= this.buffer[loffset + 1] << 8;\n        if ((value & 32768) === 32768) {\n          value = -(65535 - value + 1);\n        }\n        return value;\n      }\n      readInt16BE(offset) {\n        const loffset = this._checkRead(2, offset);\n        let value = 0;\n        value = this.buffer[loffset] << 8;\n        value |= this.buffer[loffset + 1];\n        if ((value & 32768) === 32768) {\n          value = -(65535 - value + 1);\n        }\n        return value;\n      }\n      readUInt16LE(offset) {\n        const loffset = this._checkRead(2, offset);\n        let value = 0;\n        value = this.buffer[loffset];\n        value |= this.buffer[loffset + 1] << 8;\n        return value;\n      }\n      readUInt16BE(offset) {\n        const loffset = this._checkRead(2, offset);\n        let value = 0;\n        value = this.buffer[loffset] << 8;\n        value |= this.buffer[loffset + 1];\n        return value;\n      }\n      readUInt24BE(offset) {\n        const loffset = this._checkRead(3, offset);\n        let value = 0;\n        value = this.buffer[loffset] << 16;\n        value |= this.buffer[loffset + 1] << 8;\n        value |= this.buffer[loffset + 2];\n        value |= 0;\n        return value;\n      }\n      readInt32LE(offset) {\n        const loffset = this._checkRead(4, offset);\n        let value = 0;\n        value = this.buffer[loffset + 2] << 16;\n        value |= this.buffer[loffset + 1] << 8;\n        value |= this.buffer[loffset];\n        value += this.buffer[loffset + 3] << 24 >>> 0;\n        value |= 0;\n        return value;\n      }\n      readInt32BE(offset) {\n        const loffset = this._checkRead(4, offset);\n        let value = 0;\n        value = this.buffer[loffset + 1] << 16;\n        value |= this.buffer[loffset + 2] << 8;\n        value |= this.buffer[loffset + 3];\n        value += this.buffer[loffset] << 24 >>> 0;\n        value |= 0;\n        return value;\n      }\n      readUInt32LE(offset) {\n        const loffset = this._checkRead(4, offset);\n        let value = 0;\n        value = this.buffer[loffset + 2] << 16;\n        value |= this.buffer[loffset + 1] << 8;\n        value |= this.buffer[loffset];\n        value += this.buffer[loffset + 3] << 24 >>> 0;\n        return value;\n      }\n      readUInt32BE(offset) {\n        const loffset = this._checkRead(4, offset);\n        let value = 0;\n        value = this.buffer[loffset + 1] << 16;\n        value |= this.buffer[loffset + 2] << 8;\n        value |= this.buffer[loffset + 3];\n        value += this.buffer[loffset] << 24 >>> 0;\n        return value;\n      }\n      readInt64LE(offset) {\n        const loffset = this._checkRead(8, offset);\n        let lo = 0;\n        let hi = 0;\n        lo = this.buffer[loffset + 2] << 16;\n        lo |= this.buffer[loffset + 1] << 8;\n        lo |= this.buffer[loffset];\n        lo += this.buffer[loffset + 3] << 24 >>> 0;\n        hi = this.buffer[loffset + 6] << 16;\n        hi |= this.buffer[loffset + 5] << 8;\n        hi |= this.buffer[loffset + 4];\n        hi += this.buffer[loffset + 7] << 24 >>> 0;\n        return new long_default(lo, hi, false);\n      }\n      readInt64BE(offset) {\n        const loffset = this._checkRead(8, offset);\n        let lo = 0;\n        let hi = 0;\n        hi = this.buffer[loffset + 1] << 16;\n        hi |= this.buffer[loffset + 2] << 8;\n        hi |= this.buffer[loffset + 3];\n        hi += this.buffer[loffset] << 24 >>> 0;\n        lo = this.buffer[loffset + 5] << 16;\n        lo |= this.buffer[loffset + 6] << 8;\n        lo |= this.buffer[loffset + 7];\n        lo += this.buffer[loffset + 4] << 24 >>> 0;\n        return new long_default(lo, hi, false);\n      }\n      readUInt64LE(offset) {\n        const loffset = this._checkRead(8, offset);\n        let lo = 0;\n        let hi = 0;\n        lo = this.buffer[loffset + 2] << 16;\n        lo |= this.buffer[loffset + 1] << 8;\n        lo |= this.buffer[loffset];\n        lo += this.buffer[loffset + 3] << 24 >>> 0;\n        hi = this.buffer[loffset + 6] << 16;\n        hi |= this.buffer[loffset + 5] << 8;\n        hi |= this.buffer[loffset + 4];\n        hi += this.buffer[loffset + 7] << 24 >>> 0;\n        return new long_default(lo, hi, true);\n      }\n      readUInt64BE(offset) {\n        const loffset = this._checkRead(8, offset);\n        let lo = 0;\n        let hi = 0;\n        hi = this.buffer[loffset + 1] << 16;\n        hi |= this.buffer[loffset + 2] << 8;\n        hi |= this.buffer[loffset + 3];\n        hi += this.buffer[loffset] << 24 >>> 0;\n        lo = this.buffer[loffset + 5] << 16;\n        lo |= this.buffer[loffset + 6] << 8;\n        lo |= this.buffer[loffset + 7];\n        lo += this.buffer[loffset + 4] << 24 >>> 0;\n        return new long_default(lo, hi, true);\n      }\n      readBigIntBE(offset) {\n        const loffset = this._checkRead(8, offset);\n        let value = BigInt(this.buffer[loffset]) << 56n | BigInt(this.buffer[loffset + 1]) << 48n | BigInt(this.buffer[loffset + 2]) << 40n | BigInt(this.buffer[loffset + 3]) << 32n | BigInt(this.buffer[loffset + 4]) << 24n | BigInt(this.buffer[loffset + 5]) << 16n | BigInt(this.buffer[loffset + 6]) << 8n | BigInt(this.buffer[loffset + 7]);\n        if (value & 1n << 63n) {\n          value -= 1n << 64n;\n        }\n        return value;\n      }\n      readUBigIntBE(offset) {\n        const loffset = this._checkRead(8, offset);\n        const value = BigInt(this.buffer[loffset]) << 56n | BigInt(this.buffer[loffset + 1]) << 48n | BigInt(this.buffer[loffset + 2]) << 40n | BigInt(this.buffer[loffset + 3]) << 32n | BigInt(this.buffer[loffset + 4]) << 24n | BigInt(this.buffer[loffset + 5]) << 16n | BigInt(this.buffer[loffset + 6]) << 8n | BigInt(this.buffer[loffset + 7]);\n        return value;\n      }\n      readBigIntLE(offset) {\n        const loffset = this._checkRead(8, offset);\n        let value = BigInt(this.buffer[loffset]) << 0n | BigInt(this.buffer[loffset + 1]) << 8n | BigInt(this.buffer[loffset + 2]) << 16n | BigInt(this.buffer[loffset + 3]) << 24n | BigInt(this.buffer[loffset + 4]) << 32n | BigInt(this.buffer[loffset + 5]) << 40n | BigInt(this.buffer[loffset + 6]) << 48n | BigInt(this.buffer[loffset + 7]) << 56n;\n        if (value & 1n << 63n) {\n          value -= 1n << 64n;\n        }\n        return value;\n      }\n      readUBigIntLE(offset) {\n        const loffset = this._checkRead(8, offset);\n        const value = BigInt(this.buffer[loffset + 7]) << 56n | BigInt(this.buffer[loffset + 6]) << 48n | BigInt(this.buffer[loffset + 5]) << 40n | BigInt(this.buffer[loffset + 4]) << 32n | BigInt(this.buffer[loffset + 3]) << 24n | BigInt(this.buffer[loffset + 2]) << 16n | BigInt(this.buffer[loffset + 1]) << 8n | BigInt(this.buffer[loffset]);\n        return value;\n      }\n      readFloatLE(offset) {\n        const loffset = this._checkRead(4, offset);\n        return this.buffer.readFloatLE(loffset);\n      }\n      readFloatBE(offset) {\n        const loffset = this._checkRead(4, offset);\n        return this.buffer.readFloatBE(loffset);\n      }\n      readDoubleLE(offset) {\n        const loffset = this._checkRead(8, offset);\n        return this.buffer.readDoubleLE(loffset);\n      }\n      readDoubleBE(offset) {\n        const loffset = this._checkRead(8, offset);\n        return this.buffer.readDoubleBE(loffset);\n      }\n      write(source, offset, length, encoding = \"utf8\") {\n        let loffset = offset === void 0 ? this.woffset : offset;\n        const result = loffset >>> 0;\n        if (!this.noAssert) {\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        let llength;\n        const isString2 = _isString(source);\n        if (isString2) {\n          llength = length || import_buffer.Buffer.byteLength(source);\n        } else {\n          if (!(source instanceof _SmartBuffer)) {\n            source = _SmartBuffer.wrap(source, encoding);\n          }\n          llength = source.woffset - source.roffset;\n        }\n        if (llength <= 0) {\n          return this;\n        }\n        loffset += llength;\n        let capacity = this.buffer.length;\n        if (loffset > capacity) {\n          this.resize((capacity *= 2) > loffset ? capacity : loffset);\n        }\n        if (isString2) {\n          this.buffer.write(source, result);\n        } else {\n          source.buffer.copy(this.buffer, result, source.roffset, source.woffset);\n          source.roffset += llength;\n        }\n        if (offset === void 0) {\n          this.woffset += llength;\n        }\n        return this;\n      }\n      writeBitSet(value, offset) {\n        let loffset = offset ?? this.woffset;\n        if (!this.noAssert) {\n          if (!Array.isArray(value)) {\n            throw new TypeError(\"Illegal BitSet: Not an array\");\n          }\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        const start = loffset;\n        const bits = value.length;\n        let bytes = bits >> 3;\n        let bit = 0;\n        let k;\n        loffset += this.writeVarint32(bits, loffset);\n        while (bytes--) {\n          k = !!value[bit++] & 1 | !!value[bit++] << 1 | !!value[bit++] << 2 | !!value[bit++] << 3 | !!value[bit++] << 4 | !!value[bit++] << 5 | !!value[bit++] << 6 | !!value[bit++] << 7;\n          this.writeInt8(k, loffset++);\n        }\n        if (bit < bits) {\n          let m = 0;\n          k = 0;\n          while (bit < bits) {\n            k = k | !!value[bit++] << m++;\n          }\n          this.writeInt8(k, loffset++);\n        }\n        if (offset === void 0) {\n          this.woffset = loffset;\n          return this;\n        }\n        return loffset - start;\n      }\n      writeBuffer(buf, offset) {\n        if (buf.length === 0) {\n          return this;\n        }\n        const relative = offset === void 0;\n        const loffset = relative ? this.woffset : offset;\n        const targetEnd = loffset + buf.length;\n        let capacity = this.buffer.length;\n        if (targetEnd > capacity) {\n          capacity *= 2;\n          this.resize(capacity > targetEnd ? capacity : targetEnd);\n        }\n        buf.copy(this.buffer, loffset);\n        if (relative) {\n          this.woffset = targetEnd;\n        }\n        return this;\n      }\n      writeInt8(value, offset) {\n        const iValue = value | 0;\n        const loffset = this._checkWrite(iValue, 1, offset);\n        this.buffer[loffset] = iValue;\n        return this;\n      }\n      writeUInt8(value, offset) {\n        const uValue = value >>> 0;\n        const loffset = this._checkWrite(uValue, 1, offset);\n        this.buffer[loffset] = uValue;\n        return this;\n      }\n      writeInt16LE(value, offset) {\n        const iValue = value | 0;\n        const loffset = this._checkWrite(iValue, 2, offset);\n        this.buffer[loffset + 1] = iValue >>> 8;\n        this.buffer[loffset] = iValue;\n        return this;\n      }\n      writeInt16BE(value, offset) {\n        const iValue = value | 0;\n        const loffset = this._checkWrite(iValue, 2, offset);\n        this.buffer[loffset] = iValue >>> 8;\n        this.buffer[loffset + 1] = iValue;\n        return this;\n      }\n      writeUInt16LE(value, offset) {\n        const uValue = value >>> 0;\n        const loffset = this._checkWrite(uValue, 2, offset);\n        this.buffer[loffset + 1] = uValue >>> 8;\n        this.buffer[loffset] = uValue;\n        return this;\n      }\n      writeUInt16BE(value, offset) {\n        const uValue = value >>> 0;\n        const loffset = this._checkWrite(uValue, 2, offset);\n        this.buffer[loffset] = uValue >>> 8;\n        this.buffer[loffset + 1] = uValue;\n        return this;\n      }\n      writeUInt24BE(value, offset) {\n        const uValue = value >>> 0;\n        const loffset = this._checkWrite(uValue, 3, offset);\n        this.buffer[loffset] = uValue >>> 16;\n        this.buffer[loffset + 1] = uValue >>> 8;\n        this.buffer[loffset + 2] = uValue;\n        return this;\n      }\n      writeInt32LE(value, offset) {\n        const iValue = value | 0;\n        const loffset = this._checkWrite(iValue, 4, offset);\n        this.buffer[loffset + 3] = iValue >>> 24;\n        this.buffer[loffset + 2] = iValue >>> 16;\n        this.buffer[loffset + 1] = iValue >>> 8;\n        this.buffer[loffset] = iValue;\n        return this;\n      }\n      writeInt32BE(value, offset) {\n        const iValue = value | 0;\n        const loffset = this._checkWrite(iValue, 4, offset);\n        this.buffer[loffset] = iValue >>> 24;\n        this.buffer[loffset + 1] = iValue >>> 16;\n        this.buffer[loffset + 2] = iValue >>> 8;\n        this.buffer[loffset + 3] = iValue;\n        return this;\n      }\n      writeUInt32LE(value, offset) {\n        const uValue = value >>> 0;\n        offset = this._checkWrite(uValue, 4, offset);\n        this.buffer[offset + 3] = uValue >>> 24;\n        this.buffer[offset + 2] = uValue >>> 16;\n        this.buffer[offset + 1] = uValue >>> 8;\n        this.buffer[offset] = uValue;\n        return this;\n      }\n      writeUInt32BE(value, offset) {\n        const uValue = value >>> 0;\n        offset = this._checkWrite(uValue, 4, offset);\n        this.buffer[offset] = uValue >>> 24;\n        this.buffer[offset + 1] = uValue >>> 16;\n        this.buffer[offset + 2] = uValue >>> 8;\n        this.buffer[offset + 3] = uValue;\n        return this;\n      }\n      writeInt64LE(value, offset) {\n        const [lvalue, loffset] = this._checkWriteLong(value, offset);\n        const lo = lvalue.low;\n        const hi = lvalue.high;\n        this.buffer[loffset + 3] = lo >>> 24;\n        this.buffer[loffset + 2] = lo >>> 16;\n        this.buffer[loffset + 1] = lo >>> 8;\n        this.buffer[loffset] = lo;\n        this.buffer[loffset + 7] = hi >>> 24;\n        this.buffer[loffset + 6] = hi >>> 16;\n        this.buffer[loffset + 5] = hi >>> 8;\n        this.buffer[loffset + 4] = hi;\n        return this;\n      }\n      writeInt64BE(value, offset) {\n        const [lvalue, loffset] = this._checkWriteLong(value, offset);\n        const lo = lvalue.low;\n        const hi = lvalue.high;\n        this.buffer[loffset] = hi >>> 24;\n        this.buffer[loffset + 1] = hi >>> 16;\n        this.buffer[loffset + 2] = hi >>> 8;\n        this.buffer[loffset + 3] = hi;\n        this.buffer[loffset + 4] = lo >>> 24;\n        this.buffer[loffset + 5] = lo >>> 16;\n        this.buffer[loffset + 6] = lo >>> 8;\n        this.buffer[loffset + 7] = lo;\n        return this;\n      }\n      writeUInt64LE(value, offset) {\n        const [lvalue, loffset] = this._checkWriteLong(value, offset);\n        const lo = lvalue.low;\n        const hi = lvalue.high;\n        this.buffer[loffset + 3] = lo >>> 24;\n        this.buffer[loffset + 2] = lo >>> 16;\n        this.buffer[loffset + 1] = lo >>> 8;\n        this.buffer[loffset] = lo;\n        this.buffer[loffset + 7] = hi >>> 24;\n        this.buffer[loffset + 6] = hi >>> 16;\n        this.buffer[loffset + 5] = hi >>> 8;\n        this.buffer[loffset + 4] = hi;\n        return this;\n      }\n      writeUInt64BE(value, offset) {\n        const [lvalue, loffset] = this._checkWriteLong(value, offset);\n        const lo = lvalue.low;\n        const hi = lvalue.high;\n        this.buffer[loffset] = hi >>> 24;\n        this.buffer[loffset + 1] = hi >>> 16;\n        this.buffer[loffset + 2] = hi >>> 8;\n        this.buffer[loffset + 3] = hi;\n        this.buffer[loffset + 4] = lo >>> 24;\n        this.buffer[loffset + 5] = lo >>> 16;\n        this.buffer[loffset + 6] = lo >>> 8;\n        this.buffer[loffset + 7] = lo;\n        return this;\n      }\n      writeBigIntBE(value, offset) {\n        const loffset = this._checkWrite(Number(value), 8, offset);\n        const isNegative2 = value < 0n;\n        if (isNegative2) {\n          value = (1n << 64n) + value;\n        }\n        this.buffer[loffset] = Number(BigInt(value) >> 56n & BigInt(255));\n        this.buffer[loffset + 1] = Number(BigInt(value) >> 48n & BigInt(255));\n        this.buffer[loffset + 2] = Number(BigInt(value) >> 40n & BigInt(255));\n        this.buffer[loffset + 3] = Number(BigInt(value) >> 32n & BigInt(255));\n        this.buffer[loffset + 4] = Number(BigInt(value) >> 24n & BigInt(255));\n        this.buffer[loffset + 5] = Number(BigInt(value) >> 16n & BigInt(255));\n        this.buffer[loffset + 6] = Number(BigInt(value) >> 8n & BigInt(255));\n        this.buffer[loffset + 7] = Number(BigInt(value) & BigInt(255));\n        return this;\n      }\n      writeUBigIntBE(value, offset) {\n        const loffset = this._checkWrite(Number(value), 8, offset);\n        this.buffer[loffset] = Number(BigInt(value) >> 56n & BigInt(255));\n        this.buffer[loffset + 1] = Number(BigInt(value) >> 48n & BigInt(255));\n        this.buffer[loffset + 2] = Number(BigInt(value) >> 40n & BigInt(255));\n        this.buffer[loffset + 3] = Number(BigInt(value) >> 32n & BigInt(255));\n        this.buffer[loffset + 4] = Number(BigInt(value) >> 24n & BigInt(255));\n        this.buffer[loffset + 5] = Number(BigInt(value) >> 16n & BigInt(255));\n        this.buffer[loffset + 6] = Number(BigInt(value) >> 8n & BigInt(255));\n        this.buffer[loffset + 7] = Number(BigInt(value) & BigInt(255));\n        return this;\n      }\n      writeBigIntLE(value, offset) {\n        const loffset = this._checkWrite(Number(value), 8, offset);\n        const isNegative2 = value < 0n;\n        if (isNegative2) {\n          value = (1n << 64n) + value;\n        }\n        this.buffer[loffset] = Number(value & 0xffn);\n        this.buffer[loffset + 1] = Number(BigInt(value) >> 8n & 0xffn);\n        this.buffer[loffset + 2] = Number(BigInt(value) >> 16n & 0xffn);\n        this.buffer[loffset + 3] = Number(BigInt(value) >> 24n & 0xffn);\n        this.buffer[loffset + 4] = Number(BigInt(value) >> 32n & 0xffn);\n        this.buffer[loffset + 5] = Number(BigInt(value) >> 40n & 0xffn);\n        this.buffer[loffset + 6] = Number(BigInt(value) >> 48n & 0xffn);\n        this.buffer[loffset + 7] = Number(BigInt(value) >> 56n & 0xffn);\n        return this;\n      }\n      writeUBigIntLE(value, offset) {\n        const loffset = this._checkWrite(Number(value), 8, offset);\n        this.buffer[loffset] = Number(value & 0xffn);\n        this.buffer[loffset + 1] = Number(BigInt(value) >> 8n & 0xffn);\n        this.buffer[loffset + 2] = Number(BigInt(value) >> 16n & 0xffn);\n        this.buffer[loffset + 3] = Number(BigInt(value) >> 24n & 0xffn);\n        this.buffer[loffset + 4] = Number(BigInt(value) >> 32n & 0xffn);\n        this.buffer[loffset + 5] = Number(BigInt(value) >> 40n & 0xffn);\n        this.buffer[loffset + 6] = Number(BigInt(value) >> 48n & 0xffn);\n        this.buffer[loffset + 7] = Number(BigInt(value) >> 56n & 0xffn);\n        return this;\n      }\n      writeFloatLE(value, offset) {\n        const loffset = this._checkWrite(value, 4, offset, true);\n        this.buffer.writeFloatLE(value, loffset);\n        return this;\n      }\n      writeFloatBE(value, offset) {\n        const loffset = this._checkWrite(value, 4, offset, true);\n        this.buffer.writeFloatBE(value, loffset);\n        return this;\n      }\n      writeDoubleLE(value, offset) {\n        const loffset = this._checkWrite(value, 8, offset, true);\n        this.buffer.writeDoubleLE(value, loffset);\n        return this;\n      }\n      writeDoubleBE(value, offset) {\n        const loffset = this._checkWrite(value, 8, offset, true);\n        this.buffer.writeDoubleBE(value, loffset);\n        return this;\n      }\n      _checkRead(bytes, offset) {\n        const loffset = offset ?? this.roffset;\n        if (offset === void 0) {\n          this.roffset += bytes;\n        }\n        if (!this.noAssert) {\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          if (loffset < 0 || loffset + bytes > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (${bytes}) <= ${this.buffer.length}`);\n          }\n        }\n        return loffset;\n      }\n      _checkWrite(value, bytes, offset, isFloat = false) {\n        let loffset = (offset ?? this.woffset) >>> 0;\n        if (offset === void 0) {\n          this.woffset += bytes;\n        }\n        const result = loffset >>>= 0;\n        if (!this.noAssert) {\n          if (typeof value !== \"number\" || !isFloat && value % 1 !== 0) {\n            throw new TypeError(`Illegal value: ${value} (not an integer)`);\n          }\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${offset} (not an integer)`);\n          }\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        loffset += bytes;\n        let capacity = this.buffer.length;\n        if (loffset > capacity) {\n          this.resize((capacity *= 2) > loffset ? capacity : loffset);\n        }\n        return result;\n      }\n      _checkWriteLong(value, offset) {\n        let loffset = offset ?? this.woffset;\n        if (offset === void 0) {\n          this.woffset += 8;\n        }\n        const result = loffset >>>= 0;\n        if (!this.noAssert) {\n          if (typeof value === \"number\") {\n            value = long_default.fromNumber(value);\n          } else if (_isString(value)) {\n            value = long_default.fromString(value);\n          } else if (!(typeof value === \"object\" && value instanceof long_default)) {\n            throw new TypeError(`Illegal value: ${value} (not an integer or Long)`);\n          }\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        if (typeof value === \"number\") {\n          value = long_default.fromNumber(value);\n        } else if (_isString(value)) {\n          value = long_default.fromString(value);\n        }\n        loffset += 8;\n        let capacity = this.buffer.length;\n        if (loffset > capacity) {\n          this.resize((capacity *= 2) > loffset ? capacity : loffset);\n        }\n        return [value, result];\n      }\n      writeVarint32(value, offset) {\n        let loffset = offset ?? this.woffset;\n        if (!this.noAssert) {\n          if (typeof value !== \"number\" || value % 1 !== 0) {\n            throw new TypeError(`Illegal value: ${value} (not an integer)`);\n          }\n          value |= 0;\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        const size = _SmartBuffer.calculateVarint32(value);\n        let b;\n        loffset += size;\n        let capacity10 = this.buffer.length;\n        if (loffset > capacity10) {\n          this.resize((capacity10 *= 2) > loffset ? capacity10 : loffset);\n        }\n        loffset -= size;\n        value >>>= 0;\n        while (value >= 128) {\n          b = value & 127 | 128;\n          this.buffer[loffset++] = b;\n          value >>>= 7;\n        }\n        this.buffer[loffset++] = value;\n        if (offset === void 0) {\n          this.woffset = loffset;\n          return this;\n        }\n        return size;\n      }\n      writeVarint32ZigZag(value, offset) {\n        return this.writeVarint32(_SmartBuffer.zigZagEncode32(value), offset);\n      }\n      readVarint32(offset) {\n        let loffset = offset ?? this.roffset;\n        if (!this.noAssert) {\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 1 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (1) <= ${this.buffer.length}`);\n          }\n        }\n        let c = 0;\n        let value = 0 >>> 0;\n        let b;\n        do {\n          if (!this.noAssert && loffset > this.buffer.length) {\n            const err = new Error(\"Truncated\");\n            Object.defineProperty(err, \"truncated\", {\n              enumerable: true,\n              value: true\n            });\n            throw err;\n          }\n          b = this.buffer[loffset++];\n          if (c < 5) {\n            value |= (b & 127) << 7 * c;\n          }\n          ++c;\n        } while ((b & 128) !== 0);\n        value |= 0;\n        if (offset === void 0) {\n          this.roffset = loffset;\n          return value;\n        }\n        return { value, length: c };\n      }\n      readVarint32ZigZag(offset) {\n        let val = this.readVarint32(offset);\n        if (typeof val === \"object\") {\n          val.value = _SmartBuffer.zigZagDecode32(val.value);\n        } else {\n          val = _SmartBuffer.zigZagDecode32(val);\n        }\n        return val;\n      }\n      writeVarint64(value, offset) {\n        let loffset = offset === void 0 ? this.woffset : offset;\n        if (!this.noAssert) {\n          if (typeof value === \"number\") {\n            value = long_default.fromNumber(value);\n          } else if (_isString(value)) {\n            value = long_default.fromString(value);\n          } else if (!(typeof value === \"object\" && value instanceof long_default)) {\n            throw new TypeError(`Illegal value: ${value} (not an integer or Long)`);\n          }\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        if (typeof value === \"number\") {\n          value = long_default.fromNumber(value, false);\n        } else if (_isString(value)) {\n          value = long_default.fromString(value, false);\n        } else if (value.unsigned !== false) {\n          value = value.toSigned();\n        }\n        const size = _SmartBuffer.calculateVarint64(value);\n        const part0 = value.toInt() >>> 0;\n        const part1 = value.shru(28).toInt() >>> 0;\n        const part2 = value.shru(56).toInt() >>> 0;\n        loffset += size;\n        let capacity11 = this.buffer.length;\n        if (loffset > capacity11) {\n          this.resize((capacity11 *= 2) > loffset ? capacity11 : loffset);\n        }\n        loffset -= size;\n        switch (size) {\n          case 10:\n            this.buffer[loffset + 9] = part2 >>> 7 & 1;\n          case 9:\n            this.buffer[loffset + 8] = size !== 9 ? part2 | 128 : part2 & 127;\n          case 8:\n            this.buffer[loffset + 7] = size !== 8 ? part1 >>> 21 | 128 : part1 >>> 21 & 127;\n          case 7:\n            this.buffer[loffset + 6] = size !== 7 ? part1 >>> 14 | 128 : part1 >>> 14 & 127;\n          case 6:\n            this.buffer[loffset + 5] = size !== 6 ? part1 >>> 7 | 128 : part1 >>> 7 & 127;\n          case 5:\n            this.buffer[loffset + 4] = size !== 5 ? part1 | 128 : part1 & 127;\n          case 4:\n            this.buffer[loffset + 3] = size !== 4 ? part0 >>> 21 | 128 : part0 >>> 21 & 127;\n          case 3:\n            this.buffer[loffset + 2] = size !== 3 ? part0 >>> 14 | 128 : part0 >>> 14 & 127;\n          case 2:\n            this.buffer[loffset + 1] = size !== 2 ? part0 >>> 7 | 128 : part0 >>> 7 & 127;\n          case 1:\n            this.buffer[loffset] = size !== 1 ? part0 | 128 : part0 & 127;\n        }\n        if (offset === void 0) {\n          this.woffset += size;\n          return this;\n        }\n        return size;\n      }\n      writeVarint64ZigZag(value, offset) {\n        return this.writeVarint64(_SmartBuffer.zigZagEncode64(value), offset);\n      }\n      readVarint64(offset) {\n        let loffset = offset === void 0 ? this.roffset : offset;\n        if (!this.noAssert) {\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 1 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (1) <= ${this.buffer.length}`);\n          }\n        }\n        const start = loffset;\n        let part0 = 0;\n        let part1 = 0;\n        let part2 = 0;\n        let b = 0;\n        b = this.buffer[loffset++];\n        part0 = b & 127;\n        if (b & 128) {\n          b = this.buffer[loffset++];\n          part0 |= (b & 127) << 7;\n          if (b & 128 || this.noAssert && b === void 0) {\n            b = this.buffer[loffset++];\n            part0 |= (b & 127) << 14;\n            if (b & 128 || this.noAssert && b === void 0) {\n              b = this.buffer[loffset++];\n              part0 |= (b & 127) << 21;\n              if (b & 128 || this.noAssert && b === void 0) {\n                b = this.buffer[loffset++];\n                part1 = b & 127;\n                if (b & 128 || this.noAssert && b === void 0) {\n                  b = this.buffer[loffset++];\n                  part1 |= (b & 127) << 7;\n                  if (b & 128 || this.noAssert && b === void 0) {\n                    b = this.buffer[loffset++];\n                    part1 |= (b & 127) << 14;\n                    if (b & 128 || this.noAssert && b === void 0) {\n                      b = this.buffer[loffset++];\n                      part1 |= (b & 127) << 21;\n                      if (b & 128 || this.noAssert && b === void 0) {\n                        b = this.buffer[loffset++];\n                        part2 = b & 127;\n                        if (b & 128 || this.noAssert && b === void 0) {\n                          b = this.buffer[loffset++];\n                          part2 |= (b & 127) << 7;\n                          if (b & 128 || this.noAssert && b === void 0) {\n                            throw new RangeError(\"Buffer overrun\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        const value = long_default.fromBits(part0 | part1 << 28, part1 >>> 4 | part2 << 24, false);\n        if (offset === void 0) {\n          this.roffset = loffset;\n          return value;\n        }\n        return { value, length: loffset - start };\n      }\n      readVarint64ZigZag(offset) {\n        let val = this.readVarint64(offset);\n        if (typeof val === \"object\" && val.value instanceof long_default) {\n          val.value = _SmartBuffer.zigZagDecode64(val.value);\n        } else {\n          val = _SmartBuffer.zigZagDecode64(val);\n        }\n        return val;\n      }\n      writeCString(str, offset) {\n        let loffset = offset === void 0 ? this.woffset : offset;\n        let i;\n        let k = str.length;\n        if (!this.noAssert) {\n          if (!_isString(str)) {\n            throw new TypeError(\"Illegal str: Not a string\");\n          }\n          for (i = 0; i < k; ++i) {\n            if (str.charCodeAt(i) === 0) {\n              throw new TypeError(\"Illegal str: Contains NULL-characters\");\n            }\n          }\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        k = import_buffer.Buffer.byteLength(str, \"utf8\");\n        loffset += k + 1;\n        let capacity12 = this.buffer.length;\n        if (loffset > capacity12) {\n          this.resize((capacity12 *= 2) > loffset ? capacity12 : loffset);\n        }\n        loffset -= k + 1;\n        loffset += this.buffer.write(str, loffset, k, \"utf8\");\n        this.buffer[loffset++] = 0;\n        if (offset === void 0) {\n          this.woffset = loffset;\n          return this;\n        }\n        return k;\n      }\n      readCString(offset) {\n        let loffset = offset === void 0 ? this.roffset : offset;\n        if (!this.noAssert) {\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${offset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 1 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (1) <= ${this.buffer.length}`);\n          }\n        }\n        const start = loffset;\n        let temp;\n        do {\n          if (loffset >= this.buffer.length) {\n            throw new RangeError(`Index out of range: ${loffset} <= ${this.buffer.length}`);\n          }\n          temp = this.buffer[loffset++];\n        } while (temp !== 0);\n        const str = this.buffer.toString(\"utf8\", start, loffset - 1);\n        if (offset === void 0) {\n          this.roffset = loffset;\n          return str;\n        }\n        return { string: str, length: loffset - start };\n      }\n      writeString(str, offset) {\n        let loffset = offset === void 0 ? this.woffset : offset;\n        if (!this.noAssert) {\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        const k = import_buffer.Buffer.byteLength(str, \"utf8\");\n        loffset += k;\n        let capacity14 = this.buffer.length;\n        if (loffset > capacity14) {\n          capacity14 *= 2;\n          this.resize(capacity14 > loffset ? capacity14 : loffset);\n        }\n        loffset -= k;\n        loffset += this.buffer.write(str, loffset, k, \"utf8\");\n        if (offset === void 0) {\n          this.woffset = loffset;\n          return this;\n        }\n        return k;\n      }\n      readString(length, metrics, offset) {\n        if (typeof metrics === \"number\") {\n          offset = metrics;\n          metrics = void 0;\n        }\n        let loffset = offset === void 0 ? this.roffset : offset;\n        if (metrics === void 0) {\n          metrics = _SmartBuffer.METRICS_CHARS;\n        }\n        if (!this.noAssert) {\n          if (typeof length !== \"number\" || length % 1 !== 0) {\n            throw new TypeError(`Illegal length: ${length} (not an integer)`);\n          }\n          length |= 0;\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        const start = loffset;\n        let temp;\n        if (metrics === _SmartBuffer.METRICS_CHARS) {\n          const decoder = new TextDecoder(\"utf-8\", { fatal: false });\n          let charCount = 0;\n          let result = \"\";\n          while (charCount < length && loffset < this.buffer.length) {\n            let bytesToRead = 1;\n            let decoded = \"\";\n            while (bytesToRead <= 4 && loffset + bytesToRead <= this.buffer.length) {\n              const bytes = this.buffer.subarray(loffset, loffset + bytesToRead);\n              decoded = decoder.decode(bytes, { stream: false });\n              if (decoded && decoded !== \"\\uFFFD\") {\n                break;\n              }\n              bytesToRead++;\n            }\n            if (decoded && decoded !== \"\\uFFFD\") {\n              result += decoded;\n              charCount += [...decoded].length;\n              loffset += bytesToRead;\n            } else {\n              break;\n            }\n          }\n          if (charCount !== length) {\n            throw new RangeError(`Illegal range: Truncated data, ${charCount} == ${length}`);\n          }\n          if (offset === void 0) {\n            this.roffset = loffset;\n            return result;\n          }\n          return { string: result, length: loffset - start };\n        } else if (metrics === _SmartBuffer.METRICS_BYTES) {\n          if (!this.noAssert) {\n            if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n              throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n            }\n            loffset >>>= 0;\n            if (loffset < 0 || loffset + length > this.buffer.length) {\n              throw new RangeError(`Illegal offset: 0 <= ${loffset} (${length}) <= ${this.buffer.length}`);\n            }\n          }\n          temp = this.buffer.toString(\"utf8\", loffset, loffset + length);\n          if (offset === void 0) {\n            this.roffset += length;\n            return temp;\n          }\n          return { string: temp, length };\n        }\n        throw new TypeError(`Unsupported metrics: ${metrics}`);\n      }\n      writeVString(str, offset) {\n        let loffset = offset ?? this.woffset;\n        if (!this.noAssert) {\n          if (!_isString(str)) {\n            throw new TypeError(\"Illegal str: Not a string\");\n          }\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        const start = loffset;\n        const k = import_buffer.Buffer.byteLength(str, \"utf8\");\n        const l = _SmartBuffer.calculateVarint32(k);\n        loffset += l + k;\n        let capacity15 = this.buffer.length;\n        if (loffset > capacity15) {\n          this.resize((capacity15 *= 2) > loffset ? capacity15 : loffset);\n        }\n        loffset -= l + k;\n        loffset += this.writeVarint32(k, loffset);\n        loffset += this.buffer.write(str, loffset, k, \"utf8\");\n        if (offset === void 0) {\n          this.woffset = loffset;\n          return this;\n        }\n        return loffset - start;\n      }\n      readVString(offset) {\n        let loffset = offset ?? this.roffset;\n        if (!this.noAssert) {\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 1 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (1) <= ${this.buffer.length}`);\n          }\n        }\n        const start = loffset;\n        const len = this.readVarint32(loffset);\n        const str = this.readString(len.value, _SmartBuffer.METRICS_BYTES, loffset += len.length);\n        loffset += str.length;\n        if (offset === void 0) {\n          this.roffset = loffset;\n          return str.string;\n        }\n        return { string: str.string, length: loffset - start };\n      }\n      appendTo(target, offset) {\n        target.write(this, offset);\n        return this;\n      }\n      assert(assert) {\n        this.noAssert = !assert;\n        return this;\n      }\n      reset(resetWOffset = false) {\n        this.roffset = 0;\n        if (resetWOffset) {\n          this.woffset = 0;\n        }\n        return this;\n      }\n      clone(copy = false) {\n        const bb = new _SmartBuffer(0, this.noAssert);\n        if (copy) {\n          const buffer = import_buffer.Buffer.allocUnsafe(this.buffer.length);\n          this.buffer.copy(buffer);\n          bb.buffer = buffer;\n        } else {\n          bb.buffer = this.buffer;\n        }\n        bb.roffset = this.roffset;\n        bb.woffset = this.woffset;\n        return bb;\n      }\n      compact(begin, end) {\n        let lbegin = begin === void 0 ? this.roffset : begin;\n        let lend = end === void 0 ? this.buffer.length : end;\n        if (!this.noAssert) {\n          if (typeof lbegin !== \"number\" || lbegin % 1 !== 0) {\n            throw new TypeError(\"Illegal begin: Not an integer\");\n          }\n          lbegin >>>= 0;\n          if (typeof lend !== \"number\" || lend % 1 !== 0) {\n            throw new TypeError(\"Illegal end: Not an integer\");\n          }\n          lend >>>= 0;\n          if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n            throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n          }\n        }\n        if (lbegin === 0 && lend === this.buffer.length) {\n          return this;\n        }\n        const len = lend - lbegin;\n        if (len === 0) {\n          this.buffer = EMPTY_BUFFER;\n          this.roffset = 0;\n          this.woffset = 0;\n          return this;\n        }\n        const buffer = import_buffer.Buffer.allocUnsafe(len);\n        this.buffer.copy(buffer, 0, lbegin, lend);\n        this.buffer = buffer;\n        this.woffset -= this.roffset;\n        this.roffset = 0;\n        return this;\n      }\n      copy(begin, end) {\n        let lbegin = begin === void 0 ? this.roffset : begin;\n        let lend = end === void 0 ? this.woffset : end;\n        if (!this.noAssert) {\n          if (typeof lbegin !== \"number\" || lbegin % 1 !== 0) {\n            throw new TypeError(\"Illegal begin: Not an integer\");\n          }\n          lbegin >>>= 0;\n          if (typeof lend !== \"number\" || lend % 1 !== 0) {\n            throw new TypeError(\"Illegal end: Not an integer\");\n          }\n          lend >>>= 0;\n          if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n            throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n          }\n        }\n        if (lbegin === lend) {\n          return new _SmartBuffer(0, this.noAssert);\n        }\n        const capacity = lend - lbegin;\n        const bb = new _SmartBuffer(capacity, this.noAssert);\n        bb.roffset = 0;\n        bb.woffset = 0;\n        this.copyTo(bb, 0, lbegin, lend);\n        return bb;\n      }\n      copyTo(target, targetOffset, sourceStart, sourceEnd) {\n        if (!this.noAssert) {\n          if (!(target instanceof _SmartBuffer)) {\n            throw new TypeError(\"'target' is not a SmartBuffer\");\n          }\n        }\n        const ltargetOffset = targetOffset === void 0 ? target.woffset : targetOffset | 0;\n        const lsourceStart = sourceStart === void 0 ? this.roffset : sourceStart | 0;\n        const lsourceEnd = sourceEnd === void 0 ? this.woffset : sourceEnd | 0;\n        if (ltargetOffset < 0 || ltargetOffset > target.buffer.length) {\n          throw new RangeError(`Illegal target range: 0 <= ${ltargetOffset} <= ${target.buffer.length}`);\n        }\n        if (lsourceStart < 0 || lsourceEnd > this.buffer.length) {\n          throw new RangeError(`Illegal source range: 0 <= ${lsourceStart} <= ${this.buffer.length}`);\n        }\n        const len = lsourceEnd - lsourceStart;\n        if (len === 0) {\n          return target;\n        }\n        target.ensureCapacity(ltargetOffset + len);\n        this.buffer.copy(target.buffer, ltargetOffset, lsourceStart, lsourceEnd);\n        if (sourceStart === void 0) {\n          this.roffset += len;\n        }\n        if (targetOffset === void 0) {\n          target.woffset += len;\n        }\n        return this;\n      }\n      ensureCapacity(capacity) {\n        let current = this.buffer.length;\n        if (current < capacity) {\n          return this.resize((current *= 2) > capacity ? current : capacity);\n        }\n        return this;\n      }\n      fill(value, begin, end) {\n        let lbegin = begin === void 0 ? this.woffset : begin;\n        if (_isString(value) && value.length > 0) {\n          value = value.charCodeAt(0);\n        }\n        let lend = end === void 0 ? this.buffer.length : end;\n        if (!this.noAssert) {\n          if (typeof value !== \"number\" || value % 1 !== 0) {\n            throw new TypeError(`Illegal value: ${value} (not an integer)`);\n          }\n          value |= 0;\n          if (typeof lbegin !== \"number\" || lbegin % 1 !== 0) {\n            throw new TypeError(\"Illegal begin: Not an integer\");\n          }\n          lbegin >>>= 0;\n          if (typeof lend !== \"number\" || lend % 1 !== 0) {\n            throw new TypeError(\"Illegal end: Not an integer\");\n          }\n          lend >>>= 0;\n          if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n            throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n          }\n        }\n        if (lbegin >= lend) {\n          return this;\n        }\n        this.buffer.fill(value, lbegin, lend);\n        if (begin === void 0) {\n          this.woffset = lend;\n        }\n        return this;\n      }\n      prepend(source, offset, encoding) {\n        let loffset = offset === void 0 ? this.roffset : offset;\n        if (!this.noAssert) {\n          if (typeof loffset !== \"number\" || loffset % 1 !== 0) {\n            throw new TypeError(`Illegal offset: ${loffset} (not an integer)`);\n          }\n          loffset >>>= 0;\n          if (loffset < 0 || loffset + 0 > this.buffer.length) {\n            throw new RangeError(`Illegal offset: 0 <= ${loffset} (0) <= ${this.buffer.length}`);\n          }\n        }\n        if (!(source instanceof _SmartBuffer)) {\n          source = _SmartBuffer.wrap(source, encoding);\n        }\n        const len = source.buffer.length - source.roffset;\n        if (len <= 0) {\n          return this;\n        }\n        const diff = len - loffset;\n        if (diff > 0) {\n          const buffer = import_buffer.Buffer.allocUnsafe(this.buffer.length + diff);\n          this.buffer.copy(buffer, len, loffset, this.buffer.length);\n          this.buffer = buffer;\n          this.roffset += diff;\n          this.woffset += diff;\n          loffset += diff;\n        }\n        source.buffer.copy(this.buffer, loffset - len, source.roffset, source.buffer.length);\n        source.roffset = source.buffer.length;\n        if (offset === void 0) {\n          this.roffset -= len;\n        }\n        return this;\n      }\n      prependTo(target, offset) {\n        target.prepend(this, offset);\n        return this;\n      }\n      resize(capacity) {\n        if (!this.noAssert) {\n          if (typeof capacity !== \"number\" || capacity % 1 !== 0) {\n            throw new TypeError(`'capacity' is not an integer: ${capacity}`);\n          }\n          capacity |= 0;\n          if (capacity < 0) {\n            throw new TypeError(`Not valid capacity value: 0 <= ${capacity}`);\n          }\n        }\n        if (this.buffer.length < capacity) {\n          const buffer = import_buffer.Buffer.allocUnsafe(capacity);\n          this.buffer.copy(buffer);\n          this.buffer = buffer;\n        }\n        return this;\n      }\n      reverse(begin, end) {\n        let lbegin = begin === void 0 ? this.roffset : begin;\n        let lend = end === void 0 ? this.woffset : end;\n        if (!this.noAssert) {\n          if (typeof lbegin !== \"number\" || lbegin % 1 !== 0) {\n            throw new TypeError(\"Illegal begin: Not an integer\");\n          }\n          lbegin >>>= 0;\n          if (typeof lend !== \"number\" || lend % 1 !== 0) {\n            throw new TypeError(\"Illegal end: Not an integer\");\n          }\n          lend >>>= 0;\n          if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n            throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n          }\n        }\n        if (lbegin === lend) {\n          return this;\n        }\n        Array.prototype.reverse.call(this.buffer.slice(lbegin, lend));\n        return this;\n      }\n      skipRead(length) {\n        if (!this.noAssert) {\n          if (typeof length !== \"number\" || length % 1 !== 0) {\n            throw new TypeError(`Illegal length: ${length} (not an integer)`);\n          }\n          length |= 0;\n        }\n        const offset = this.roffset + length;\n        if (!this.noAssert) {\n          if (offset < 0 || offset > this.buffer.length) {\n            throw new RangeError(`Illegal length: 0 <= ${this.roffset} + ${length} <= ${this.buffer.length}`);\n          }\n        }\n        this.roffset = offset;\n        return this;\n      }\n      skipWrite(length) {\n        if (!this.noAssert) {\n          if (typeof length !== \"number\" || length % 1 !== 0) {\n            throw new TypeError(`Illegal length: ${length} (not an integer)`);\n          }\n          length |= 0;\n        }\n        const offset = this.woffset + length;\n        if (!this.noAssert) {\n          if (offset < 0 || offset > this.buffer.length) {\n            throw new RangeError(`Illegal length: 0 <= ${this.woffset} + ${length} <= ${this.buffer.length}`);\n          }\n        }\n        this.woffset = offset;\n        return this;\n      }\n      slice(begin, end) {\n        let lbegin = begin === void 0 ? this.roffset : begin;\n        let lend = end === void 0 ? this.woffset : end;\n        if (!this.noAssert) {\n          if (typeof lbegin !== \"number\" || lbegin % 1 !== 0) {\n            throw new TypeError(\"Illegal begin: Not an integer\");\n          }\n          lbegin >>>= 0;\n          if (typeof end !== \"number\" || lend % 1 !== 0) {\n            throw new TypeError(\"Illegal end: Not an integer\");\n          }\n          lend >>>= 0;\n          if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n            throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n          }\n        }\n        const bb = new _SmartBuffer(lend - lbegin);\n        bb.buffer = this.buffer.slice(begin, lend);\n        bb.woffset = bb.capacity;\n        return bb;\n      }\n      toBuffer(forceCopy = false, begin, end) {\n        let lbegin = begin === void 0 ? this.roffset : begin;\n        let lend = end === void 0 ? this.woffset : end;\n        lbegin >>>= 0;\n        lend >>>= 0;\n        if (!this.noAssert) {\n          if (typeof lbegin !== \"number\" || lbegin % 1 !== 0) {\n            throw new TypeError(\"Illegal begin: Not an integer\");\n          }\n          if (typeof lend !== \"number\" || lend % 1 !== 0) {\n            throw new TypeError(\"Illegal end: Not an integer\");\n          }\n          if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n            throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n          }\n        }\n        if (forceCopy) {\n          const buffer = import_buffer.Buffer.allocUnsafe(lend - lbegin);\n          this.buffer.copy(buffer, 0, lbegin, end);\n          return buffer;\n        }\n        if (lbegin === 0 && lend === this.buffer.length) {\n          return this.buffer;\n        }\n        return this.buffer.slice(lbegin, lend);\n      }\n      toArrayBuffer() {\n        let offset = this.roffset;\n        let limit = this.woffset;\n        if (!this.noAssert) {\n          if (offset === void 0 || offset % 1 !== 0) {\n            throw new TypeError(\"Illegal offset: Not an integer\");\n          }\n          offset >>>= 0;\n          if (typeof limit !== \"number\" || limit % 1 !== 0) {\n            throw new TypeError(\"Illegal limit: Not an integer\");\n          }\n          limit >>>= 0;\n          if (offset < 0 || offset > limit || limit > this.buffer.length) {\n            throw new RangeError(`Illegal range: 0 <= ${offset} <= ${limit} <= ${this.buffer.length}`);\n          }\n        }\n        const ab = new ArrayBuffer(limit - offset);\n        const dst = new Uint8Array(ab);\n        this.buffer.copy(dst);\n        return ab;\n      }\n      toString(encoding, begin, end) {\n        if (encoding === void 0) {\n          return `ByteArrayNB(roffset=${this.roffset},woffset=${this.woffset},capacity=${this.capacity})`;\n        }\n        switch (encoding) {\n          case \"utf8\":\n            return this.toUTF8(begin, end);\n          case \"base64\":\n            return this.toBase64(begin, end);\n          case \"hex\":\n            return this.toHex(begin, end);\n          case \"binary\":\n            return this.toBinary(begin, end);\n          case \"debug\":\n            return this.toDebug();\n          default:\n            throw new TypeError(`Unsupported encoding: ${encoding}`);\n        }\n      }\n      toBase64(begin, end) {\n        let lbegin = begin === void 0 ? this.roffset : begin;\n        let lend = end === void 0 ? this.woffset : end;\n        lbegin |= 0;\n        lend |= 0;\n        if (lbegin < 0 || lend > this.buffer.length || lbegin > lend) {\n          throw new RangeError(\"begin, end\");\n        }\n        return this.buffer.toString(\"base64\", lbegin, lend);\n      }\n      toBinary(begin, end) {\n        let lbegin = begin === void 0 ? this.roffset : begin;\n        let lend = end === void 0 ? this.woffset : end;\n        lbegin |= 0;\n        lend |= 0;\n        if (lbegin < 0 || lend > this.capacity || lbegin > lend) {\n          throw new RangeError(\"begin, end\");\n        }\n        return this.buffer.toString(\"binary\", lbegin, lend);\n      }\n      toDebug(columns = false) {\n        let i = -1;\n        const k = this.buffer.length;\n        let b;\n        let hex = \"\";\n        let asc = \"\";\n        let out = \"\";\n        while (i < k) {\n          if (i !== -1) {\n            b = this.buffer[i];\n            if (b < 16) {\n              hex += `0${b.toString(16).toUpperCase()}`;\n            } else {\n              hex += b.toString(16).toUpperCase();\n            }\n            if (columns) {\n              asc += b > 32 && b < 127 ? String.fromCharCode(b) : \".\";\n            }\n          }\n          ++i;\n          if (columns) {\n            if (i > 0 && i % 16 === 0 && i !== k) {\n              while (hex.length < 3 * 16 + 3) {\n                hex += \" \";\n              }\n              out += `${hex + asc}\n`;\n              hex = asc = \"\";\n            }\n          }\n          if (i === this.roffset && this.roffset === this.woffset && this.woffset === this.buffer.length) {\n            hex += \"|\";\n          } else if (i === this.roffset && this.roffset === this.woffset) {\n            hex += \"^\";\n          } else if (i === this.roffset && this.roffset === this.buffer.length) {\n            hex += \"[\";\n          } else if (i === this.woffset && this.woffset === this.buffer.length) {\n            hex += \"]\";\n          } else if (i === this.roffset) {\n            hex += \"<\";\n          } else if (i === this.woffset) {\n            hex += \">\";\n          } else if (i === this.buffer.length) {\n            hex += \"*\";\n          } else {\n            hex += columns || i !== 0 && i !== k ? \" \" : \"\";\n          }\n        }\n        if (columns && hex !== \" \") {\n          while (hex.length < 3 * 16 + 3) {\n            hex += \" \";\n          }\n          out += `${hex + asc}\n`;\n        }\n        return columns ? out : hex;\n      }\n      toHex(begin, end) {\n        let lbegin = begin === void 0 ? this.roffset : begin;\n        let lend = end === void 0 ? this.woffset : end;\n        if (!this.noAssert) {\n          if (typeof lbegin !== \"number\" || lbegin % 1 !== 0) {\n            throw new TypeError(\"Illegal begin: Not an integer\");\n          }\n          lbegin >>>= 0;\n          if (typeof lend !== \"number\" || lend % 1 !== 0) {\n            throw new TypeError(\"Illegal end: Not an integer\");\n          }\n          lend >>>= 0;\n          if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n            throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n          }\n        }\n        return this.buffer.toString(\"hex\", lbegin, lend);\n      }\n      toUTF8(begin, end) {\n        let lbegin = begin === void 0 ? this.roffset : begin;\n        let lend = end === void 0 ? this.woffset : end;\n        if (!this.noAssert) {\n          if (typeof lbegin !== \"number\" || lbegin % 1 !== 0) {\n            throw new TypeError(\"Illegal begin: Not an integer\");\n          }\n          lbegin >>>= 0;\n          if (typeof lend !== \"number\" || lend % 1 !== 0) {\n            throw new TypeError(\"Illegal end: Not an integer\");\n          }\n          lend >>>= 0;\n          if (lbegin < 0 || lbegin > lend || lend > this.buffer.length) {\n            throw new RangeError(`Illegal range: 0 <= ${lbegin} <= ${lend} <= ${this.buffer.length}`);\n          }\n        }\n        return this.buffer.toString(\"utf8\", lbegin, lend);\n      }\n      static alloc(capacity, noAssert = _SmartBuffer.DEFAULT_NOASSERT) {\n        return new _SmartBuffer(capacity, noAssert);\n      }\n      static concat(buffers, encoding, noAssert = _SmartBuffer.DEFAULT_NOASSERT) {\n        let capacity = 0;\n        const k = buffers.length;\n        let i = 0;\n        let length;\n        for (; i < k; ++i) {\n          if (!(buffers[i] instanceof _SmartBuffer)) {\n            buffers[i] = _SmartBuffer.wrap(buffers[i], encoding);\n          }\n          length = buffers[i].woffset - buffers[i].roffset;\n          if (length > 0) {\n            capacity += length;\n          }\n        }\n        if (capacity === 0) {\n          return new _SmartBuffer(0, noAssert);\n        }\n        const bb = new _SmartBuffer(capacity, noAssert);\n        let bi;\n        i = 0;\n        while (i < k) {\n          bi = buffers[i++];\n          length = bi.woffset - bi.roffset;\n          if (length <= 0) {\n            continue;\n          }\n          bi.buffer.copy(bb.buffer, bb.woffset, bi.roffset, bi.woffset);\n          bb.woffset += length;\n        }\n        bb.roffset = 0;\n        return bb;\n      }\n      static wrap(buffer, encoding, noAssert) {\n        if (_isString(buffer)) {\n          if (encoding === void 0) {\n            encoding = \"utf8\";\n          }\n          switch (encoding) {\n            case \"base64\":\n              return _SmartBuffer.fromBase64(buffer);\n            case \"hex\":\n              return _SmartBuffer.fromHex(buffer);\n            case \"binary\":\n              return _SmartBuffer.fromBinary(buffer);\n            case \"utf8\":\n              return _SmartBuffer.fromUTF8(buffer);\n            case \"debug\":\n              return _SmartBuffer.fromDebug(buffer);\n            default:\n              throw new TypeError(`Unsupported encoding: ${encoding}`);\n          }\n        }\n        let bb;\n        if (buffer instanceof _SmartBuffer) {\n          bb = buffer.clone();\n          return bb;\n        }\n        let b;\n        if (buffer instanceof Uint8Array) {\n          b = import_buffer.Buffer.from(buffer);\n          buffer = b;\n        } else if (buffer instanceof ArrayBuffer) {\n          b = import_buffer.Buffer.from(buffer);\n          buffer = b;\n        } else if (!(buffer instanceof import_buffer.Buffer)) {\n          if (!Array.isArray(buffer)) {\n            throw new TypeError(\"Illegal buffer\");\n          }\n          buffer = import_buffer.Buffer.from(buffer);\n        }\n        bb = new _SmartBuffer(0, noAssert);\n        if (buffer.length > 0) {\n          bb.buffer = buffer;\n          bb.woffset = buffer.length;\n        }\n        return bb;\n      }\n      static calculateVarint32(value) {\n        value = value >>> 0;\n        if (value < 1 << 7) {\n          return 1;\n        } else if (value < 1 << 14) {\n          return 2;\n        } else if (value < 1 << 21) {\n          return 3;\n        } else if (value < 1 << 28) {\n          return 4;\n        }\n        return 5;\n      }\n      static zigZagEncode32(n) {\n        return ((n |= 0) << 1 ^ n >> 31) >>> 0;\n      }\n      static zigZagDecode32(n) {\n        return n >>> 1 ^ -(n & 1) | 0;\n      }\n      static calculateVarint64(value) {\n        let lValue;\n        if (typeof value === \"number\") {\n          lValue = long_default.fromNumber(value);\n        } else if (_isString(value)) {\n          lValue = long_default.fromString(value);\n        } else {\n          lValue = value;\n        }\n        const part0 = lValue.toInt() >>> 0;\n        const part1 = lValue.shru(28).toInt() >>> 0;\n        const part2 = lValue.shru(56).toInt() >>> 0;\n        if (part2 === 0) {\n          if (part1 === 0) {\n            if (part0 < 1 << 14) {\n              return part0 < 1 << 7 ? 1 : 2;\n            }\n            return part0 < 1 << 21 ? 3 : 4;\n          }\n          if (part1 < 1 << 14) {\n            return part1 < 1 << 7 ? 5 : 6;\n          }\n          return part1 < 1 << 21 ? 7 : 8;\n        }\n        return part2 < 1 << 7 ? 9 : 10;\n      }\n      static zigZagEncode64(value) {\n        let lValue;\n        if (typeof value === \"number\") {\n          lValue = long_default.fromNumber(value, false);\n        } else if (_isString(value)) {\n          lValue = long_default.fromString(value, false);\n        } else if (value.unsigned !== false) {\n          lValue = value.toSigned();\n        } else {\n          lValue = value;\n        }\n        return lValue.shl(1).xor(lValue.shr(63)).toUnsigned();\n      }\n      static zigZagDecode64(value) {\n        let lValue;\n        if (typeof value === \"number\") {\n          lValue = long_default.fromNumber(value, false);\n        } else if (_isString(value)) {\n          lValue = long_default.fromString(value, false);\n        } else if (value.unsigned !== false) {\n          lValue = value.toSigned();\n        } else {\n          lValue = value;\n        }\n        return lValue.shru(1).xor(lValue.and(long_default.ONE).toSigned().negate()).toSigned();\n      }\n      static calculateUTF8Chars(str) {\n        return [...str].length;\n      }\n      static calculateString(str) {\n        if (!_isString(str)) {\n          throw new TypeError(`Illegal argument: ${typeof str}`);\n        }\n        return import_buffer.Buffer.byteLength(str, \"utf8\");\n      }\n      static fromBase64(str) {\n        return _SmartBuffer.wrap(import_buffer.Buffer.from(str, \"base64\"));\n      }\n      static btoa(str) {\n        return _SmartBuffer.fromBinary(str).toBase64();\n      }\n      static atob(b64) {\n        return _SmartBuffer.fromBase64(b64).toBinary();\n      }\n      static fromBinary(str) {\n        return _SmartBuffer.wrap(import_buffer.Buffer.from(str, \"binary\"));\n      }\n      static fromDebug(str, noAssert = _SmartBuffer.DEFAULT_NOASSERT) {\n        const k = str.length;\n        const bb = new _SmartBuffer((k + 1) / 3 | 0, noAssert);\n        let i = 0;\n        let j = 0;\n        let ch;\n        let b;\n        let rs = false;\n        let hw = false;\n        let hr = false;\n        let hl = false;\n        let fail = false;\n        while (i < k) {\n          switch (ch = str.charAt(i++)) {\n            case \"|\":\n              if (!noAssert) {\n                if (hr || hw || hl) {\n                  fail = true;\n                  break;\n                }\n                hr = hw = hl = true;\n              }\n              bb.roffset = bb.woffset = j;\n              rs = false;\n              break;\n            case \"]\":\n              if (!noAssert) {\n                if (hw || hl) {\n                  fail = true;\n                  break;\n                }\n                hw = hl = true;\n              }\n              bb.woffset = j;\n              rs = false;\n              break;\n            case \"^\":\n              if (!noAssert) {\n                if (hr || hw) {\n                  fail = true;\n                  break;\n                }\n                hr = hw = true;\n              }\n              bb.roffset = bb.woffset = j;\n              rs = false;\n              break;\n            case \"<\":\n              if (!noAssert) {\n                if (hr) {\n                  fail = true;\n                  break;\n                }\n                hr = true;\n              }\n              bb.roffset = j;\n              rs = false;\n              break;\n            case \"*\":\n              if (!noAssert) {\n                if (hl) {\n                  fail = true;\n                  break;\n                }\n                hl = true;\n              }\n              rs = false;\n              break;\n            case \">\":\n              if (!noAssert) {\n                if (hw) {\n                  fail = true;\n                  break;\n                }\n                hw = true;\n              }\n              bb.woffset = j;\n              rs = false;\n              break;\n            case \" \":\n              rs = false;\n              break;\n            default:\n              if (!noAssert) {\n                if (rs) {\n                  fail = true;\n                  break;\n                }\n              }\n              b = parseInt(ch + str.charAt(i++), 16);\n              if (!noAssert) {\n                if (isNaN(b) || b < 0 || b > 255) {\n                  throw new RangeError(\"Not a debug encoded string\");\n                }\n              }\n              bb.buffer[j++] = b;\n              rs = true;\n          }\n          if (fail) {\n            throw new RangeError(`Invalid symbol at ${i}`);\n          }\n        }\n        if (!noAssert) {\n          if (!hr || !hw || !hl) {\n            throw new RangeError(`Missing roffset or woffset or limit: ${str}`);\n          }\n          if (j < bb.buffer.length) {\n            throw new RangeError(`Not a debug encoded string (is it hex?) ${j} < ${k}`);\n          }\n        }\n        return bb;\n      }\n      static fromHex(str, noAssert = _SmartBuffer.DEFAULT_NOASSERT) {\n        if (!noAssert) {\n          if (!_isString(str)) {\n            throw new TypeError(\"Illegal str: Not a string\");\n          }\n          if (str.length % 2 !== 0) {\n            throw new TypeError(\"Illegal str: Length not a multiple of 2\");\n          }\n        }\n        const bb = new _SmartBuffer(0, true);\n        bb.buffer = import_buffer.Buffer.from(str, \"hex\");\n        bb.woffset = bb.buffer.length;\n        return bb;\n      }\n      static fromUTF8(str, noAssert = _SmartBuffer.DEFAULT_NOASSERT) {\n        if (!noAssert) {\n          if (!_isString(str)) {\n            throw new TypeError(\"Illegal str: Not a string\");\n          }\n        }\n        const bb = new _SmartBuffer(0, noAssert);\n        bb.buffer = import_buffer.Buffer.from(str, \"utf8\");\n        bb.woffset = bb.buffer.length;\n        return bb;\n      }\n    };\n  }\n});\n\n// ../messagepack/dist/encoder.js\nvar import_buffer2, getType, encodeString, encodeCustom, Encoder;\nvar init_encoder = __esm({\n  \"../messagepack/dist/encoder.js\"() {\n    \"use strict\";\n    init_process_shim();\n    import_buffer2 = __toESM(require_buffer(), 1);\n    init_dist2();\n    init_dist();\n    getType = /* @__PURE__ */ __name((value) => {\n      if (value === null)\n        return \"null\";\n      if (value === void 0)\n        return \"undefined\";\n      const type = typeof value;\n      if (type !== \"object\")\n        return type;\n      const stringTag = Object.prototype.toString.call(value);\n      const match = stringTag.match(/\\[object (\\w+)\\]/);\n      return match ? match[1].toLowerCase() : \"object\";\n    }, \"getType\");\n    encodeString = /* @__PURE__ */ __name((x, buf) => {\n      const len = import_buffer2.Buffer.byteLength(x);\n      if (len < 32) {\n        buf.writeInt8(160 | len);\n        if (len === 0) {\n          return;\n        }\n      } else if (len <= 255) {\n        buf.writeUInt16BE(55552 | len);\n      } else if (len <= 65535) {\n        buf.writeInt8(218);\n        buf.writeUInt16BE(len);\n      } else {\n        buf.writeInt8(219);\n        buf.writeUInt32BE(len);\n      }\n      buf.write(x, void 0, len);\n    }, \"encodeString\");\n    encodeCustom = /* @__PURE__ */ __name((x, type, encFunc, buf) => {\n      const encoded = encFunc(x, buf);\n      const length = encoded.length;\n      if (length === 1) {\n        buf.writeUInt8(212);\n      } else if (length === 2) {\n        buf.writeUInt8(213);\n      } else if (length === 4) {\n        buf.writeUInt8(214);\n      } else if (length === 8) {\n        buf.writeUInt8(215);\n      } else if (length === 16) {\n        buf.writeUInt8(216);\n      } else if (length < 256) {\n        buf.writeUInt16BE(50944 | length);\n      } else if (length < 65536) {\n        buf.writeUInt32BE(3355443200 | length << 8);\n        buf.woffset -= 1;\n      } else {\n        buf.writeUInt8(201);\n        buf.writeUInt32BE(length);\n      }\n      buf.writeInt8(type);\n      buf.write(encoded);\n    }, \"encodeCustom\");\n    Encoder = class {\n      static {\n        __name(this, \"Encoder\");\n      }\n      constructor(encodingTypes) {\n        this.encodingTypes = encodingTypes;\n      }\n      encode(x, buf) {\n        buf = buf || new SmartBuffer(1024, true);\n        this._encode(x, buf);\n        return buf;\n      }\n      _encode(x, buf) {\n        const type = typeof x;\n        switch (type) {\n          case \"undefined\": {\n            buf.writeUInt32BE(3556769792);\n            buf.woffset--;\n            break;\n          }\n          case \"boolean\": {\n            if (x === true) {\n              buf.writeInt8(195);\n            } else {\n              buf.writeInt8(194);\n            }\n            break;\n          }\n          case \"string\": {\n            encodeString(x, buf);\n            break;\n          }\n          case \"bigint\": {\n            encodeCustom(x, 120, this.encodingTypes.get(120).encode, buf);\n            break;\n          }\n          case \"number\": {\n            if (x !== (x | 0)) {\n              buf.writeInt8(203);\n              buf.writeDoubleBE(x);\n            } else if (x >= 0) {\n              if (x < 128) {\n                buf.writeInt8(x);\n              } else if (x < 256) {\n                buf.writeInt16BE(52224 | x);\n              } else if (x < 65536) {\n                buf.writeInt8(205);\n                buf.writeUInt16BE(x);\n              } else if (x <= 4294967295) {\n                buf.writeInt8(206);\n                buf.writeUInt32BE(x);\n              } else if (x <= 9007199254740991) {\n                buf.writeInt8(207);\n                buf.writeUInt64BE(x);\n              } else {\n                buf.writeInt8(203);\n                buf.writeDoubleBE(x);\n              }\n            } else {\n              if (x >= -32) {\n                buf.writeInt8(256 + x);\n              } else if (x >= -128) {\n                buf.writeInt8(208);\n                buf.writeInt8(x);\n              } else if (x >= -32768) {\n                buf.writeInt8(209);\n                buf.writeInt16BE(x);\n              } else if (x > -214748365) {\n                buf.writeInt8(210);\n                buf.writeInt32BE(x);\n              } else if (x >= -9007199254740991) {\n                buf.writeInt8(211);\n                buf.writeInt64BE(x);\n              } else {\n                buf.writeInt8(203);\n                buf.writeDoubleBE(x);\n              }\n            }\n            break;\n          }\n          default: {\n            if (x === null) {\n              buf.writeInt8(192);\n            } else if (isBuffer(x)) {\n              if (x.length <= 255) {\n                buf.writeInt16BE(50176 | x.length);\n              } else if (x.length <= 65535) {\n                buf.writeInt8(197);\n                buf.writeUInt16BE(x.length);\n              } else {\n                buf.writeUInt8(198);\n                buf.writeUInt32BE(x.length);\n              }\n              buf.write(x);\n            } else if (Array.isArray(x)) {\n              if (x.length < 16) {\n                buf.writeInt8(144 | x.length);\n              } else if (x.length < 65536) {\n                buf.writeInt8(220);\n                buf.writeUInt16BE(x.length);\n              } else {\n                buf.writeInt8(221);\n                buf.writeUInt32BE(x.length);\n              }\n              for (const obj of x) {\n                this._encode(obj, buf);\n              }\n            } else if (isPlainObject(x)) {\n              const keys2 = Object.keys(x);\n              if (keys2.length < 16) {\n                buf.writeInt8(128 | keys2.length);\n              } else {\n                buf.writeInt8(222);\n                buf.writeUInt16BE(keys2.length);\n              }\n              for (const key of keys2) {\n                encodeString(key, buf);\n                this._encode(x[key], buf);\n              }\n            } else {\n              const encTypes = this.encodingTypes;\n              for (const [type_, info] of encTypes.entries()) {\n                if (info.check(x)) {\n                  encodeCustom(x, type_, info.encode, buf);\n                  return;\n                }\n              }\n              throw new Error(`Not supported: ${getType(x)}`);\n            }\n          }\n        }\n      }\n    };\n  }\n});\n\n// ../messagepack/dist/decoder.js\nvar getSize, buildDecodeResult, isValidDataSize, Decoder;\nvar init_decoder = __esm({\n  \"../messagepack/dist/decoder.js\"() {\n    \"use strict\";\n    init_process_shim();\n    init_dist2();\n    getSize = /* @__PURE__ */ __name((first) => {\n      switch (first) {\n        case 196:\n          return 2;\n        case 197:\n          return 3;\n        case 198:\n          return 5;\n        case 199:\n          return 3;\n        case 200:\n          return 4;\n        case 201:\n          return 6;\n        case 202:\n          return 5;\n        case 203:\n          return 9;\n        case 204:\n          return 2;\n        case 205:\n          return 3;\n        case 206:\n          return 5;\n        case 207:\n          return 9;\n        case 208:\n          return 2;\n        case 209:\n          return 3;\n        case 210:\n          return 5;\n        case 211:\n          return 9;\n        case 212:\n          return 3;\n        case 213:\n          return 4;\n        case 214:\n          return 6;\n        case 215:\n          return 10;\n        case 216:\n          return 18;\n        case 217:\n          return 2;\n        case 218:\n          return 3;\n        case 219:\n          return 5;\n        case 222:\n          return 3;\n        default:\n          return -1;\n      }\n    }, \"getSize\");\n    buildDecodeResult = /* @__PURE__ */ __name((value, bytesConsumed) => ({\n      value,\n      bytesConsumed\n    }), \"buildDecodeResult\");\n    isValidDataSize = /* @__PURE__ */ __name((dataLength, bufLength, headerLength) => bufLength >= headerLength + dataLength, \"isValidDataSize\");\n    Decoder = class {\n      static {\n        __name(this, \"Decoder\");\n      }\n      constructor(decodingTypes) {\n        this.decodingTypes = decodingTypes;\n      }\n      decode(buf) {\n        const smartBuf = isSmartBuffer(buf) ? buf : SmartBuffer.wrap(buf, void 0, true);\n        const result = this.tryDecode(smartBuf);\n        if (result) {\n          return result.value;\n        }\n        throw new Error(\"Incomplete buffer\");\n      }\n      tryDecode(buf) {\n        const bufLength = buf.length;\n        if (bufLength <= 0) {\n          return null;\n        }\n        const first = buf.readUInt8();\n        let length;\n        let result = 0;\n        let type;\n        const size = getSize(first);\n        if (size !== -1 && bufLength < size) {\n          return null;\n        }\n        switch (first) {\n          case 192:\n            return buildDecodeResult(null, 1);\n          case 194:\n            return buildDecodeResult(false, 1);\n          case 195:\n            return buildDecodeResult(true, 1);\n          case 204:\n            result = buf.readUInt8();\n            return buildDecodeResult(result, 2);\n          case 205:\n            result = buf.readUInt16BE();\n            return buildDecodeResult(result, 3);\n          case 206:\n            result = buf.readUInt32BE();\n            return buildDecodeResult(result, 5);\n          case 207:\n            result = buf.readUInt64BE().toNumber();\n            return buildDecodeResult(result, 9);\n          case 208:\n            result = buf.readInt8();\n            return buildDecodeResult(result, 2);\n          case 209:\n            result = buf.readInt16BE();\n            return buildDecodeResult(result, 3);\n          case 210:\n            result = buf.readInt32BE();\n            return buildDecodeResult(result, 5);\n          case 211:\n            result = buf.readInt64BE().toNumber();\n            return buildDecodeResult(result, 9);\n          case 202:\n            result = buf.readFloatBE();\n            return buildDecodeResult(result, 5);\n          case 203:\n            result = buf.readDoubleBE();\n            return buildDecodeResult(result, 9);\n          case 217:\n            length = buf.readUInt8();\n            if (!length || !isValidDataSize(length, bufLength, 2)) {\n              return null;\n            }\n            result = buf.toString(\"utf8\", buf.roffset, buf.roffset + length);\n            buf.skipRead(length);\n            return buildDecodeResult(result, 2 + length);\n          case 218:\n            length = buf.readUInt16BE();\n            if (!isValidDataSize(length, bufLength, 3)) {\n              return null;\n            }\n            result = buf.toString(\"utf8\", buf.roffset, buf.roffset + length);\n            buf.skipRead(length);\n            return buildDecodeResult(result, 3 + length);\n          case 219:\n            length = buf.readUInt32BE();\n            if (!isValidDataSize(length, bufLength, 5)) {\n              return null;\n            }\n            result = buf.toString(\"utf8\", buf.roffset, buf.roffset + length);\n            buf.skipRead(length);\n            return buildDecodeResult(result, 5 + length);\n          case 196:\n            length = buf.readUInt8();\n            if (length === void 0 || !isValidDataSize(length, bufLength, 2)) {\n              return null;\n            }\n            result = buf.slice(buf.roffset, buf.roffset + length).buffer;\n            buf.skipRead(length);\n            return buildDecodeResult(result, 2 + length);\n          case 197:\n            length = buf.readUInt16BE();\n            if (!isValidDataSize(length, bufLength, 3)) {\n              return null;\n            }\n            result = buf.slice(buf.roffset, buf.roffset + length).buffer;\n            buf.skipRead(length);\n            return buildDecodeResult(result, 3 + length);\n          case 198:\n            length = buf.readUInt32BE();\n            if (!isValidDataSize(length, bufLength, 5)) {\n              return null;\n            }\n            result = buf.slice(buf.roffset, buf.roffset + length).buffer;\n            buf.skipRead(length);\n            return buildDecodeResult(result, 5 + length);\n          case 220:\n            if (bufLength < 3) {\n              return null;\n            }\n            length = buf.readUInt16BE();\n            return this.decodeArray(buf, length, 3);\n          case 221:\n            if (bufLength < 5) {\n              return null;\n            }\n            length = buf.readUInt32BE();\n            return this.decodeArray(buf, length, 5);\n          case 222:\n            length = buf.readUInt16BE();\n            return this.decodeMap(buf, length, 3);\n          case 223:\n            throw new Error(\"map too big to decode in JS\");\n          case 212:\n            return this.decodeFixExt(buf, 1);\n          case 213:\n            return this.decodeFixExt(buf, 2);\n          case 214:\n            return this.decodeFixExt(buf, 4);\n          case 215:\n            return this.decodeFixExt(buf, 8);\n          case 216:\n            return this.decodeFixExt(buf, 16);\n          case 199:\n            length = buf.readUInt8();\n            type = buf.readUInt8();\n            if (!type || !length || !isValidDataSize(length, bufLength, 3)) {\n              return null;\n            }\n            return this.decodeExt(buf, type, length, 3);\n          case 200:\n            length = buf.readUInt16BE();\n            type = buf.readUInt8();\n            if (!type || !length || !isValidDataSize(length, bufLength, 4)) {\n              return null;\n            }\n            return this.decodeExt(buf, type, length, 4);\n          case 201:\n            length = buf.readUInt32BE();\n            type = buf.readUInt8();\n            if (!type || !length || !isValidDataSize(length, bufLength, 6)) {\n              return null;\n            }\n            return this.decodeExt(buf, type, length, 6);\n        }\n        if ((first & 240) === 144) {\n          length = first & 15;\n          return this.decodeArray(buf, length, 1);\n        } else if ((first & 240) === 128) {\n          length = first & 15;\n          return this.decodeMap(buf, length, 1);\n        } else if ((first & 224) === 160) {\n          length = first & 31;\n          if (isValidDataSize(length, bufLength, 1)) {\n            result = buf.toString(\"utf8\", buf.roffset, buf.roffset + length);\n            buf.skipRead(length);\n            return buildDecodeResult(result, length + 1);\n          }\n          return null;\n        } else if (first >= 224) {\n          result = first - 256;\n          return buildDecodeResult(result, 1);\n        } else if (first < 128) {\n          return buildDecodeResult(first, 1);\n        }\n        throw new Error(\"Not implemented yet\");\n      }\n      decodeMap(buf, length, headerLength) {\n        const result = {};\n        let key;\n        let totalBytesConsumed = 0;\n        for (let i = 0; i < length; ++i) {\n          const keyResult = this.tryDecode(buf);\n          if (keyResult) {\n            const valueResult = this.tryDecode(buf);\n            if (valueResult) {\n              key = keyResult.value;\n              result[key] = valueResult.value;\n              totalBytesConsumed += keyResult.bytesConsumed + valueResult.bytesConsumed;\n            } else {\n              return null;\n            }\n          } else {\n            return null;\n          }\n        }\n        return buildDecodeResult(result, headerLength + totalBytesConsumed);\n      }\n      decodeArray(buf, length, headerLength) {\n        const result = [];\n        let totalBytesConsumed = 0;\n        for (let i = 0; i < length; ++i) {\n          const decodeResult = this.tryDecode(buf);\n          if (decodeResult) {\n            result.push(decodeResult.value);\n            totalBytesConsumed += decodeResult.bytesConsumed;\n          } else {\n            return null;\n          }\n        }\n        return buildDecodeResult(result, headerLength + totalBytesConsumed);\n      }\n      decodeFixExt(buf, size) {\n        const type = buf.readUInt8();\n        return this.decodeExt(buf, type, size, 2);\n      }\n      decodeExt(buf, type, size, headerSize) {\n        const decTypes = this.decodingTypes;\n        const decode = decTypes.get(type);\n        if (decode) {\n          const value = decode(buf.slice(buf.roffset, buf.roffset + size));\n          buf.skipRead(size);\n          return buildDecodeResult(value, headerSize + size);\n        }\n        if (type === 0) {\n          const val = buf.readUInt8();\n          if (val === 0) {\n            return buildDecodeResult(void 0, headerSize + size);\n          }\n        }\n        throw new Error(`Unable to find ext type ${type}`);\n      }\n    };\n  }\n});\n\n// ../messagepack/dist/serializer.js\nvar Serializer;\nvar init_serializer = __esm({\n  \"../messagepack/dist/serializer.js\"() {\n    \"use strict\";\n    init_process_shim();\n    init_dist2();\n    init_encoder();\n    init_decoder();\n    Serializer = class {\n      static {\n        __name(this, \"Serializer\");\n      }\n      constructor(initialCapacity = 64) {\n        this.initialCapacity = initialCapacity;\n        this.encodingTypes = /* @__PURE__ */ new Map();\n        this.decodingTypes = /* @__PURE__ */ new Map();\n        this.encoder = new Encoder(this.encodingTypes);\n        this.decoder = new Decoder(this.decodingTypes);\n      }\n      registerEncoder(type, check, encode) {\n        this.encodingTypes.set(type, { check, encode });\n        return this;\n      }\n      registerDecoder(type, decode) {\n        this.decodingTypes.set(type, decode);\n        return this;\n      }\n      register(type, constructor, encode, decode) {\n        if (type < 0 || type > 127) {\n          throw new RangeError(`Bad type: 0 <= ${type} <= 127`);\n        }\n        this.registerEncoder(type, (obj) => obj instanceof constructor, (obj) => {\n          const extBuf = new SmartBuffer(this.initialCapacity, true);\n          encode(obj, extBuf);\n          return extBuf;\n        });\n        this.registerDecoder(type, decode);\n        return this;\n      }\n      encode(x, buf) {\n        return this.encoder.encode(x, buf);\n      }\n      decode(buf) {\n        return this.decoder.decode(buf);\n      }\n    };\n  }\n});\n\n// ../messagepack/dist/errors.js\nvar errorIdMap, stdIdMap, stdErrors, idErrorMap, keys, createError, getStdErrorId;\nvar init_errors = __esm({\n  \"../messagepack/dist/errors.js\"() {\n    \"use strict\";\n    init_process_shim();\n    errorIdMap = {};\n    stdIdMap = {};\n    stdErrors = [];\n    idErrorMap = {\n      1: Error,\n      2: SyntaxError,\n      3: TypeError,\n      4: ReferenceError,\n      5: RangeError,\n      6: EvalError,\n      7: URIError\n    };\n    keys = Object.keys(idErrorMap).map((v) => +v);\n    for (let i = 0; i < keys.length; i++) {\n      const errCode = keys[i];\n      const ExceptionClass = idErrorMap[errCode];\n      errorIdMap[ExceptionClass] = errCode;\n      stdErrors.push(ExceptionClass);\n      stdIdMap[ExceptionClass.name] = errCode;\n    }\n    createError = /* @__PURE__ */ __name((id, message, stack) => {\n      const err = new idErrorMap[id](message);\n      err.stack = stack;\n      return err;\n    }, \"createError\");\n    getStdErrorId = /* @__PURE__ */ __name((err) => stdIdMap[err.constructor.name] ?? stdIdMap[Error.name], \"getStdErrorId\");\n  }\n});\n\n// ../messagepack/dist/index.js\nvar registerCommonTypesFor, serializer;\nvar init_dist3 = __esm({\n  \"../messagepack/dist/index.js\"() {\n    \"use strict\";\n    init_process_shim();\n    init_long();\n    init_serializer();\n    init_errors();\n    registerCommonTypesFor = /* @__PURE__ */ __name((s) => {\n      s.register(126, Error, (obj, buf) => {\n        buf.writeUInt16BE(getStdErrorId(obj));\n        s.encode(obj.name, buf);\n        s.encode(obj.stack, buf);\n        s.encode(obj.message, buf);\n        const customFields = Object.keys(obj).filter((key) => ![\"stack\", \"message\", \"name\"].includes(key) && obj[key] !== void 0);\n        buf.writeUInt16BE(customFields.length);\n        for (const key of customFields) {\n          s.encode(key, buf);\n          s.encode(obj[key], buf);\n        }\n      }, (buf) => {\n        const id = buf.readUInt16BE();\n        const name = s.decode(buf);\n        const stack = s.decode(buf);\n        const message = s.decode(buf);\n        const error = createError(id, message, stack);\n        error.name = name;\n        const customFieldsCount = buf.readUInt16BE();\n        for (let i = 0; i < customFieldsCount; i++) {\n          const key = s.decode(buf);\n          const value = s.decode(buf);\n          error[key] = value;\n        }\n        return error;\n      });\n      s.register(125, Date, (obj, buf) => {\n        buf.writeUInt64BE(obj.getTime());\n      }, (buf) => new Date(buf.readUInt64BE().toNumber()));\n      s.register(124, Map, (obj, buf) => {\n        buf.writeUInt32BE(obj.size);\n        for (const [key, val] of obj.entries()) {\n          s.encode(key, buf);\n          s.encode(val, buf);\n        }\n      }, (buf) => {\n        const map = /* @__PURE__ */ new Map();\n        const size = buf.readUInt32BE();\n        for (let i = 0; i < size; i++) {\n          const key = s.decode(buf);\n          const val = s.decode(buf);\n          map.set(key, val);\n        }\n        return map;\n      });\n      s.register(123, Set, (obj, buf) => {\n        buf.writeUInt32BE(obj.size);\n        for (const val of obj.values()) {\n          s.encode(val, buf);\n        }\n      }, (buf) => {\n        const set = /* @__PURE__ */ new Set();\n        const size = buf.readUInt32BE();\n        for (let i = 0; i < size; i++) {\n          const val = s.decode(buf);\n          set.add(val);\n        }\n        return set;\n      });\n      s.register(121, RegExp, (obj, buf) => {\n        s.encode(obj.source, buf);\n        s.encode(obj.flags, buf);\n      }, (buf) => {\n        const source = s.decode(buf);\n        const flags = s.decode(buf);\n        return new RegExp(source, flags);\n      });\n      s.register(120, BigInt, (obj, buf) => {\n        const str = obj.toString();\n        s.encode(str, buf);\n      }, (buf) => {\n        const str = s.decode(buf);\n        return BigInt(str);\n      });\n      s.register(119, long_default, (obj, buf) => {\n        buf.writeInt8(obj.unsigned ? 1 : 0);\n        if (obj.unsigned) {\n          buf.writeUInt64BE(obj);\n        } else {\n          buf.writeInt64BE(obj);\n        }\n      }, (buf) => {\n        const unsigned = Boolean(buf.readInt8());\n        return unsigned ? buf.readUInt64BE() : buf.readInt64BE();\n      });\n    }, \"registerCommonTypesFor\");\n    serializer = new Serializer();\n    registerCommonTypesFor(serializer);\n  }\n});\n\n// src/netron/definition.ts\nvar Definition;\nvar init_definition = __esm({\n  \"src/netron/definition.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    init_uid();\n    Definition = class {\n      /**\n       * Constructs a new Definition instance with the specified parameters.\n       *\n       * @param {string} id - A unique identifier for the service definition. This should be\n       *                      generated using the static nextId() method to ensure uniqueness.\n       * @param {string} peerId - The identifier of the peer that owns or provides this service.\n       *                          This links the service to its provider in the network.\n       * @param {ServiceMetadata} meta - The service metadata object containing detailed\n       *                                information about the service's capabilities and interface.\n       * @throws {Error} If the provided id is not a valid UUID or if the metadata is incomplete.\n       */\n      constructor(id, peerId, meta) {\n        this.id = id;\n        this.peerId = peerId;\n        this.meta = meta;\n      }\n      static {\n        __name(this, \"Definition\");\n      }\n      /**\n       * The identifier of the parent service definition, if this service is part of a hierarchy.\n       * This property enables the creation of service trees and facilitates service composition.\n       *\n       * @type {string}\n       * @default ''\n       */\n      parentId = \"\";\n      /**\n       * Generates a new cryptographically secure unique identifier using the Node.js crypto module.\n       * This method uses the randomUUID() function to create a version 4 UUID that is suitable\n       * for use as a service definition identifier.\n       *\n       * @static\n       * @returns {string} A new UUID v4 string that can be used as a unique identifier.\n       * @example\n       * const newId = Definition.nextId();\n       * // Returns something like: '123e4567-e89b-12d3-a456-426614174000'\n       */\n      static nextId() {\n        return randomUUID();\n      }\n    };\n  }\n});\n\n// src/netron/packet/serializer.ts\nasync function ensureStreamReferenceRegistered() {\n  if (streamReferenceRegistered) {\n    return;\n  }\n  try {\n    const module = await Promise.resolve().then(() => (init_stream_reference(), stream_reference_exports));\n    StreamReferenceClass = module.StreamReference;\n    serializer2.register(\n      107,\n      StreamReferenceClass,\n      /**\n       * Encodes a StreamReference object into a binary buffer.\n       * Serializes the stream's identity, type, liveness status, and associated peer.\n       *\n       * @param {StreamReference} obj - The StreamReference object to encode\n       * @param {SmartBuffer} buf - The buffer to write the encoded data to\n       */\n      (obj, buf) => {\n        serializer2.encode(obj.streamId.toString(), buf);\n        buf.writeUInt8(obj.type === \"writable\" ? 1 : 0);\n        buf.writeUInt8(obj.isLive ? 1 : 0);\n        serializer2.encode(obj.peerId, buf);\n      },\n      /**\n       * Decodes a StreamReference object from a binary buffer.\n       * Reconstructs the stream reference with its type, liveness status,\n       * and associated peer information.\n       *\n       * @param {SmartBuffer} buf - The buffer containing the encoded StreamReference\n       * @returns {StreamReference} A new StreamReference instance with restored properties\n       */\n      (buf) => {\n        const streamId = Number(serializer2.decode(buf));\n        const streamType = buf.readUInt8() === 1 ? \"writable\" : \"readable\";\n        const isLive = buf.readUInt8() === 1;\n        const peerId = serializer2.decode(buf);\n        return new StreamReferenceClass(streamId, streamType, isLive, peerId);\n      }\n    );\n    streamReferenceRegistered = true;\n  } catch (error) {\n    console.error(\"Failed to register StreamReference:\", error);\n    throw error;\n  }\n}\nvar serializer2, streamReferenceRegistered, StreamReferenceClass, originalEncode, originalDecode;\nvar init_serializer2 = __esm({\n  \"src/netron/packet/serializer.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    init_dist3();\n    init_reference();\n    init_definition();\n    serializer2 = new Serializer();\n    registerCommonTypesFor(serializer2);\n    serializer2.register(\n      109,\n      Definition,\n      /**\n       * Encodes a Definition object into a binary buffer.\n       * The encoding process preserves the object's identity and relationships\n       * by serializing its id, parentId, peerId, and metadata.\n       *\n       * @param {Definition} obj - The Definition object to encode\n       * @param {SmartBuffer} buf - The buffer to write the encoded data to\n       */\n      (obj, buf) => {\n        serializer2.encode(obj.id, buf);\n        serializer2.encode(obj.parentId, buf);\n        serializer2.encode(obj.peerId, buf);\n        serializer2.encode(obj.meta, buf);\n      },\n      /**\n       * Decodes a Definition object from a binary buffer.\n       * Reconstructs the object's state by reading its properties in the same\n       * order they were written during encoding.\n       *\n       * @param {SmartBuffer} buf - The buffer containing the encoded Definition\n       * @returns {Definition} A new Definition instance with restored properties\n       */\n      (buf) => {\n        const id = serializer2.decode(buf);\n        const parentId = serializer2.decode(buf);\n        const peerId = serializer2.decode(buf);\n        const meta = serializer2.decode(buf);\n        const def = new Definition(id, peerId, meta);\n        def.parentId = parentId;\n        return def;\n      }\n    ).register(\n      108,\n      Reference,\n      /**\n       * Encodes a Reference object into a binary buffer.\n       * Only the defId property is serialized as it uniquely identifies\n       * the referenced service definition.\n       *\n       * @param {Reference} obj - The Reference object to encode\n       * @param {SmartBuffer} buf - The buffer to write the encoded data to\n       */\n      (obj, buf) => {\n        serializer2.encode(obj.defId, buf);\n      },\n      /**\n       * Decodes a Reference object from a binary buffer.\n       * Creates a new Reference instance using the decoded defId.\n       *\n       * @param {SmartBuffer} buf - The buffer containing the encoded Reference\n       * @returns {Reference} A new Reference instance with the restored defId\n       */\n      (buf) => new Reference(serializer2.decode(buf))\n    );\n    streamReferenceRegistered = false;\n    StreamReferenceClass = null;\n    __name(ensureStreamReferenceRegistered, \"ensureStreamReferenceRegistered\");\n    originalEncode = serializer2.encode.bind(serializer2);\n    originalDecode = serializer2.decode.bind(serializer2);\n    serializer2.encode = function(value, buffer) {\n      if (value && value.constructor && value.constructor.name === \"StreamReference\" && !streamReferenceRegistered) {\n        Promise.resolve(ensureStreamReferenceRegistered()).catch(console.error);\n      }\n      return originalEncode(value, buffer);\n    };\n    serializer2.decode = function(buffer) {\n      return originalDecode(buffer);\n    };\n  }\n});\n\n// src/netron/packet/index.ts\nvar createPacket;\nvar init_packet2 = __esm({\n  \"src/netron/packet/index.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    init_dist2();\n    init_packet();\n    init_serializer2();\n    init_types();\n    init_types();\n    createPacket = /* @__PURE__ */ __name((id, impulse, action, data) => {\n      const packet = new Packet(id);\n      packet.setImpulse(impulse);\n      packet.setType(action);\n      packet.data = data;\n      return packet;\n    }, \"createPacket\");\n  }\n});\n\n// src/netron/writable-stream.ts\nvar uid2, NetronWritableStream;\nvar init_writable_stream = __esm({\n  \"src/netron/writable-stream.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    init_stream();\n    init_uid();\n    init_packet2();\n    uid2 = new Uid();\n    NetronWritableStream = class _NetronWritableStream extends Writable {\n      static {\n        __name(this, \"NetronWritableStream\");\n      }\n      /** Unique identifier for this stream instance */\n      id;\n      /** The remote peer this stream is associated with */\n      peer;\n      /** Current chunk index for maintaining write order */\n      index = 0;\n      /** Whether the stream is operating in live/real-time mode */\n      isLive;\n      /** Flag indicating if the stream has been closed */\n      isClosed = false;\n      /**\n       * Creates a new NetronWritableStream instance.\n       *\n       * @constructor\n       * @param {NetronWritableStreamOptions} options - Configuration options for the stream\n       * @param {RemotePeer} options.peer - The remote peer this stream is associated with\n       * @param {number} [options.streamId] - Optional custom stream identifier\n       * @param {boolean} [options.isLive=false] - Whether the stream is operating in live mode\n       * @param {WritableOptions} [options] - Additional Node.js stream options\n       */\n      constructor({ peer, streamId, isLive = false, ...opts }) {\n        super({ ...opts, objectMode: true });\n        this.peer = peer;\n        this.isLive = isLive;\n        this.id = streamId ?? uid2.next();\n        this.peer.logger.info({ streamId: this.id, isLive }, \"Creating writable stream\");\n        this.peer.writableStreams.set(this.id, this);\n        this.once(\"close\", this.cleanup);\n      }\n      /**\n       * Pipes data from an AsyncIterable or Readable stream into this stream.\n       * Handles backpressure and ensures proper cleanup on errors.\n       *\n       * @param {AsyncIterable<any> | Readable} source - The source stream to pipe from\n       * @returns {Promise<void>} A promise that resolves when piping is complete\n       * @throws {Error} If an error occurs during the piping process\n       */\n      async pipeFrom(source) {\n        this.peer.logger.debug({ streamId: this.id }, \"Starting pipe operation\");\n        try {\n          for await (const chunk of source) {\n            if (!this.write(chunk)) {\n              this.peer.logger.debug({ streamId: this.id }, \"Stream backpressure detected\");\n              await new Promise((resolve) => this.once(\"drain\", resolve));\n            }\n          }\n          this.end();\n          this.peer.logger.debug({ streamId: this.id }, \"Pipe operation completed\");\n        } catch (error) {\n          this.peer.logger.error({ streamId: this.id, error }, \"Pipe operation failed\");\n          this.destroy(error instanceof Error ? error : new Error(String(error)));\n        }\n      }\n      /**\n       * Internal write implementation for handling stream chunks.\n       * Sends data to the remote peer and manages stream state.\n       *\n       * @override\n       * @param {any} chunk - The data chunk to write\n       * @param {BufferEncoding} _ - Unused encoding parameter\n       * @param {(error?: Error | null) => void} callback - Callback to signal write completion\n       */\n      _write(chunk, _, callback) {\n        if (this.isClosed) {\n          this.peer.logger.warn({ streamId: this.id }, \"Attempt to write to closed stream\");\n          callback(new Error(\"Stream is already closed\"));\n          return;\n        }\n        this.peer.logger.debug({ streamId: this.id, index: this.index }, \"Writing chunk\");\n        this.peer.sendStreamChunk(this.id, chunk, this.index++, false, this.isLive).then(() => callback()).catch((err) => {\n          this.peer.logger.error({ streamId: this.id, error: err }, \"Error sending stream chunk\");\n          this.peer.sendPacket(\n            createPacket(Packet.nextId(), 1, TYPE_STREAM_ERROR, {\n              streamId: this.id,\n              message: err.message\n            })\n          ).catch((sendErr) => {\n            this.peer.logger.error({ streamId: this.id, error: sendErr }, \"Failed to send stream error packet\");\n          });\n          callback(err);\n        });\n      }\n      /**\n       * Internal final implementation for handling stream completion.\n       * Sends final chunk to remote peer and performs cleanup.\n       *\n       * @override\n       * @param {(error?: Error | null) => void} callback - Callback to signal finalization completion\n       */\n      _final(callback) {\n        if (this.isClosed) {\n          this.peer.logger.warn({ streamId: this.id }, \"Attempt to finalize closed stream\");\n          callback(new Error(\"Stream is already closed\"));\n          return;\n        }\n        this.peer.logger.debug({ streamId: this.id, index: this.index }, \"Sending final chunk\");\n        this.peer.sendStreamChunk(this.id, null, this.index, true, this.isLive).then(() => callback()).catch((err) => {\n          this.peer.logger.error({ streamId: this.id, error: err }, \"Error sending final chunk\");\n          callback(err);\n        }).finally(() => this.closeStream());\n      }\n      /**\n       * Gracefully closes the stream and performs cleanup.\n       * This method ensures proper resource cleanup and state management.\n       */\n      closeStream() {\n        if (this.isClosed) {\n          this.peer.logger.warn({ streamId: this.id }, \"Attempt to close already closed stream\");\n          return;\n        }\n        this.peer.logger.info({ streamId: this.id }, \"Closing stream\");\n        this.isClosed = true;\n        this.end();\n        this.cleanup();\n      }\n      /**\n       * Overrides the destroy method to ensure proper cleanup and error handling.\n       * Sends a close notification packet to the remote peer for immediate stream termination.\n       *\n       * @override\n       * @param {Error} [error] - Optional error that caused the destruction\n       * @returns {this} The stream instance for chaining\n       */\n      destroy(error) {\n        if (this.isClosed) {\n          this.peer.logger.warn({ streamId: this.id }, \"Attempt to destroy already closed stream\");\n          return this;\n        }\n        this.peer.logger.info({ streamId: this.id, error }, \"Destroying stream\");\n        this.isClosed = true;\n        this.cleanup();\n        super.destroy(error);\n        const closeReason = error ? error.message : \"Stream destroyed\";\n        this.peer.sendPacket(createPacket(Packet.nextId(), 1, TYPE_STREAM_CLOSE, {\n          streamId: this.id,\n          reason: closeReason\n        })).catch((sendError) => {\n          this.peer.logger.error({ streamId: this.id, error: sendError }, \"Failed to send stream close packet\");\n        });\n        return this;\n      }\n      /**\n       * Internal cleanup method that removes stream references from the peer.\n       * This ensures proper garbage collection and prevents memory leaks.\n       */\n      cleanup = /* @__PURE__ */ __name(() => {\n        this.peer.logger.debug({ streamId: this.id }, \"Cleaning up stream resources\");\n        this.peer.writableStreams.delete(this.id);\n      }, \"cleanup\");\n      /**\n       * Factory method for creating a NetronWritableStream instance.\n       * Optionally pipes data from a source stream if provided.\n       *\n       * @static\n       * @param {RemotePeer} peer - The remote peer this stream is associated with\n       * @param {AsyncIterable<any> | Readable} [source] - Optional source stream to pipe from\n       * @param {boolean} [isLive=false] - Whether the stream is operating in live mode\n       * @param {number} [streamId] - Optional custom stream identifier\n       * @returns {NetronWritableStream} A new stream instance\n       */\n      static create(peer, source, isLive = false, streamId) {\n        const stream = new _NetronWritableStream({ peer, streamId, isLive });\n        if (source) {\n          stream.pipeFrom(source);\n        }\n        return stream;\n      }\n    };\n  }\n});\n\n// src/netron/stream-reference.ts\nvar stream_reference_exports = {};\n__export(stream_reference_exports, {\n  StreamReference: () => StreamReference\n});\nvar StreamReference;\nvar init_stream_reference = __esm({\n  \"src/netron/stream-reference.ts\"() {\n    \"use strict\";\n    init_process_shim();\n    init_readable_stream();\n    init_writable_stream();\n    StreamReference = class _StreamReference {\n      /**\n       * Creates a new StreamReference instance.\n       *\n       * @param {number} streamId - Unique identifier of the stream\n       * @param {StreamReferenceType} type - Type of the stream (readable or writable)\n       * @param {boolean} isLive - Indicates if the stream is live/real-time\n       * @param {string} peerId - ID of the peer that owns the stream\n       */\n      constructor(streamId, type, isLive, peerId) {\n        this.streamId = streamId;\n        this.type = type;\n        this.isLive = isLive;\n        this.peerId = peerId;\n      }\n      static {\n        __name(this, \"StreamReference\");\n      }\n      /**\n       * Creates a StreamReference from an existing stream instance.\n       * This method is used to serialize a local stream for transmission over the network.\n       *\n       * @static\n       * @param {NetronReadableStream | NetronWritableStream} stream - The stream instance to reference\n       * @returns {StreamReference} A new StreamReference representing the given stream\n       */\n      static from(stream) {\n        return new _StreamReference(\n          stream.id,\n          stream instanceof NetronWritableStream ? \"writable\" : \"readable\",\n          stream.isLive,\n          stream.peer.id\n        );\n      }\n      /**\n       * Creates a stream instance from a StreamReference.\n       * This method is used to deserialize a stream reference into a working stream instance\n       * on the receiving end of a network transmission.\n       *\n       * @static\n       * @param {StreamReference} ref - The stream reference to convert\n       * @param {RemotePeer} peer - The remote peer that owns the stream\n       * @returns {NetronReadableStream | NetronWritableStream} A new stream instance\n       * @throws {Error} If the stream type is invalid or creation fails\n       */\n      static to(ref, peer) {\n        if (ref.type === \"writable\") {\n          return NetronReadableStream.create(peer, ref.streamId, ref.isLive);\n        } else {\n          return NetronWritableStream.create(peer, void 0, ref.isLive, ref.streamId);\n        }\n      }\n    };\n  }\n});\n\n// src/netron/netron.ts\ninit_process_shim();\n\n// src/netron/transport/http/client.ts\ninit_process_shim();\n\n// src/netron/transport/http/connection.ts\ninit_process_shim();\n\n// ../eventemitter/dist/index.js\ninit_process_shim();\n\n// ../eventemitter/dist/types.js\ninit_process_shim();\n\n// ../eventemitter/dist/emitter.js\ninit_process_shim();\ninit_dist();\nvar EventEmitter = class {\n  static {\n    __name(this, \"EventEmitter\");\n  }\n  constructor(concurrency) {\n    this._events = /* @__PURE__ */ new Map();\n    this._eventsCount = 0;\n    this.onceListeners = /* @__PURE__ */ new WeakMap();\n    if (concurrency && concurrency >= 1) {\n      this.setConcurrency(concurrency);\n    }\n  }\n  eventNames() {\n    return Array.from(this._events.keys());\n  }\n  listeners(event) {\n    const handlers = this._events.get(event);\n    if (!handlers)\n      return [];\n    if (!Array.isArray(handlers)) {\n      return [handlers.fn];\n    }\n    return handlers.map((h) => h.fn);\n  }\n  listenerCount(event) {\n    const handlers = this._events.get(event);\n    if (!handlers)\n      return 0;\n    if (!Array.isArray(handlers))\n      return 1;\n    return handlers.length;\n  }\n  emit(event, ...args) {\n    const handlers = this._events.get(event);\n    if (!handlers)\n      return false;\n    if (!Array.isArray(handlers)) {\n      if (handlers.once) {\n        this.removeListener(event, handlers.fn);\n      }\n      handlers.fn.apply(handlers.context, args);\n    } else {\n      const handlersCopy = handlers.slice();\n      for (let i = 0; i < handlersCopy.length; i++) {\n        const handler = handlersCopy[i];\n        if (handler && handler.once) {\n          this.removeListener(event, handler.fn);\n        }\n        if (handler) {\n          handler.fn.apply(handler.context, args);\n        }\n      }\n    }\n    return true;\n  }\n  on(event, fn, context) {\n    return this.addListener(event, fn, context, false);\n  }\n  addListener(event, fn, context, once = false) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"The listener must be a function\");\n    }\n    const listener = {\n      fn,\n      context: context || this,\n      once: once || false\n    };\n    const existing = this._events.get(event);\n    if (!existing) {\n      this._events.set(event, listener);\n      this._eventsCount++;\n    } else if (!Array.isArray(existing)) {\n      this._events.set(event, [existing, listener]);\n    } else {\n      existing.push(listener);\n    }\n    return this;\n  }\n  once(event, fn, context) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"The listener must be a function\");\n    }\n    let fired = false;\n    const onceListener = /* @__PURE__ */ __name((...args) => {\n      this.removeListener(event, onceListener);\n      if (!fired) {\n        fired = true;\n        return fn.apply(context || this, args);\n      }\n      return void 0;\n    }, \"onceListener\");\n    this.on(event, onceListener);\n    this.onceListeners.set(fn, onceListener);\n    return this;\n  }\n  removeListener(event, fn) {\n    const onceListener = this.onceListeners.get(fn);\n    if (onceListener) {\n      this.onceListeners.delete(fn);\n      fn = onceListener;\n    }\n    const handlers = this._events.get(event);\n    if (!handlers)\n      return this;\n    if (!Array.isArray(handlers)) {\n      if (handlers.fn === fn) {\n        this._events.delete(event);\n        this._eventsCount--;\n      }\n    } else {\n      const filtered = handlers.filter((h) => h.fn !== fn);\n      if (filtered.length === 0) {\n        this._events.delete(event);\n        this._eventsCount--;\n      } else if (filtered.length === 1 && filtered[0]) {\n        this._events.set(event, filtered[0]);\n      } else {\n        this._events.set(event, filtered);\n      }\n    }\n    return this;\n  }\n  off(event, fn) {\n    return this.removeListener(event, fn);\n  }\n  removeAllListeners(event) {\n    if (event) {\n      if (this._events.has(event)) {\n        this._events.delete(event);\n        this._eventsCount--;\n      }\n    } else {\n      this._events.clear();\n      this._eventsCount = 0;\n    }\n    return this;\n  }\n  setConcurrency(concurrency) {\n    if (concurrency >= 1) {\n      this.limiter = pLimit(concurrency);\n    }\n    return this;\n  }\n  emitParallel(event, ...args) {\n    const promises = this.listeners(event).map((listener) => this._executeListener(listener, args));\n    return Promise.all(promises);\n  }\n  emitSerial(event, ...args) {\n    return this.listeners(event).reduce((promise, listener) => promise.then((values) => this._executeListener(listener, args).then((value) => {\n      values.push(value);\n      return values;\n    })), Promise.resolve([]));\n  }\n  emitReduce(event, ...args) {\n    return this._emitReduceRun(event, args);\n  }\n  emitReduceRight(event, ...args) {\n    return this._emitReduceRun(event, args, true);\n  }\n  subscribe(event, listener, once = false) {\n    const unsubscribe = /* @__PURE__ */ __name(() => {\n      this.removeListener(event, listener);\n    }, \"unsubscribe\");\n    if (once) {\n      this.once(event, listener);\n    } else {\n      this.on(event, listener);\n    }\n    return unsubscribe;\n  }\n  _emitReduceRun(event, args, inverse = false) {\n    const listeners = inverse ? this.listeners(event).reverse() : this.listeners(event);\n    return listeners.reduce((promise, listener) => promise.then((prevArgs) => {\n      const currentArgs = Array.isArray(prevArgs) ? prevArgs : [prevArgs];\n      return this._executeListener(listener, currentArgs);\n    }), Promise.resolve(args));\n  }\n  _executeListener(listener, args) {\n    try {\n      if (this.limiter) {\n        return this.limiter(() => listener(...args));\n      }\n      return Promise.resolve(listener(...args));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n};\n\n// ../eventemitter/dist/history.js\ninit_process_shim();\n\n// ../eventemitter/dist/metrics.js\ninit_process_shim();\n\n// ../eventemitter/dist/wildcard.js\ninit_process_shim();\n\n// ../eventemitter/dist/scheduler.js\ninit_process_shim();\n\n// ../eventemitter/dist/predicates.js\ninit_process_shim();\n\n// ../eventemitter/dist/enhanced-emitter.js\ninit_process_shim();\n\n// src/netron/transport/types.ts\ninit_process_shim();\ninit_packet();\n\n// src/netron/errors.ts\ninit_process_shim();\nvar ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {\n  ErrorCode2[\"UNAUTHORIZED\"] = \"UNAUTHORIZED\";\n  ErrorCode2[\"FORBIDDEN\"] = \"FORBIDDEN\";\n  ErrorCode2[\"NOT_FOUND\"] = \"NOT_FOUND\";\n  ErrorCode2[\"INVALID_REQUEST\"] = \"INVALID_REQUEST\";\n  ErrorCode2[\"INTERNAL_ERROR\"] = \"INTERNAL_ERROR\";\n  ErrorCode2[\"SERVICE_UNAVAILABLE\"] = \"SERVICE_UNAVAILABLE\";\n  ErrorCode2[\"TIMEOUT\"] = \"TIMEOUT\";\n  ErrorCode2[\"REQUEST_TIMEOUT\"] = \"REQUEST_TIMEOUT\";\n  return ErrorCode2;\n})(ErrorCode || {});\nvar TitanError = class extends Error {\n  static {\n    __name(this, \"TitanError\");\n  }\n  code;\n  details;\n  constructor(message, code, details) {\n    if (typeof message === \"object\") {\n      super(message.message);\n      this.code = message.code ?? \"INTERNAL_ERROR\" /* INTERNAL_ERROR */;\n      this.details = message.details;\n    } else {\n      super(message);\n      this.code = code ?? \"INTERNAL_ERROR\" /* INTERNAL_ERROR */;\n      this.details = details;\n    }\n    this.name = \"TitanError\";\n  }\n};\n\n// src/netron/transport/http/types.ts\ninit_process_shim();\nfunction isHttpResponseMessage(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  return typeof value.id === \"string\" && value.version === \"2.0\" && typeof value.timestamp === \"number\" && typeof value.success === \"boolean\" && (value.success ? \"data\" in value : \"error\" in value);\n}\n__name(isHttpResponseMessage, \"isHttpResponseMessage\");\nfunction generateRequestId() {\n  return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n}\n__name(generateRequestId, \"generateRequestId\");\nfunction createRequestMessage(service, method, input, options) {\n  return {\n    id: options?.id || generateRequestId(),\n    version: \"2.0\",\n    timestamp: Date.now(),\n    service,\n    method,\n    input,\n    context: options?.context,\n    hints: options?.hints\n  };\n}\n__name(createRequestMessage, \"createRequestMessage\");\n\n// src/netron/transport/http/connection.ts\nvar HttpConnection = class extends EventEmitter {\n  static {\n    __name(this, \"HttpConnection\");\n  }\n  id;\n  _state = \"connecting\" /* CONNECTING */;\n  baseUrl;\n  options;\n  abortController;\n  // Service discovery cache\n  services = /* @__PURE__ */ new Map();\n  contracts = /* @__PURE__ */ new Map();\n  discoveryPromise = null;\n  // Request tracking\n  pendingRequests = /* @__PURE__ */ new Map();\n  get state() {\n    return this._state;\n  }\n  get remoteAddress() {\n    return this.baseUrl;\n  }\n  get localAddress() {\n    return void 0;\n  }\n  constructor(baseUrl, options) {\n    super();\n    this.id = this.generateId();\n    this.baseUrl = baseUrl.endsWith(\"/\") ? baseUrl.slice(0, -1) : baseUrl;\n    this.options = options || {};\n    this.initializeConnection();\n  }\n  /**\n   * Initialize the connection\n   */\n  async initializeConnection() {\n    this._state = \"connected\" /* CONNECTED */;\n    setImmediate(() => {\n      this.emit(\"connect\");\n      this.discoverServices().catch((err) => {\n        console.warn(\"Failed to pre-load service discovery:\", err);\n      });\n    });\n  }\n  /**\n   * Generate unique connection ID\n   */\n  generateId() {\n    return `http-direct-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n  }\n  /**\n   * Discover services from the HTTP server\n   */\n  async discoverServices() {\n    if (this.discoveryPromise) {\n      return this.discoveryPromise;\n    }\n    this.discoveryPromise = this._discoverServices();\n    return this.discoveryPromise;\n  }\n  async _discoverServices() {\n    try {\n      const discoveryTimeout = 5e3;\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error(\"Discovery timeout\")), discoveryTimeout);\n      });\n      const response = await Promise.race([\n        this.sendHttpRequest(\n          \"GET\",\n          \"/netron/discovery\"\n        ),\n        timeoutPromise\n      ]);\n      if (response.services) {\n        for (const [name, service] of Object.entries(response.services)) {\n          const definition = {\n            id: `${name}-${service.version}`,\n            meta: {\n              name,\n              version: service.version,\n              methods: service.methods.reduce((acc, method) => {\n                acc[method] = { name: method };\n                return acc;\n              }, {}),\n              properties: {},\n              ...service.metadata\n            },\n            parentId: \"\",\n            peerId: this.id\n          };\n          this.services.set(name, definition);\n        }\n      }\n      if (response.contracts) {\n        for (const [name, contract] of Object.entries(response.contracts)) {\n          this.contracts.set(name, contract);\n        }\n      }\n    } catch (error) {\n      console.warn(\"Service discovery failed:\", error);\n    }\n  }\n  /**\n   * Send data using native HTTP messaging\n   */\n  async send(data) {\n    const buffer = Buffer.isBuffer(data) ? data : data instanceof Uint8Array ? Buffer.from(data) : Buffer.from(data);\n    try {\n      const str = buffer.toString();\n      const msg = JSON.parse(str);\n      if (msg.type === \"request\" || msg.service) {\n        const request = createRequestMessage(\n          msg.service || \"__system\",\n          msg.method || msg.type,\n          msg.input || msg.data\n        );\n        const response = await this.sendRequestMessage(request);\n        this.emit(\"message\", Buffer.from(JSON.stringify(response)), true);\n      }\n    } catch (error) {\n      console.warn(\"Received unknown data format:\", error);\n    }\n  }\n  /**\n   * Send a packet - converts packet to HTTP message for compatibility\n   * This method provides backward compatibility with packet-based code\n   */\n  async sendPacket(packet) {\n    const data = packet.data;\n    if (data && typeof data === \"object\") {\n      if (data.service && data.method) {\n        const request = createRequestMessage(\n          data.service,\n          data.method,\n          data.input || data.args || data.params\n        );\n        const response = await this.sendRequestMessage(request);\n        this.emit(\"packet\", {\n          id: packet.id,\n          flags: 0,\n          data: response\n        });\n      } else {\n        await this.send(Buffer.from(JSON.stringify(data)));\n      }\n    } else {\n      const buffer = Buffer.isBuffer(data) ? data : typeof data === \"string\" ? Buffer.from(data) : Buffer.from(JSON.stringify(data));\n      await this.send(buffer);\n    }\n  }\n  /**\n   * Send HTTP request message\n   */\n  async sendRequestMessage(message) {\n    const response = await this.sendHttpRequest(\n      \"POST\",\n      \"/netron/invoke\",\n      message\n    );\n    if (!isHttpResponseMessage(response)) {\n      throw new TitanError({\n        code: ErrorCode.UNPROCESSABLE_ENTITY,\n        message: \"Invalid response format from server\"\n      });\n    }\n    return response;\n  }\n  /**\n   * Send HTTP request\n   */\n  async sendHttpRequest(method, path, body) {\n    const url = `${this.baseUrl}${path}`;\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"application/json\",\n      \"X-Netron-Version\": \"2.0\",\n      ...this.options?.headers\n    };\n    const timeout = this.options?.timeout || 3e4;\n    this.abortController = new AbortController();\n    const timeoutId = setTimeout(() => {\n      this.abortController?.abort();\n    }, timeout);\n    try {\n      const response = await fetch(url, {\n        method,\n        headers,\n        body: body ? JSON.stringify(body) : void 0,\n        signal: this.abortController.signal\n      });\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        try {\n          const errorData = await response.json();\n          if (errorData.error) {\n            throw new TitanError({\n              code: typeof errorData.error.code === \"number\" ? errorData.error.code : \"INTERNAL_ERROR\" /* INTERNAL_ERROR */,\n              message: errorData.error.message,\n              details: errorData.error.details\n            });\n          }\n        } catch {\n        }\n        throw new TitanError({\n          code: \"INTERNAL_ERROR\" /* INTERNAL_ERROR */,\n          message: `HTTP ${response.status}: ${response.statusText}`\n        });\n      }\n      return await response.json();\n    } catch (error) {\n      clearTimeout(timeoutId);\n      if (error.name === \"AbortError\") {\n        throw new TitanError({\n          code: \"REQUEST_TIMEOUT\" /* REQUEST_TIMEOUT */,\n          message: `Request timeout after ${timeout}ms`\n        });\n      }\n      throw error;\n    }\n  }\n  /**\n   * Close the connection\n   */\n  async close(code, reason) {\n    if (this._state === \"disconnected\" /* DISCONNECTED */) {\n      return;\n    }\n    this._state = \"disconnected\" /* DISCONNECTED */;\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n    for (const [id, pending] of this.pendingRequests) {\n      clearTimeout(pending.timeout);\n      pending.reject(new Error(\"Connection closed\"));\n    }\n    this.pendingRequests.clear();\n    this.emit(\"disconnect\", { code, reason });\n  }\n  /**\n   * Reconnect (for compatibility - HTTP is stateless)\n   */\n  async reconnect() {\n    this._state = \"connecting\" /* CONNECTING */;\n    await new Promise((resolve) => setTimeout(resolve, 100));\n    this._state = \"connected\" /* CONNECTED */;\n    this.emit(\"connect\");\n    await this.discoverServices();\n  }\n  /**\n   * Check if connection is alive\n   */\n  isAlive() {\n    return this._state === \"connected\" /* CONNECTED */;\n  }\n  /**\n   * Get connection metrics\n   */\n  getMetrics() {\n    return {\n      id: this.id,\n      state: this._state,\n      baseUrl: this.baseUrl,\n      services: Array.from(this.services.keys()),\n      pendingRequests: this.pendingRequests.size\n    };\n  }\n  /**\n   * Query interface (for Netron compatibility)\n   */\n  async queryInterface(serviceName) {\n    try {\n      await Promise.race([\n        this.discoverServices(),\n        new Promise((resolve) => setTimeout(resolve, 1e3))\n        // 1 second max wait\n      ]);\n    } catch (error) {\n    }\n    const definition = this.services.get(serviceName);\n    if (!definition) {\n      const minimalDef = {\n        id: serviceName,\n        meta: {\n          name: serviceName,\n          version: \"1.0.0\",\n          methods: {},\n          properties: {}\n        },\n        parentId: \"\",\n        peerId: this.id\n      };\n      return this.createServiceProxy(minimalDef);\n    }\n    return this.createServiceProxy(definition);\n  }\n  /**\n   * Create service proxy\n   */\n  createServiceProxy(definition) {\n    const self = this;\n    return new Proxy({}, {\n      get(target, prop) {\n        if (prop === \"$def\") {\n          return definition;\n        }\n        return async (...args) => {\n          const request = createRequestMessage(\n            definition.meta.name,\n            prop,\n            args\n            // Pass full arguments array\n          );\n          const response = await self.sendRequestMessage(request);\n          if (!response.success) {\n            throw new TitanError({\n              code: typeof response.error?.code === \"number\" ? response.error.code : \"INTERNAL_ERROR\" /* INTERNAL_ERROR */,\n              message: response.error?.message || \"Method call failed\",\n              details: response.error?.details\n            });\n          }\n          return response.data;\n        };\n      }\n    });\n  }\n};\n\n// src/netron/transport/http/peer.ts\ninit_process_shim();\n\n// e2e/stubs/events.js\ninit_process_shim();\nvar EventEmitter2 = class {\n  static {\n    __name(this, \"EventEmitter\");\n  }\n  constructor() {\n    this.events = /* @__PURE__ */ new Map();\n  }\n  on(event, listener) {\n    if (!this.events.has(event)) {\n      this.events.set(event, []);\n    }\n    this.events.get(event).push(listener);\n    return this;\n  }\n  emit(event, ...args) {\n    const listeners = this.events.get(event);\n    if (listeners) {\n      for (const listener of listeners) {\n        listener(...args);\n      }\n      return true;\n    }\n    return false;\n  }\n  off(event, listener) {\n    const listeners = this.events.get(event);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n    return this;\n  }\n  removeListener(event, listener) {\n    return this.off(event, listener);\n  }\n};\n\n// src/netron/abstract-peer.ts\ninit_process_shim();\nvar import_semver = __toESM(require_semver2(), 1);\n\n// src/netron/interface.ts\ninit_process_shim();\ninit_reference();\ninit_stream_reference();\n\n// src/netron/stream-utils.ts\ninit_process_shim();\ninit_readable_stream();\ninit_writable_stream();\nvar isNetronStream = /* @__PURE__ */ __name((obj) => obj instanceof NetronReadableStream || obj instanceof NetronWritableStream, \"isNetronStream\");\n\n// src/netron/service-utils.ts\ninit_process_shim();\n\n// src/netron/decorators.ts\ninit_process_shim();\nvar SERVICE_ANNOTATION = Symbol(\"service\");\n\n// src/netron/service-utils.ts\nvar isNetronService = /* @__PURE__ */ __name((obj) => {\n  if (obj && typeof obj === \"object\" && obj.constructor) {\n    return Reflect.hasMetadata(SERVICE_ANNOTATION, obj.constructor);\n  }\n  return false;\n}, \"isNetronService\");\n\n// src/netron/interface.ts\nvar INTERNAL_READ_PROPERTIES = [\"$def\", \"$peer\", \"waitForAssigned\", \"$pendingPromises\", \"then\", \"$$typeof\", \"nodeType\", \"tagName\"];\nvar INTERNAL_WRITE_PROPERTIES = [\"$def\", \"$peer\"];\nvar Interface = class _Interface {\n  /**\n   * Constructs a new Interface instance with the specified service definition and peer.\n   * The constructor returns a Proxy that intercepts all property access and method calls,\n   * providing transparent remote service interaction.\n   *\n   * @param {Definition} [def] - The service definition containing metadata about available\n   *                            methods and properties\n   * @param {AbstractPeer} [peer] - The peer instance responsible for network communication\n   * @returns {Proxy} A Proxy instance that intercepts property access and method calls\n   */\n  constructor($def, $peer) {\n    this.$def = $def;\n    this.$peer = $peer;\n    return new Proxy(this, {\n      /**\n       * Intercepts property access on the Interface instance.\n       * This handler implements the core logic for remote service interaction:\n       * - Method calls are converted to asynchronous remote procedure calls\n       * - Property access triggers remote property retrieval\n       * - Internal properties are handled directly\n       *\n       * @param {Interface} target - The target Interface instance\n       * @param {string} prop - The name of the property being accessed\n       * @returns {any} The property value or a function for method calls\n       * @throws {Error} If the interface is invalid or the member is unknown\n       */\n      get: /* @__PURE__ */ __name((target, prop) => {\n        if (!this.$def) {\n          throw new Error(\"Invalid interface: Service definition is missing\");\n        }\n        if (this.$def?.meta.methods[prop]) {\n          return /* @__PURE__ */ __name(async function methodProxy(...args) {\n            const processedArgs = target.$processArgs(args);\n            return $peer?.call($def.id, prop, processedArgs);\n          }, \"methodProxy\");\n        }\n        if ($def?.meta.properties[prop]) {\n          return $peer?.get($def.id, prop);\n        }\n        if (INTERNAL_READ_PROPERTIES.includes(prop)) {\n          return Reflect.get(target, prop);\n        }\n        if (typeof prop === \"symbol\" || prop.startsWith(\"$$\") || prop.startsWith(\"@@\")) {\n          return void 0;\n        }\n        throw new Error(`Unknown member: '${prop}' is not defined in the service interface`);\n      }, \"get\"),\n      /**\n       * Intercepts property assignment on the Interface instance.\n       * This handler manages asynchronous property updates and ensures proper\n       * type conversion and validation before remote updates are performed.\n       *\n       * @param {Interface} target - The target Interface instance\n       * @param {string} prop - The name of the property being set\n       * @param {any} value - The value being assigned\n       * @returns {boolean} true if the assignment was successful\n       * @throws {Error} If the interface is invalid, the member is unknown, or the property is read-only\n       */\n      set: /* @__PURE__ */ __name((target, prop, value) => {\n        if (INTERNAL_WRITE_PROPERTIES.includes(prop)) {\n          Reflect.set(target, prop, value);\n          return true;\n        }\n        if (!this.$def) {\n          throw new Error(\"Invalid interface: Service definition is missing\");\n        }\n        if (!$def?.meta.properties[prop]) {\n          throw new Error(`Unknown member: '${prop}' is not defined in the service interface`);\n        }\n        if (this.$def?.meta.properties[prop]?.readonly) {\n          throw new Error(`Property is not writable: '${prop}' is marked as readonly`);\n        }\n        let resolvePromise = /* @__PURE__ */ __name(() => {\n        }, \"resolvePromise\");\n        let rejectPromise = /* @__PURE__ */ __name(() => {\n        }, \"rejectPromise\");\n        const promise = new Promise((resolve, reject) => {\n          resolvePromise = resolve;\n          rejectPromise = reject;\n        });\n        this.$pendingPromises.set(prop, promise);\n        (async () => {\n          try {\n            value = await this.$processValue(value);\n            await $peer?.set($def.id, prop, value);\n            resolvePromise();\n            this.$pendingPromises.delete(prop);\n          } catch (error) {\n            rejectPromise(error);\n          }\n        })();\n        return true;\n      }, \"set\")\n    });\n  }\n  static {\n    __name(this, \"Interface\");\n  }\n  /**\n   * A Map tracking pending promises for asynchronous property assignments.\n   * This is used to ensure proper handling of concurrent property updates\n   * and to provide a mechanism for waiting on property assignment completion.\n   *\n   * @private\n   * @type {Map<string, Promise<void>>}\n   */\n  $pendingPromises = /* @__PURE__ */ new Map();\n  /**\n   * Waits for the completion of a property assignment operation.\n   * This method is particularly useful when you need to ensure that a property\n   * update has been successfully propagated to the remote service before proceeding.\n   *\n   * @param {string} prop - The name of the property to wait for\n   * @returns {Promise<void>} A promise that resolves when the assignment is complete\n   * @throws {Error} If the assignment operation fails\n   */\n  async waitForAssigned(prop) {\n    try {\n      const promise = this.$pendingPromises.get(prop);\n      return promise ? await promise : Promise.resolve();\n    } catch (error) {\n      this.$pendingPromises.delete(prop);\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * Processes a value to convert it into a format suitable for network transmission.\n   * This method handles various special types that require special serialization:\n   * - Service interfaces are converted to references\n   * - Streams are converted to stream references\n   * - Other types are passed through unchanged\n   *\n   * @private\n   * @param {any} value - The value to process\n   * @returns {any} The processed value\n   * @throws {Error} If the value type is not supported\n   */\n  $processValue(value) {\n    if (value instanceof _Interface) {\n      if (!value.$def) {\n        throw new Error(\"Service interface is not valid: Missing service definition\");\n      }\n      return new Reference(value.$def.id);\n    } else if (isNetronService(value)) {\n      throw Error(\"Unsupported value type: Direct service exposure is not yet implemented\");\n    } else if (isNetronStream(value)) {\n      return StreamReference.from(value);\n    }\n    return value;\n  }\n  /**\n   * Processes an array of arguments by converting each argument using $processValue.\n   * This method ensures that all arguments passed to remote methods are properly\n   * serialized for network transmission.\n   *\n   * @private\n   * @param {any[]} args - The array of arguments to process\n   * @returns {any[]} The array of processed arguments\n   */\n  $processArgs(args) {\n    return args.map((arg) => this.$processValue(arg));\n  }\n  /**\n   * Factory method for creating new Interface instances.\n   * This method provides a more convenient way to create Interface instances\n   * while maintaining proper type safety.\n   *\n   * @static\n   * @param {Definition} def - The service definition\n   * @param {AbstractPeer} peer - The peer instance\n   * @returns {Interface} A new Interface instance\n   */\n  static create(def, peer) {\n    return new _Interface(def, peer);\n  }\n};\n\n// src/netron/abstract-peer.ts\nvar AbstractPeer = class {\n  /**\n   * Constructs a new AbstractPeer instance.\n   *\n   * @param {INetron} netron - The Netron instance this peer belongs to\n   * @param {string} id - Unique identifier for this peer\n   */\n  constructor(netron, id) {\n    this.netron = netron;\n    this.id = id;\n  }\n  static {\n    __name(this, \"AbstractPeer\");\n  }\n  /**\n   * Internal map storing interface instances and their reference counts.\n   * Key is the definition ID, value contains the interface instance and its reference count.\n   * Used for managing interface lifecycle and preventing memory leaks.\n   */\n  interfaces = /* @__PURE__ */ new Map();\n  /**\n   * Cache of service definitions indexed by qualified service name (name@version).\n   * This cache reduces network overhead by storing previously fetched definitions.\n   * The cache can be manually invalidated using invalidateDefinitionCache().\n   */\n  definitionCache = /* @__PURE__ */ new Map();\n  /**\n   * Removes all services exposed by this peer.\n   * Iterates through all service names and unexposes each one.\n   */\n  unexposeAllServices() {\n    for (const ctxId of this.getServiceNames()) {\n      this.unexposeService(ctxId);\n    }\n  }\n  /**\n   * Queries and retrieves an interface for a specified service.\n   * Handles version resolution, caching, and interface creation.\n   *\n   * Flow:\n   * 1. Parse service name and version\n   * 2. Check definition cache\n   * 3. If not cached, query remote peer via queryInterfaceRemote()\n   * 4. Cache the definition\n   * 5. Create and return interface\n   *\n   * @template T - Type of the interface to return\n   * @param {string} qualifiedName - Service name with optional version (name@version)\n   * @returns {Promise<T>} Resolves with the requested interface instance\n   */\n  async queryInterface(qualifiedName) {\n    let name;\n    let version;\n    if (qualifiedName.includes(\"@\")) {\n      [name, version] = qualifiedName.split(\"@\");\n    } else {\n      name = qualifiedName;\n      version = \"*\";\n    }\n    const normalizedName = version === \"*\" || !version ? name : `${name}@${version}`;\n    let def = this.definitionCache.get(normalizedName);\n    if (def) {\n      try {\n        this.getDefinitionById(def.id);\n      } catch {\n        this.definitionCache.delete(normalizedName);\n        def = void 0;\n      }\n    }\n    if (!def) {\n      if (version === \"*\" || !version) {\n        try {\n          def = this.findLatestServiceVersion(name);\n        } catch {\n          def = await this.queryInterfaceRemote(name);\n        }\n      } else {\n        const exactKey = `${name}@${version}`;\n        try {\n          def = this.getDefinitionByServiceName(exactKey);\n        } catch {\n          def = await this.queryInterfaceRemote(exactKey);\n        }\n      }\n      this.definitionCache.set(normalizedName, def);\n    }\n    return this.queryInterfaceByDefId(def.id, def);\n  }\n  /**\n   * Retrieves an interface instance by its definition ID.\n   * Manages interface caching and reference counting.\n   *\n   * @template T - Type of the interface to return\n   * @param {string} defId - Definition ID of the interface\n   * @param {Definition} [def] - Optional pre-fetched definition\n   * @returns {T} The interface instance\n   */\n  queryInterfaceByDefId(defId, def) {\n    if (!def) {\n      def = this.getDefinitionById(defId);\n    }\n    let iInfo = this.interfaces.get(defId);\n    if (iInfo !== void 0) {\n      iInfo.refCount++;\n      return iInfo.instance;\n    }\n    const instance = Interface.create(def, this);\n    iInfo = { instance, refCount: 1 };\n    this.interfaces.set(def.id, iInfo);\n    return instance;\n  }\n  /**\n   * Releases a previously queried interface.\n   * Handles reference counting and cleanup of dependent interfaces.\n   *\n   * @template T - Type of the interface to release\n   * @param {T} iInstance - Interface instance to release\n   * @param {Set<string>} [released] - Set of already released definition IDs\n   * @returns {Promise<void>} Resolves when interface is released\n   * @throws {Error} If interface is invalid or not found\n   */\n  async releaseInterface(iInstance, released = /* @__PURE__ */ new Set()) {\n    if (!(iInstance instanceof Interface) || !iInstance.$def) {\n      throw new Error(\"Invalid interface\");\n    }\n    const defId = iInstance.$def.id;\n    if (released.has(defId)) return;\n    released.add(defId);\n    const iInfo = this.interfaces.get(defId);\n    if (!iInfo) {\n      throw new Error(\"Invalid interface\");\n    }\n    iInfo.refCount--;\n    if (iInfo.refCount === 0) {\n      this.interfaces.delete(defId);\n      for (const i of this.interfaces.values()) {\n        if (i.instance.$def?.parentId === defId) {\n          this.releaseInterface(i.instance);\n        }\n      }\n      await this.releaseInterfaceInternal(iInstance);\n      iInstance.$def = void 0;\n      iInstance.$peer = void 0;\n    }\n  }\n  /**\n   * Finds the latest version of a service by its name.\n   * This method implements a sophisticated version resolution strategy that:\n   * 1. First attempts to find an exact match without version specification\n   * 2. If that fails, searches for all versions of the service and returns the latest one\n   *\n   * @param {string} serviceName - The name of the service to find. Can be either:\n   *                              - A simple name (e.g., 'auth')\n   *                              - A name with version (e.g., 'auth@1.0.0')\n   * @returns {Definition} The Definition object representing the latest version of the service\n   * @throws {Error} If no matching service is found\n   *\n   * @example\n   * // Returns the latest version of the 'auth' service\n   * const latestAuth = findLatestServiceVersion('auth');\n   *\n   * @example\n   * // Returns the latest version of the 'auth' service\n   * const latestAuth = findLatestServiceVersion('auth@1.0.0');\n   */\n  findLatestServiceVersion(serviceName) {\n    if (!serviceName.includes(\"@\")) {\n      try {\n        return this.getDefinitionByServiceName(serviceName);\n      } catch {\n      }\n    }\n    const regex = new RegExp(`^${serviceName}@([^@]+)$`);\n    const candidates = Array.from(this.getServiceNames()).map((key) => {\n      const match = key.match(regex);\n      if (match) return { version: match[1], key };\n      return null;\n    }).filter((x) => x !== null).sort((a, b) => import_semver.default.rcompare(a.version, b.version));\n    if (candidates.length === 0) {\n      throw new Error(`Unknown service: ${serviceName}`);\n    }\n    return this.getDefinitionByServiceName(candidates[0].key);\n  }\n  /**\n   * Invalidates cached definitions matching the given pattern.\n   * Supports wildcard patterns using * for matching multiple services.\n   *\n   * @param {string} [pattern] - Optional pattern to match service names.\n   *                            If not provided, all cached definitions are invalidated.\n   *                            Supports wildcard (*) for pattern matching.\n   * @returns {number} The number of cache entries invalidated\n   *\n   * @example\n   * // Invalidate specific service\n   * peer.invalidateDefinitionCache('userService@1.0.0');\n   *\n   * @example\n   * // Invalidate all services starting with \"user\"\n   * peer.invalidateDefinitionCache('user*');\n   *\n   * @example\n   * // Invalidate all cached definitions\n   * peer.invalidateDefinitionCache();\n   */\n  invalidateDefinitionCache(pattern) {\n    let invalidatedCount = 0;\n    if (pattern === void 0) {\n      invalidatedCount = this.definitionCache.size;\n      this.definitionCache.clear();\n      return invalidatedCount;\n    }\n    const keysToDelete = [];\n    for (const key of this.definitionCache.keys()) {\n      if (this.matchesPattern(key, pattern)) {\n        keysToDelete.push(key);\n      }\n    }\n    for (const key of keysToDelete) {\n      this.definitionCache.delete(key);\n      invalidatedCount++;\n    }\n    return invalidatedCount;\n  }\n  /**\n   * Clears all cached service definitions.\n   * This is equivalent to calling invalidateDefinitionCache() with no arguments.\n   *\n   * @returns {number} The number of cache entries cleared\n   */\n  clearDefinitionCache() {\n    const count = this.definitionCache.size;\n    this.definitionCache.clear();\n    return count;\n  }\n  /**\n   * Checks if a service name matches a pattern with wildcard support.\n   *\n   * @param {string} serviceName - The service name to check\n   * @param {string} pattern - The pattern to match against (supports * wildcard)\n   * @returns {boolean} True if the service name matches the pattern\n   * @private\n   */\n  matchesPattern(serviceName, pattern) {\n    if (serviceName === pattern) {\n      return true;\n    }\n    if (!pattern.includes(\"*\")) {\n      return false;\n    }\n    const regexPattern = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/\\*/g, \".*\");\n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(serviceName);\n  }\n};\n\n// src/netron/transport/http/peer.ts\ninit_definition();\n\n// src/netron/transport/http/interface.ts\ninit_process_shim();\nvar HttpInterface = class {\n  constructor(transport, definition) {\n    this.transport = transport;\n    this.definition = definition;\n    this.$def = definition;\n    return new Proxy(this, {\n      get: /* @__PURE__ */ __name((target, prop) => {\n        if (typeof prop === \"symbol\") {\n          if (prop === Symbol.asyncIterator) return void 0;\n          return void 0;\n        }\n        if (prop === \"$def\") {\n          return target.definition;\n        }\n        if (prop === \"$peer\") {\n          return target.$peer;\n        }\n        if (prop === \"transport\" || prop === \"definition\") {\n          return Reflect.get(target, prop);\n        }\n        if (target.definition.meta.methods && target.definition.meta.methods[prop]) {\n          return async (...args) => {\n            const serviceName = target.definition.meta.name;\n            const methodName = prop;\n            const result = await target.transport.invoke(\n              serviceName,\n              methodName,\n              args\n            );\n            return result;\n          };\n        }\n        return void 0;\n      }, \"get\")\n    });\n  }\n  static {\n    __name(this, \"HttpInterface\");\n  }\n  /**\n   * Definition metadata (for compatibility with standard Interface)\n   * @internal\n   */\n  $def;\n  /**\n   * Peer reference (for compatibility with standard Interface)\n   * @internal\n   */\n  $peer;\n};\n\n// src/netron/transport/http/fluent-interface.ts\ninit_process_shim();\n\n// src/netron/transport/http/query-builder.ts\ninit_process_shim();\nvar QueryBuilder = class _QueryBuilder {\n  constructor(transport, definition, cacheManager, retryManager) {\n    this.transport = transport;\n    this.definition = definition;\n    this.cacheManager = cacheManager;\n    this.retryManager = retryManager;\n    this.abortController = new AbortController();\n  }\n  static {\n    __name(this, \"QueryBuilder\");\n  }\n  options = {};\n  methodName;\n  methodInput;\n  abortController;\n  // Shared deduplication map across all QueryBuilder instances\n  static inFlightRequests = /* @__PURE__ */ new Map();\n  // Background refetch intervals (number for browser)\n  static backgroundIntervals = /* @__PURE__ */ new Map();\n  /**\n   * Set the method to call\n   */\n  method(name) {\n    this.methodName = name;\n    return this;\n  }\n  /**\n   * Set the input for the method\n   */\n  input(data) {\n    this.methodInput = data;\n    return this;\n  }\n  /**\n   * Configure caching\n   */\n  cache(options) {\n    if (typeof options === \"number\") {\n      this.options.cache = { maxAge: options };\n    } else {\n      this.options.cache = options;\n    }\n    return this;\n  }\n  /**\n   * Configure retry behavior\n   */\n  retry(options) {\n    if (typeof options === \"number\") {\n      this.options.retry = { attempts: options };\n    } else {\n      this.options.retry = options;\n    }\n    return this;\n  }\n  /**\n   * Set cache invalidation tags\n   */\n  invalidateOn(tags) {\n    this.options.invalidateTags = tags;\n    return this;\n  }\n  /**\n   * Configure optimistic updates\n   */\n  optimistic(updater) {\n    this.options.optimisticUpdate = updater;\n    return this;\n  }\n  /**\n   * Set deduplication key\n   */\n  dedupe(key) {\n    this.options.dedupeKey = key;\n    return this;\n  }\n  /**\n   * Configure background refetch\n   */\n  background(interval) {\n    this.options.backgroundRefetch = interval;\n    return this;\n  }\n  /**\n   * Set request timeout\n   */\n  timeout(ms) {\n    this.options.timeout = ms;\n    return this;\n  }\n  /**\n   * Set request priority\n   */\n  priority(level) {\n    this.options.priority = level;\n    return this;\n  }\n  /**\n   * Transform response data\n   */\n  transform(fn) {\n    this.options.transform = fn;\n    return this;\n  }\n  /**\n   * Validate response data\n   */\n  validate(fn) {\n    this.options.validate = fn;\n    return this;\n  }\n  /**\n   * Set fallback data\n   */\n  fallback(data) {\n    this.options.fallback = data;\n    return this;\n  }\n  /**\n   * Track metrics\n   */\n  metrics(fn) {\n    this.options.metrics = fn;\n    return this;\n  }\n  /**\n   * Cancel the query if it's in progress\n   */\n  cancel() {\n    this.abortController.abort();\n  }\n  /**\n   * Execute the query\n   */\n  async execute() {\n    if (!this.methodName) {\n      throw new Error(\"Method name not specified\");\n    }\n    const dedupeKey = this.options.dedupeKey || (this.options.cache ? this.getCacheKey() : void 0);\n    if (dedupeKey) {\n      const inFlight = _QueryBuilder.inFlightRequests.get(dedupeKey);\n      if (inFlight) {\n        return inFlight;\n      }\n    }\n    const promise = this.executeInternal();\n    if (dedupeKey) {\n      _QueryBuilder.inFlightRequests.set(dedupeKey, promise);\n    }\n    try {\n      const result = await promise;\n      return result;\n    } finally {\n      if (dedupeKey) {\n        _QueryBuilder.inFlightRequests.delete(dedupeKey);\n      }\n    }\n  }\n  /**\n   * Internal execution logic\n   */\n  async executeInternal() {\n    const startTime = performance.now();\n    let cacheHit = false;\n    let result;\n    try {\n      if (this.abortController.signal.aborted) {\n        throw new Error(\"Query cancelled\");\n      }\n      if (this.options.optimisticUpdate && this.cacheManager && this.options.cache) {\n        const cacheKey = this.getCacheKey();\n        const current = this.cacheManager.getRaw(cacheKey);\n        const optimistic = this.options.optimisticUpdate(current);\n        this.cacheManager.set(cacheKey, optimistic, {\n          ...this.options.cache,\n          tags: [...this.options.cache.tags || [], \"__optimistic__\"]\n        });\n        try {\n          const fetcher = this.options.retry && this.retryManager ? () => this.retryManager.execute(() => this.executeRequest(), this.options.retry) : () => this.executeRequest();\n          result = await fetcher();\n          this.cacheManager.set(cacheKey, result, this.options.cache);\n        } catch (error) {\n          this.cacheManager.invalidate(cacheKey);\n          throw error;\n        }\n      } else {\n        if (this.abortController.signal.aborted) {\n          throw new Error(\"Query cancelled\");\n        }\n        if (this.options.cache && this.cacheManager) {\n          const cacheKey = this.getCacheKey();\n          const fetcher = this.options.retry && this.retryManager ? () => this.retryManager.execute(() => this.executeRequest(), this.options.retry) : () => this.executeRequest();\n          result = await this.cacheManager.get(\n            cacheKey,\n            fetcher,\n            this.options.cache\n          );\n          cacheHit = this.cacheManager.isCacheHit(cacheKey);\n          if (this.abortController.signal.aborted) {\n            throw new Error(\"Query cancelled\");\n          }\n        } else if (this.options.retry && this.retryManager) {\n          result = await this.retryManager.execute(\n            () => this.executeRequest(),\n            this.options.retry\n          );\n          if (this.abortController.signal.aborted) {\n            throw new Error(\"Query cancelled\");\n          }\n        } else {\n          result = await this.executeRequest();\n          if (this.abortController.signal.aborted) {\n            throw new Error(\"Query cancelled\");\n          }\n        }\n      }\n      if (this.abortController.signal.aborted) {\n        throw new Error(\"Query cancelled\");\n      }\n      if (this.options.transform) {\n        result = this.options.transform(result);\n      }\n      if (this.options.validate) {\n        const isValid = await this.options.validate(result);\n        if (!isValid) {\n          throw new Error(\"Response validation failed\");\n        }\n      }\n      if (this.options.metrics) {\n        const duration = performance.now() - startTime;\n        this.options.metrics({ duration, cacheHit });\n      }\n      if (this.options.backgroundRefetch && this.options.cache && this.cacheManager) {\n        this.setupBackgroundRefetch();\n      }\n      return result;\n    } catch (error) {\n      if (error.name === \"AbortError\" || error.message === \"Query cancelled\") {\n        throw new Error(\"Query cancelled\");\n      }\n      if (this.options.fallback !== void 0) {\n        return this.options.fallback;\n      }\n      throw error;\n    }\n  }\n  /**\n   * Execute the actual request\n   */\n  async executeRequest() {\n    const context = {};\n    const hints = {};\n    if (this.options.cache) {\n      hints.cache = {\n        maxAge: this.options.cache.maxAge,\n        staleWhileRevalidate: this.options.cache.staleWhileRevalidate,\n        tags: this.options.cache.tags\n      };\n    }\n    if (this.options.retry) {\n      hints.retry = {\n        attempts: this.options.retry.attempts,\n        backoff: this.options.retry.backoff,\n        maxDelay: this.options.retry.maxDelay,\n        initialDelay: this.options.retry.initialDelay\n      };\n    }\n    if (this.options.priority) {\n      hints.priority = this.options.priority;\n    }\n    if (this.options.timeout) {\n      hints.timeout = this.options.timeout;\n    }\n    return this.transport.invoke(\n      this.definition.meta.name,\n      this.methodName,\n      [this.methodInput],\n      { context, hints }\n    );\n  }\n  /**\n   * Generate cache key\n   */\n  getCacheKey() {\n    if (this.options.dedupeKey) {\n      return this.options.dedupeKey;\n    }\n    return `${this.definition.meta.name}.${String(this.methodName)}:${JSON.stringify(this.methodInput)}`;\n  }\n  /**\n   * Setup background refetch interval\n   */\n  setupBackgroundRefetch() {\n    if (!this.options.backgroundRefetch || !this.cacheManager) {\n      return;\n    }\n    const cacheKey = this.getCacheKey();\n    this.stopBackgroundRefetch(cacheKey);\n    const interval = setInterval(async () => {\n      try {\n        const result = await this.executeRequest();\n        let transformedResult = result;\n        if (this.options.transform) {\n          transformedResult = this.options.transform(result);\n        }\n        if (this.options.cache && this.cacheManager) {\n          this.cacheManager.set(cacheKey, transformedResult, this.options.cache);\n        }\n      } catch (error) {\n      }\n    }, this.options.backgroundRefetch);\n    _QueryBuilder.backgroundIntervals.set(cacheKey, interval);\n  }\n  /**\n   * Stop background refetch for a specific cache key\n   */\n  stopBackgroundRefetch(cacheKey) {\n    const interval = _QueryBuilder.backgroundIntervals.get(cacheKey);\n    if (interval !== void 0) {\n      clearInterval(interval);\n      _QueryBuilder.backgroundIntervals.delete(cacheKey);\n    }\n  }\n  /**\n   * Stop all background refetch intervals\n   * Useful for cleanup when shutting down or during SSR\n   */\n  static stopAllBackgroundRefetch() {\n    for (const interval of _QueryBuilder.backgroundIntervals.values()) {\n      clearInterval(interval);\n    }\n    _QueryBuilder.backgroundIntervals.clear();\n  }\n  /**\n   * Get active background refetch count (for debugging/testing)\n   */\n  static getActiveBackgroundRefetchCount() {\n    return _QueryBuilder.backgroundIntervals.size;\n  }\n};\n\n// src/netron/transport/http/configurable-proxy.ts\ninit_process_shim();\nvar ConfigurableProxy = class {\n  // Store the proxy for returning from methods\n  constructor(transport, definition, cacheManager, retryManager, initialOptions) {\n    this.transport = transport;\n    this.definition = definition;\n    this.cacheManager = cacheManager;\n    this.retryManager = retryManager;\n    if (initialOptions) {\n      this.accumulatedOptions = { ...initialOptions };\n    }\n    this.proxy = new Proxy(this, {\n      get: /* @__PURE__ */ __name((target, prop) => {\n        if (typeof prop === \"symbol\" || prop in target) {\n          const value = target[prop];\n          if (typeof value === \"function\") {\n            return value.bind(target);\n          }\n          return value;\n        }\n        return (...args) => {\n          const builder = new QueryBuilder(\n            target.transport,\n            target.definition,\n            target.cacheManager,\n            target.retryManager\n          );\n          target.applyOptions(builder, target.accumulatedOptions);\n          builder.method(prop);\n          if (args.length > 0) {\n            builder.input(args.length === 1 ? args[0] : args);\n          }\n          return builder.execute();\n        };\n      }, \"get\")\n    });\n    return this.proxy;\n  }\n  static {\n    __name(this, \"ConfigurableProxy\");\n  }\n  accumulatedOptions = {};\n  proxy;\n  /**\n   * Chain cache configuration\n   */\n  cache(options) {\n    this.accumulatedOptions.cache = typeof options === \"number\" ? { maxAge: options } : options;\n    return this.proxy;\n  }\n  /**\n   * Chain retry configuration\n   */\n  retry(options) {\n    this.accumulatedOptions.retry = typeof options === \"number\" ? { attempts: options } : options;\n    return this.proxy;\n  }\n  /**\n   * Chain deduplication key\n   */\n  dedupe(key) {\n    this.accumulatedOptions.dedupeKey = key;\n    return this.proxy;\n  }\n  /**\n   * Chain timeout\n   */\n  timeout(ms) {\n    this.accumulatedOptions.timeout = ms;\n    return this.proxy;\n  }\n  /**\n   * Chain priority\n   */\n  priority(level) {\n    this.accumulatedOptions.priority = level;\n    return this.proxy;\n  }\n  /**\n   * Chain transform\n   */\n  transform(fn) {\n    this.accumulatedOptions.transform = fn;\n    return this.proxy;\n  }\n  /**\n   * Chain validate\n   */\n  validate(fn) {\n    this.accumulatedOptions.validate = fn;\n    return this.proxy;\n  }\n  /**\n   * Chain fallback\n   */\n  fallback(data) {\n    this.accumulatedOptions.fallback = data;\n    return this.proxy;\n  }\n  /**\n   * Chain optimistic updates\n   */\n  optimistic(updater) {\n    this.accumulatedOptions.optimisticUpdate = updater;\n    return this.proxy;\n  }\n  /**\n   * Chain cache invalidation tags\n   */\n  invalidateOn(tags) {\n    this.accumulatedOptions.invalidateTags = tags;\n    return this.proxy;\n  }\n  /**\n   * Chain background refetch\n   */\n  background(interval) {\n    this.accumulatedOptions.backgroundRefetch = interval;\n    return this.proxy;\n  }\n  /**\n   * Chain metrics callback\n   */\n  metrics(fn) {\n    this.accumulatedOptions.metrics = fn;\n    return this.proxy;\n  }\n  /**\n   * Apply accumulated options to a QueryBuilder\n   */\n  applyOptions(builder, options) {\n    if (options.cache) builder.cache(options.cache);\n    if (options.retry) builder.retry(options.retry);\n    if (options.timeout) builder.timeout(options.timeout);\n    if (options.priority) builder.priority(options.priority);\n    if (options.transform) builder.transform(options.transform);\n    if (options.validate) builder.validate(options.validate);\n    if (options.fallback !== void 0) builder.fallback(options.fallback);\n    if (options.optimisticUpdate) builder.optimistic(options.optimisticUpdate);\n    if (options.invalidateTags) builder.invalidateOn(options.invalidateTags);\n    if (options.backgroundRefetch) builder.background(options.backgroundRefetch);\n    if (options.metrics) builder.metrics(options.metrics);\n    if (options.dedupeKey) builder.dedupe(options.dedupeKey);\n  }\n};\n\n// src/netron/transport/http/fluent-interface.ts\nvar FluentInterface = class {\n  constructor(transport, definition, cacheManager, retryManager, globalOptions = {}) {\n    this.transport = transport;\n    this.definition = definition;\n    this.cacheManager = cacheManager;\n    this.retryManager = retryManager;\n    this.globalOptions = globalOptions;\n    this.$def = definition;\n  }\n  static {\n    __name(this, \"FluentInterface\");\n  }\n  /**\n   * Definition metadata (for compatibility with Interface)\n   * @internal\n   */\n  $def;\n  /**\n   * Peer reference (for compatibility with Interface)\n   * @internal\n   */\n  $peer;\n  /**\n   * Set global cache configuration that applies to all method calls\n   * @returns this for method chaining\n   */\n  globalCache(options) {\n    if (!this.globalOptions) {\n      this.globalOptions = {};\n    }\n    this.globalOptions.cache = options;\n    return this;\n  }\n  /**\n   * Set global retry configuration that applies to all method calls\n   * @returns this for method chaining\n   */\n  globalRetry(options) {\n    if (!this.globalOptions) {\n      this.globalOptions = {};\n    }\n    this.globalOptions.retry = options;\n    return this;\n  }\n  /**\n   * Configure caching for the next method call\n   * @returns ConfigurableProxy with cache settings\n   */\n  cache(options) {\n    const mergedOptions = { ...this.globalOptions };\n    mergedOptions.cache = this.normalizeCacheOptions(options);\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Configure retry behavior for the next method call\n   * @returns ConfigurableProxy with retry settings\n   */\n  retry(options) {\n    const mergedOptions = { ...this.globalOptions };\n    mergedOptions.retry = this.normalizeRetryOptions(options);\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Set deduplication key for the next method call\n   * @returns ConfigurableProxy with dedupe settings\n   */\n  dedupe(key) {\n    const mergedOptions = { ...this.globalOptions, dedupeKey: key };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Configure request timeout\n   * @returns ConfigurableProxy with timeout settings\n   */\n  timeout(ms) {\n    const mergedOptions = { ...this.globalOptions, timeout: ms };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Set request priority\n   * @returns ConfigurableProxy with priority settings\n   */\n  priority(level) {\n    const mergedOptions = { ...this.globalOptions, priority: level };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Transform response data\n   * @returns ConfigurableProxy with transform function\n   */\n  transform(fn) {\n    const mergedOptions = { ...this.globalOptions, transform: fn };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Validate response data\n   * @returns ConfigurableProxy with validation function\n   */\n  validate(fn) {\n    const mergedOptions = { ...this.globalOptions, validate: fn };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Provide fallback data on error\n   * @returns ConfigurableProxy with fallback data\n   */\n  fallback(data) {\n    const mergedOptions = { ...this.globalOptions, fallback: data };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Configure optimistic updates\n   * @returns ConfigurableProxy with optimistic updater\n   */\n  optimistic(updater) {\n    const mergedOptions = { ...this.globalOptions, optimisticUpdate: updater };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Set cache invalidation tags\n   * @returns ConfigurableProxy with invalidation tags\n   */\n  invalidateOn(tags) {\n    const mergedOptions = { ...this.globalOptions, invalidateTags: tags };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Configure background refetch\n   * @returns ConfigurableProxy with background refetch interval\n   */\n  background(interval) {\n    const mergedOptions = { ...this.globalOptions, backgroundRefetch: interval };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  /**\n   * Set metrics callback\n   * @returns ConfigurableProxy with metrics function\n   */\n  metrics(fn) {\n    const mergedOptions = { ...this.globalOptions, metrics: fn };\n    return new ConfigurableProxy(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager,\n      mergedOptions\n    );\n  }\n  // Backward compatibility methods\n  /**\n   * Original call-based API (backward compatible)\n   * @deprecated Use fluent API instead: service.cache().retry().method(args)\n   */\n  call(method, input) {\n    const builder = new QueryBuilder(\n      this.transport,\n      this.definition,\n      this.cacheManager,\n      this.retryManager\n    );\n    builder.method(method);\n    if (input !== void 0) {\n      builder.input(input);\n    }\n    if (this.globalOptions) {\n      this.applyGlobalOptions(builder, this.globalOptions);\n    }\n    return builder;\n  }\n  /**\n   * Direct service proxy (no configuration)\n   * For simple calls: await service.api.getUser(id)\n   */\n  get api() {\n    return this.createDirectProxy();\n  }\n  /**\n   * Create a direct proxy that immediately executes method calls\n   */\n  createDirectProxy() {\n    const self = this;\n    return new Proxy({}, {\n      get: /* @__PURE__ */ __name((target, methodName) => {\n        if (typeof methodName === \"symbol\") return void 0;\n        return (...args) => {\n          const builder = self.call(methodName, args.length === 1 ? args[0] : args);\n          return builder.execute();\n        };\n      }, \"get\")\n    });\n  }\n  /**\n   * Cache invalidation API\n   */\n  invalidate(pattern) {\n    if (!this.cacheManager) return;\n    const patterns = Array.isArray(pattern) ? pattern : [pattern];\n    for (const p of patterns) {\n      this.cacheManager.invalidate(p);\n    }\n  }\n  /**\n   * Clear all cache\n   */\n  clearCache() {\n    this.cacheManager?.clear();\n  }\n  // Helper methods\n  normalizeCacheOptions(options) {\n    return typeof options === \"number\" ? { maxAge: options } : options;\n  }\n  normalizeRetryOptions(options) {\n    return typeof options === \"number\" ? { attempts: options } : options;\n  }\n  applyGlobalOptions(builder, options) {\n    if (options.cache) builder.cache(options.cache);\n    if (options.retry) builder.retry(options.retry);\n    if (options.timeout) builder.timeout(options.timeout);\n    if (options.priority) builder.priority(options.priority);\n    if (options.transform) builder.transform(options.transform);\n    if (options.validate) builder.validate(options.validate);\n    if (options.fallback !== void 0) builder.fallback(options.fallback);\n    if (options.optimisticUpdate) builder.optimistic(options.optimisticUpdate);\n    if (options.invalidateTags) builder.invalidateOn(options.invalidateTags);\n    if (options.backgroundRefetch) builder.background(options.backgroundRefetch);\n    if (options.metrics) builder.metrics(options.metrics);\n    if (options.dedupeKey) builder.dedupe(options.dedupeKey);\n  }\n};\n\n// src/netron/transport/http/peer.ts\nvar HttpRemotePeer = class extends AbstractPeer {\n  static {\n    __name(this, \"HttpRemotePeer\");\n  }\n  logger;\n  /** Base URL for HTTP requests */\n  baseUrl;\n  /** HTTP connection */\n  connection;\n  /** Service definitions cached from discovery */\n  services = /* @__PURE__ */ new Map();\n  /** Definition cache */\n  definitions = /* @__PURE__ */ new Map();\n  /** Event emitter for internal events */\n  events = new EventEmitter2();\n  /** Service names exposed */\n  serviceNames = /* @__PURE__ */ new Set();\n  /** Default request options */\n  defaultOptions = {};\n  /** Request interceptors */\n  requestInterceptors = [];\n  /** Response interceptors */\n  responseInterceptors = [];\n  /** Cache manager for HTTP responses */\n  cacheManager;\n  /** Retry manager for failed requests */\n  retryManager;\n  /** Global query options */\n  globalOptions = {};\n  constructor(connection, netron, baseUrl, options) {\n    const id = `http-direct-${new URL(baseUrl).host}`;\n    super(netron, id);\n    this.connection = connection;\n    this.baseUrl = baseUrl.endsWith(\"/\") ? baseUrl.slice(0, -1) : baseUrl;\n    this.logger = netron.logger.child({ component: \"HttpRemotePeer\", baseUrl });\n    this.defaultOptions = {\n      timeout: options?.requestTimeout || 3e4,\n      headers: options?.headers || {}\n    };\n  }\n  /**\n   * Initialize the HTTP peer\n   * Phase 7: Removed pre-fetch service discovery in favor of lazy loading via queryInterfaceRemote()\n   * Phase 8: Added support for legacyAbilitiesExchange flag\n   */\n  async init(isClient, _options) {\n    this.logger.debug(\"Initializing HTTP Remote peer\");\n    if (isClient) {\n      this.logger.debug(\"HTTP peer initialized in client mode - using auth-aware on-demand service discovery\");\n      this.logger.debug(\n        \"Services will be discovered on-demand via queryInterfaceRemote(). Use POST /netron/authenticate for user authentication and POST /netron/query-interface for auth-aware service discovery.\"\n      );\n    }\n  }\n  /**\n   * Set a property value on the remote peer\n   */\n  async set(defId, name, value) {\n    const service = this.getServiceNameFromDefId(defId);\n    const message = createRequestMessage(service, `__setProperty`, { name, value });\n    const response = await this.sendRequestMessage(message);\n    if (!response.success) {\n      throw this.createErrorFromResponse(response);\n    }\n  }\n  /**\n   * Get a property value from the remote peer\n   */\n  async get(defId, name) {\n    const service = this.getServiceNameFromDefId(defId);\n    const message = createRequestMessage(service, `__getProperty`, { name });\n    const response = await this.sendRequestMessage(message);\n    if (!response.success) {\n      throw this.createErrorFromResponse(response);\n    }\n    return response.data;\n  }\n  /**\n   * Call a method on the remote peer\n   */\n  async call(defId, method, args) {\n    const service = this.getServiceNameFromDefId(defId);\n    const message = createRequestMessage(\n      service,\n      method,\n      args,\n      // Pass all arguments as array\n      {\n        context: this.buildRequestContext(),\n        hints: this.buildRequestHints()\n      }\n    );\n    const response = await this.sendRequestMessage(message);\n    if (!response.success) {\n      throw this.createErrorFromResponse(response);\n    }\n    if (response.hints?.cache) {\n      this.handleCacheHints(service, method, args[0], response.data, response.hints.cache);\n    }\n    return response.data;\n  }\n  /**\n   * Subscribe to events (requires WebSocket upgrade)\n   */\n  async subscribe(eventName, _handler) {\n    this.logger.warn({ eventName }, \"Event subscription requires WebSocket upgrade, falling back to polling\");\n  }\n  /**\n   * Unsubscribe from events\n   */\n  async unsubscribe(_eventName, _handler) {\n  }\n  /**\n   * Expose a service (not supported for HTTP client)\n   */\n  async exposeService(_instance) {\n    throw new Error(\"Service exposure not supported from HTTP client\");\n  }\n  /**\n   * Unexpose a service (not supported for HTTP client)\n   */\n  async unexposeService(_ctxId, _releaseOriginated) {\n  }\n  /**\n   * Get service names\n   */\n  getServiceNames() {\n    return Array.from(this.serviceNames);\n  }\n  /**\n   * Invalidate definition cache for services matching a pattern\n   * @override\n   */\n  invalidateDefinitionCache(pattern) {\n    const parentCount = super.invalidateDefinitionCache(pattern);\n    if (!pattern) {\n      const totalCount = this.services.size + this.definitions.size;\n      this.services.clear();\n      this.definitions.clear();\n      return parentCount + totalCount;\n    }\n    const servicesToDelete = [];\n    const definitionsToDelete = [];\n    for (const key of this.services.keys()) {\n      if (this.matchServicePattern(key, pattern)) {\n        servicesToDelete.push(key);\n        const def = this.services.get(key);\n        if (def) {\n          definitionsToDelete.push(def.id);\n        }\n      }\n    }\n    for (const key of servicesToDelete) {\n      this.services.delete(key);\n    }\n    for (const id of definitionsToDelete) {\n      this.definitions.delete(id);\n    }\n    return parentCount + servicesToDelete.length + definitionsToDelete.length;\n  }\n  /**\n   * Pattern matching helper for HTTP peer\n   * @private\n   */\n  matchServicePattern(serviceName, pattern) {\n    if (serviceName === pattern) return true;\n    if (!pattern.includes(\"*\")) return false;\n    const regexPattern = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/\\*/g, \".*\");\n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(serviceName);\n  }\n  /**\n   * Execute a task on the remote peer\n   */\n  async executeTask(task, payload) {\n    const message = createRequestMessage(\"__system\", task, payload);\n    const response = await this.sendRequestMessage(message);\n    if (!response.success) {\n      throw this.createErrorFromResponse(response);\n    }\n    return response.data;\n  }\n  /**\n   * Send HTTP request message\n   */\n  async sendRequestMessage(message) {\n    let processedMessage = message;\n    for (const interceptor of this.requestInterceptors) {\n      processedMessage = await interceptor(processedMessage);\n    }\n    const response = await this.sendHttpRequest(\n      \"POST\",\n      \"/netron/invoke\",\n      processedMessage\n    );\n    let processedResponse = response;\n    for (const interceptor of this.responseInterceptors) {\n      processedResponse = await interceptor(processedResponse);\n    }\n    return processedResponse;\n  }\n  /**\n   * Send HTTP request\n   */\n  async sendHttpRequest(method, path, body) {\n    const url = `${this.baseUrl}${path}`;\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"application/json\",\n      \"X-Netron-Version\": \"2.0\",\n      ...this.defaultOptions.headers\n    };\n    const controller = new AbortController();\n    const timeoutId = setTimeout(\n      () => controller.abort(),\n      this.defaultOptions.timeout\n    );\n    try {\n      const response = await fetch(url, {\n        method,\n        headers,\n        body: body ? JSON.stringify(body) : void 0,\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        try {\n          const errorData = await response.json();\n          if (errorData.error) {\n            throw new TitanError({\n              code: typeof errorData.error.code === \"number\" ? errorData.error.code : \"INTERNAL_ERROR\" /* INTERNAL_ERROR */,\n              message: errorData.error.message,\n              details: errorData.error.details\n            });\n          }\n        } catch {\n        }\n        throw new TitanError({\n          code: \"INTERNAL_ERROR\" /* INTERNAL_ERROR */,\n          message: `HTTP ${response.status}: ${response.statusText}`\n        });\n      }\n      return await response.json();\n    } catch (error) {\n      clearTimeout(timeoutId);\n      if (error.name === \"AbortError\") {\n        throw new TitanError({\n          code: \"REQUEST_TIMEOUT\" /* REQUEST_TIMEOUT */,\n          message: `Request timeout after ${this.defaultOptions.timeout}ms`\n        });\n      }\n      throw error;\n    }\n  }\n  /**\n   * Create service proxy\n   */\n  // @ts-expect-error - Unused in browser client\n  _createServiceProxy(definition) {\n    const self = this;\n    return new Proxy({}, {\n      get(_target, prop) {\n        if (definition.meta.methods[prop]) {\n          return async (...args) => self.call(definition.id, prop, args);\n        }\n        if (definition.meta.properties && definition.meta.properties[prop]) {\n          return self.get(definition.id, prop);\n        }\n        if (prop === \"$def\") {\n          return definition;\n        }\n        if (prop === \"$peer\") {\n          return self;\n        }\n        return void 0;\n      },\n      set(_target, prop, value) {\n        if (definition.meta.properties && definition.meta.properties[prop]) {\n          self.set(definition.id, prop, value);\n          return true;\n        }\n        return false;\n      }\n    });\n  }\n  /**\n   * Build request context\n   */\n  buildRequestContext() {\n    return {\n      // TODO: Add tracing, user context, etc.\n    };\n  }\n  /**\n   * Build request hints\n   */\n  buildRequestHints() {\n    return {\n      // TODO: Add caching, retry hints based on configuration\n    };\n  }\n  /**\n   * Handle cache hints from response\n   */\n  handleCacheHints(service, method, _input, _output, cacheHints) {\n    this.logger.debug({ service, method, cacheHints }, \"Received cache hints\");\n  }\n  /**\n   * Get service name from definition ID\n   */\n  getServiceNameFromDefId(defId) {\n    const definition = this.definitions.get(defId);\n    if (!definition) {\n      const parts = defId.split(\"-\");\n      return parts[0] || \"unknown\";\n    }\n    return definition.meta.name;\n  }\n  /**\n   * Create error from response\n   */\n  createErrorFromResponse(response) {\n    if (response.error) {\n      return new TitanError({\n        code: typeof response.error.code === \"string\" ? parseInt(response.error.code, 10) : response.error.code || \"INTERNAL_ERROR\" /* INTERNAL_ERROR */,\n        message: response.error.message,\n        details: response.error.details\n      });\n    }\n    return new Error(\"Unknown error\");\n  }\n  /**\n   * Add request interceptor\n   */\n  addRequestInterceptor(interceptor) {\n    this.requestInterceptors.push(interceptor);\n  }\n  /**\n   * Add response interceptor\n   */\n  addResponseInterceptor(interceptor) {\n    this.responseInterceptors.push(interceptor);\n  }\n  /**\n   * Emit event to the peer's event emitter\n   */\n  emit(event, ...args) {\n    return this.events.emit(event, ...args);\n  }\n  /**\n   * Close the peer connection\n   */\n  async close() {\n    this.logger.debug(\"Closing HTTP Remote peer connection\");\n    this.interfaces.clear();\n    this.services.clear();\n    this.definitions.clear();\n    if (this.connection && typeof this.connection.close === \"function\") {\n      await this.connection.close();\n    }\n    this.emit(\"disconnect\");\n  }\n  /**\n   * Check if peer is connected\n   */\n  get isConnected() {\n    return true;\n  }\n  /**\n   * Release interface internal\n   */\n  async releaseInterfaceInternal(_iInstance) {\n  }\n  /**\n   * Get definition by ID\n   */\n  getDefinitionById(defId) {\n    const def = this.definitions.get(defId);\n    if (!def) {\n      throw new Error(`Definition ${defId} not found`);\n    }\n    return def;\n  }\n  /**\n   * Get definition by service name\n   */\n  getDefinitionByServiceName(name) {\n    const def = this.services.get(name);\n    if (!def) {\n      throw new Error(`Service ${name} not found`);\n    }\n    return def;\n  }\n  /**\n   * Queries the remote peer for a service definition via HTTP endpoint.\n   * This method will use the POST /netron/query-interface endpoint.\n   *\n   * @param {string} qualifiedName - Service name with version (name@version)\n   * @returns {Promise<Definition>} Resolves with the service definition\n   * @throws {TitanError} If the service is not found or access is denied\n   * @protected\n   */\n  async queryInterfaceRemote(qualifiedName) {\n    this.logger.debug({ serviceName: qualifiedName }, \"Querying remote interface via HTTP\");\n    try {\n      const response = await this.sendHttpRequest(\n        \"POST\",\n        \"/netron/query-interface\",\n        { serviceName: qualifiedName }\n      );\n      const definitionMeta = response.data;\n      if (!definitionMeta) {\n        throw new TitanError({\n          code: \"NOT_FOUND\" /* NOT_FOUND */,\n          message: `Service '${qualifiedName}' not found on remote peer`\n        });\n      }\n      const definition = new Definition(\n        Definition.nextId(),\n        this.id,\n        definitionMeta\n      );\n      this.definitions.set(definition.id, definition);\n      const serviceKey = `${definition.meta.name}@${definition.meta.version}`;\n      this.services.set(serviceKey, definition);\n      this.logger.info(\n        {\n          serviceName: qualifiedName,\n          definitionId: definition.id,\n          methodCount: Object.keys(definition.meta.methods || {}).length\n        },\n        \"Remote interface queried successfully via HTTP\"\n      );\n      return definition;\n    } catch (error) {\n      this.logger.error(\n        { error, serviceName: qualifiedName },\n        \"Failed to query remote interface via HTTP\"\n      );\n      throw error;\n    }\n  }\n  /**\n   * Query interface for HTTP service (unified RPC API)\n   *\n   * Overrides AbstractPeer.queryInterface() to return standard HttpInterface\n   * for simple RPC functionality compatible with other transports.\n   *\n   * For advanced HTTP features (caching, retry, etc.), use queryFluentInterface().\n   *\n   * @template TService - Service interface type\n   * @param qualifiedName - Fully qualified service name (e.g., \"UserService@1.0.0\")\n   * @returns HttpInterface with standard RPC API\n   *\n   * @example\n   * ```typescript\n   * // Unified API - same as other transports (WebSocket, TCP, Unix)\n   * const userService = await peer.queryInterface<IUserService>('UserService@1.0.0');\n   *\n   * // Simple RPC method calls\n   * const user = await userService.getUser('user-123');\n   * const users = await userService.listUsers({ page: 1, limit: 10 });\n   * ```\n   *\n   * @override\n   */\n  async queryInterface(qualifiedName) {\n    const definition = await this.queryInterfaceRemote(qualifiedName);\n    const transport = this.getOrCreateHttpClient();\n    const httpInterface = new HttpInterface(transport, definition);\n    httpInterface.$peer = this;\n    const iInfo = { instance: httpInterface, refCount: 1 };\n    this.interfaces.set(definition.id, iInfo);\n    return httpInterface;\n  }\n  /**\n   * Query fluent interface for HTTP service (advanced HTTP API)\n   *\n   * Returns FluentInterface with advanced HTTP-specific features like caching,\n   * retry logic, optimistic updates, request deduplication, etc.\n   *\n   * This is HTTP-transport-specific and not available in other transports.\n   *\n   * @template TService - Service interface type\n   * @param qualifiedName - Fully qualified service name (e.g., \"UserService@1.0.0\")\n   * @returns FluentInterface with advanced HTTP features\n   *\n   * @example\n   * ```typescript\n   * const userService = await peer.queryFluentInterface<IUserService>('UserService@1.0.0');\n   *\n   * // Advanced HTTP features\n   * const user = await userService.cache(60000).retry(3).getUser('user-123');\n   * const users = await userService.priority('high').timeout(5000).listUsers();\n   * ```\n   */\n  async queryFluentInterface(qualifiedName) {\n    const definition = await this.queryInterfaceRemote(qualifiedName);\n    const transport = this.getOrCreateHttpClient();\n    const fluentInterface = new FluentInterface(\n      transport,\n      definition,\n      this.cacheManager,\n      this.retryManager,\n      this.globalOptions\n    );\n    fluentInterface.$peer = this;\n    const iInfo = { instance: fluentInterface, refCount: 1 };\n    this.interfaces.set(definition.id, iInfo);\n    return fluentInterface;\n  }\n  /**\n   * Get or create HTTP transport client for this peer\n   */\n  getOrCreateHttpClient() {\n    return new HttpTransportClient(this.baseUrl);\n  }\n  /**\n   * Set cache manager for all interfaces created by this peer\n   *\n   * @param manager - HttpCacheManager instance\n   * @returns this for method chaining\n   *\n   * @example\n   * ```typescript\n   * peer.setCacheManager(new HttpCacheManager({ maxEntries: 1000 }));\n   * const service = await peer.queryFluentInterface<IUserService>('UserService@1.0.0');\n   * // service will use the configured cache manager\n   * ```\n   */\n  setCacheManager(manager) {\n    this.cacheManager = manager;\n    return this;\n  }\n  /**\n   * Set retry manager for all interfaces created by this peer\n   *\n   * @param manager - RetryManager instance\n   * @returns this for method chaining\n   *\n   * @example\n   * ```typescript\n   * peer.setRetryManager(new RetryManager({ maxAttempts: 5 }));\n   * const service = await peer.queryFluentInterface<IUserService>('UserService@1.0.0');\n   * // service will use the configured retry manager\n   * ```\n   */\n  setRetryManager(manager) {\n    this.retryManager = manager;\n    return this;\n  }\n  /**\n   * Set global query options for all interfaces created by this peer\n   *\n   * @param options - Global query options\n   * @returns this for method chaining\n   *\n   * @example\n   * ```typescript\n   * peer.setGlobalOptions({\n   *   cache: { maxAge: 60000 },\n   *   retry: { attempts: 3 }\n   * });\n   * const service = await peer.queryFluentInterface<IUserService>('UserService@1.0.0');\n   * // service will use the global options by default\n   * ```\n   */\n  setGlobalOptions(options) {\n    this.globalOptions = options;\n    return this;\n  }\n  /**\n   * Get cache manager instance\n   */\n  getCacheManager() {\n    return this.cacheManager;\n  }\n  /**\n   * Get retry manager instance\n   */\n  getRetryManager() {\n    return this.retryManager;\n  }\n  /**\n   * Get global query options\n   */\n  getGlobalOptions() {\n    return this.globalOptions;\n  }\n};\n\n// src/netron/transport/http/client.ts\nvar HttpTransportClient = class {\n  constructor(baseUrl, netron, options) {\n    this.baseUrl = baseUrl;\n    this.netron = netron;\n    this.options = options;\n    this.baseUrl = baseUrl.endsWith(\"/\") ? baseUrl.slice(0, -1) : baseUrl;\n  }\n  static {\n    __name(this, \"HttpTransportClient\");\n  }\n  connection;\n  peer;\n  /**\n   * Initialize the client\n   */\n  async initialize() {\n    if (!this.connection) {\n      this.connection = new HttpConnection(this.baseUrl, this.options);\n      if (this.netron) {\n        this.peer = new HttpRemotePeer(this.connection, this.netron, this.baseUrl, this.options);\n        await this.peer.init(true, this.options);\n      }\n    }\n  }\n  /**\n   * Invoke a service method\n   */\n  async invoke(service, method, args, options) {\n    await this.initialize();\n    const message = createRequestMessage(service, method, args, {\n      context: options?.context,\n      hints: options?.hints\n    });\n    const response = await this.sendRequest(message);\n    if (!response.success) {\n      throw new Error(response.error?.message || \"Method invocation failed\");\n    }\n    return response.data;\n  }\n  /**\n   * Send HTTP request\n   */\n  async sendRequest(message) {\n    const url = `${this.baseUrl}/netron/invoke`;\n    const timeout = message.hints?.timeout || this.options?.timeout || 3e4;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\",\n          \"X-Netron-Version\": \"2.0\",\n          ...this.options?.headers\n        },\n        body: JSON.stringify(message),\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        try {\n          const errorData = await response.json();\n          return errorData;\n        } catch {\n          return {\n            id: message.id,\n            version: \"2.0\",\n            timestamp: Date.now(),\n            success: false,\n            error: {\n              code: \"HTTP_ERROR\",\n              message: `HTTP ${response.status}: ${response.statusText}`\n            }\n          };\n        }\n      }\n      return await response.json();\n    } catch (error) {\n      clearTimeout(timeoutId);\n      if (error.name === \"AbortError\") {\n        return {\n          id: message.id,\n          version: \"2.0\",\n          timestamp: Date.now(),\n          success: false,\n          error: {\n            code: \"TIMEOUT\",\n            message: `Request timeout after ${timeout}ms`\n          }\n        };\n      }\n      return {\n        id: message.id,\n        version: \"2.0\",\n        timestamp: Date.now(),\n        success: false,\n        error: {\n          code: \"NETWORK_ERROR\",\n          message: error.message\n        }\n      };\n    }\n  }\n  /**\n   * Close the client connection\n   */\n  async close() {\n    if (this.peer) {\n      await this.peer.close();\n    }\n    if (this.connection) {\n      await this.connection.close();\n    }\n  }\n  /**\n   * Get connection metrics\n   */\n  getMetrics() {\n    const connectionMetrics = this.connection?.getMetrics();\n    return {\n      id: connectionMetrics?.id || \"unknown\",\n      baseUrl: this.baseUrl,\n      connected: !!this.connection,\n      hasPeer: !!this.peer,\n      connectionMetrics\n    };\n  }\n};\n\n// src/netron/transport/ws/simple-client.ts\ninit_process_shim();\nvar SimpleWsClient = class {\n  constructor(options) {\n    this.options = options;\n  }\n  static {\n    __name(this, \"SimpleWsClient\");\n  }\n  ws;\n  pendingCalls = /* @__PURE__ */ new Map();\n  messageIdCounter = 0;\n  connected = false;\n  connecting = false;\n  reconnectAttempts = 0;\n  shouldReconnect = false;\n  /**\n   * Connect to WebSocket server\n   */\n  async connect() {\n    if (this.connected) return;\n    if (this.connecting) {\n      return new Promise((resolve, reject) => {\n        const checkInterval = setInterval(() => {\n          if (this.connected) {\n            clearInterval(checkInterval);\n            resolve();\n          } else if (!this.connecting) {\n            clearInterval(checkInterval);\n            reject(new Error(\"Connection failed\"));\n          }\n        }, 100);\n      });\n    }\n    this.connecting = true;\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket(this.options.url);\n      const onOpen = /* @__PURE__ */ __name(() => {\n        this.connected = true;\n        this.connecting = false;\n        this.reconnectAttempts = 0;\n        this.shouldReconnect = this.options.reconnect !== false;\n        this.ws.removeEventListener(\"open\", onOpen);\n        this.ws.removeEventListener(\"error\", onError);\n        this.setupListeners();\n        resolve();\n      }, \"onOpen\");\n      const onError = /* @__PURE__ */ __name((error) => {\n        this.connecting = false;\n        reject(new Error(\"WebSocket connection failed\"));\n      }, \"onError\");\n      this.ws.addEventListener(\"open\", onOpen);\n      this.ws.addEventListener(\"error\", onError);\n    });\n  }\n  /**\n   * Setup WebSocket event listeners\n   */\n  setupListeners() {\n    if (!this.ws) return;\n    this.ws.addEventListener(\"message\", (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        this.handleMessage(message);\n      } catch (error) {\n        console.error(\"Failed to parse WebSocket message:\", error);\n      }\n    });\n    this.ws.addEventListener(\"close\", () => {\n      this.connected = false;\n      this.connecting = false;\n      for (const [id, pending] of this.pendingCalls.entries()) {\n        clearTimeout(pending.timeout);\n        pending.reject(new Error(\"WebSocket closed\"));\n        this.pendingCalls.delete(id);\n      }\n      if (this.shouldReconnect) {\n        this.handleReconnect();\n      }\n    });\n    this.ws.addEventListener(\"error\", (error) => {\n      console.error(\"WebSocket error:\", error);\n    });\n  }\n  /**\n   * Handle incoming message\n   */\n  handleMessage(message) {\n    if (message.type === \"response\") {\n      const pending = this.pendingCalls.get(message.id);\n      if (pending) {\n        clearTimeout(pending.timeout);\n        pending.resolve(message.result);\n        this.pendingCalls.delete(message.id);\n      }\n    } else if (message.type === \"error\") {\n      const pending = this.pendingCalls.get(message.id);\n      if (pending) {\n        clearTimeout(pending.timeout);\n        const error = new Error(message.error?.message || \"Remote error\");\n        error.code = message.error?.code;\n        pending.reject(error);\n        this.pendingCalls.delete(message.id);\n      }\n    }\n  }\n  /**\n   * Call remote method\n   */\n  async call(service, method, ...args) {\n    if (!this.connected) {\n      throw new Error(\"WebSocket not connected\");\n    }\n    const id = `msg-${++this.messageIdCounter}`;\n    const timeout = this.options.timeout || 3e4;\n    return new Promise((resolve, reject) => {\n      const timeoutHandle = setTimeout(() => {\n        this.pendingCalls.delete(id);\n        reject(new Error(`Request timeout after ${timeout}ms`));\n      }, timeout);\n      this.pendingCalls.set(id, {\n        resolve,\n        reject,\n        timeout: timeoutHandle\n      });\n      const message = {\n        id,\n        type: \"call\",\n        service,\n        method,\n        args\n      };\n      this.ws.send(JSON.stringify(message));\n    });\n  }\n  /**\n   * Handle reconnection\n   */\n  async handleReconnect() {\n    const maxAttempts = this.options.maxReconnectAttempts ?? Infinity;\n    if (this.reconnectAttempts >= maxAttempts) {\n      console.error(\"Max reconnect attempts reached\");\n      return;\n    }\n    this.reconnectAttempts++;\n    const delay = this.options.reconnectInterval ?? 5e3;\n    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);\n    setTimeout(async () => {\n      try {\n        await this.connect();\n      } catch (error) {\n        console.error(\"Reconnect failed:\", error);\n      }\n    }, delay);\n  }\n  /**\n   * Check if connected\n   */\n  isConnected() {\n    return this.connected && this.ws?.readyState === WebSocket.OPEN;\n  }\n  /**\n   * Close connection\n   */\n  async close() {\n    this.shouldReconnect = false;\n    if (this.ws) {\n      this.ws.close();\n      this.ws = void 0;\n    }\n    this.connected = false;\n  }\n};\n\n// src/netron/logger.ts\ninit_process_shim();\nvar BrowserLogger = class _BrowserLogger {\n  constructor(context = {}) {\n    this.context = context;\n  }\n  static {\n    __name(this, \"BrowserLogger\");\n  }\n  /**\n   * Format message for logging\n   * Handles both signatures: (msg) and (obj, msg)\n   */\n  formatMessage(obj, msg) {\n    if (typeof obj === \"string\") {\n      return [obj];\n    }\n    return [msg || \"\", { ...this.context, ...obj }];\n  }\n  debug(obj, msg) {\n    const [message, data] = this.formatMessage(obj, msg);\n    if (data) {\n      console.debug(\"[Netron]\", message, data);\n    } else {\n      console.debug(\"[Netron]\", message);\n    }\n  }\n  info(obj, msg) {\n    const [message, data] = this.formatMessage(obj, msg);\n    if (data) {\n      console.info(\"[Netron]\", message, data);\n    } else {\n      console.info(\"[Netron]\", message);\n    }\n  }\n  warn(obj, msg) {\n    const [message, data] = this.formatMessage(obj, msg);\n    if (data) {\n      console.warn(\"[Netron]\", message, data);\n    } else {\n      console.warn(\"[Netron]\", message);\n    }\n  }\n  error(obj, msg) {\n    const [message, data] = this.formatMessage(obj, msg);\n    if (data) {\n      console.error(\"[Netron]\", message, data);\n    } else {\n      console.error(\"[Netron]\", message);\n    }\n  }\n  /**\n   * Create a child logger with additional context\n   * Context is accumulated from parent to child\n   */\n  child(context) {\n    return new _BrowserLogger({ ...this.context, ...context });\n  }\n};\n\n// src/netron/netron.ts\nvar Netron = class {\n  constructor(options) {\n    this.options = options;\n    this.id = crypto.randomUUID();\n    this.logger = options.logger ?? new BrowserLogger({ client: \"Netron\" });\n    this.netronStub = this.createNetronStub();\n  }\n  static {\n    __name(this, \"Netron\");\n  }\n  logger;\n  netronStub;\n  peer = null;\n  httpClient = null;\n  wsClient = null;\n  ws = null;\n  reconnectAttempts = 0;\n  shouldReconnect = false;\n  /**\n   * Unique identifier for this client instance\n   */\n  id;\n  /**\n   * Connect to server\n   * For HTTP: initializes the client\n   * For WebSocket: establishes connection\n   */\n  async connect() {\n    if (this.options.transport === \"http\") {\n      return this.connectHttp();\n    } else {\n      return this.connectWebSocket();\n    }\n  }\n  /**\n   * Query service interface by name\n   * Returns a typed proxy for calling remote methods\n   *\n   * @param serviceName - Service name with optional version (e.g. 'Calculator@1.0.0')\n   * @returns Typed service proxy\n   *\n   * @example\n   * ```typescript\n   * const calc = await client.queryInterface<Calculator>('Calculator@1.0.0');\n   * const result = await calc.add(2, 3);\n   * ```\n   */\n  queryInterface(serviceName) {\n    if (this.options.transport === \"http\") {\n      if (!this.httpClient) {\n        throw new Error(\"Not connected. Call connect() first.\");\n      }\n      this.logger.debug({ serviceName }, \"Creating HTTP service proxy\");\n      const SPECIAL_PROPERTIES = [\n        \"then\",\n        \"catch\",\n        \"finally\",\n        // Promise methods\n        \"constructor\",\n        \"prototype\",\n        // Object methods\n        \"$$typeof\",\n        \"nodeType\",\n        \"tagName\",\n        // React/DOM inspection\n        Symbol.toStringTag,\n        // toString behavior\n        Symbol.iterator,\n        // Iterator protocol\n        Symbol.asyncIterator\n        // Async iterator protocol\n      ];\n      return new Proxy({}, {\n        get: /* @__PURE__ */ __name((_target, prop) => {\n          if (SPECIAL_PROPERTIES.includes(prop)) {\n            return void 0;\n          }\n          if (typeof prop === \"symbol\") {\n            return void 0;\n          }\n          if (typeof prop === \"string\" && (prop.startsWith(\"$\") || prop.startsWith(\"__\"))) {\n            return void 0;\n          }\n          return async (...args) => {\n            this.logger.debug({ serviceName, method: prop, args }, \"Invoking HTTP method\");\n            return this.httpClient.invoke(serviceName, prop, args);\n          };\n        }, \"get\")\n      });\n    } else {\n      if (!this.wsClient) {\n        throw new Error(\"Not connected. Call connect() first.\");\n      }\n      this.logger.debug({ serviceName }, \"Creating WebSocket service proxy\");\n      const SPECIAL_PROPERTIES = [\n        \"then\",\n        \"catch\",\n        \"finally\",\n        \"constructor\",\n        \"prototype\",\n        \"$$typeof\",\n        \"nodeType\",\n        \"tagName\",\n        Symbol.toStringTag,\n        Symbol.iterator,\n        Symbol.asyncIterator\n      ];\n      return new Proxy({}, {\n        get: /* @__PURE__ */ __name((_target, prop) => {\n          if (SPECIAL_PROPERTIES.includes(prop)) {\n            return void 0;\n          }\n          if (typeof prop === \"symbol\") {\n            return void 0;\n          }\n          if (typeof prop === \"string\" && (prop.startsWith(\"$\") || prop.startsWith(\"__\"))) {\n            return void 0;\n          }\n          return async (...args) => {\n            this.logger.debug({ serviceName, method: prop, args }, \"Invoking WebSocket method\");\n            return this.wsClient.call(serviceName, prop, ...args);\n          };\n        }, \"get\")\n      });\n    }\n  }\n  /**\n   * Subscribe to server events (WebSocket only)\n   *\n   * @param event - Event name\n   * @param handler - Event handler function\n   * @throws Error if using HTTP transport or not connected\n   */\n  async subscribe(event, handler) {\n    if (this.options.transport === \"http\") {\n      throw new Error(\"Events not supported with HTTP transport. Use WebSocket instead.\");\n    }\n    if (!this.peer) {\n      throw new Error(\"Not connected. Call connect() first.\");\n    }\n    return this.peer.subscribe(event, handler);\n  }\n  /**\n   * Unsubscribe from server events (WebSocket only)\n   *\n   * @param event - Event name\n   * @param handler - Event handler to remove\n   */\n  async unsubscribe(event, handler) {\n    if (this.options.transport === \"http\") {\n      throw new Error(\"Events not supported with HTTP transport\");\n    }\n    if (!this.peer) {\n      throw new Error(\"Not connected. Call connect() first.\");\n    }\n    return this.peer.unsubscribe(event, handler);\n  }\n  /**\n   * Disconnect from server\n   * Closes connection and cleans up resources\n   */\n  async disconnect() {\n    this.shouldReconnect = false;\n    this.logger.info(\"Disconnecting from server\");\n    if (this.options.transport === \"http\") {\n      if (this.httpClient) {\n        await this.httpClient.close();\n        this.httpClient = null;\n      }\n    } else {\n      if (this.wsClient) {\n        await this.wsClient.close();\n        this.wsClient = null;\n      }\n    }\n  }\n  /**\n   * Check if currently connected\n   */\n  isConnected() {\n    if (this.options.transport === \"http\") {\n      return this.httpClient !== null;\n    } else {\n      return this.wsClient?.isConnected() || false;\n    }\n  }\n  /**\n   * Get current transport type\n   */\n  getTransport() {\n    return this.options.transport;\n  }\n  /**\n   * Get client metrics\n   */\n  getMetrics() {\n    if (this.options.transport === \"http\" && this.httpClient) {\n      return this.httpClient.getMetrics();\n    }\n    return {\n      id: this.id,\n      transport: this.options.transport,\n      connected: this.isConnected(),\n      url: this.options.url\n    };\n  }\n  // --- Private methods ---\n  async connectHttp() {\n    this.logger.info({ url: this.options.url }, \"Initializing HTTP client\");\n    this.httpClient = new HttpTransportClient(this.options.url, this.netronStub, {\n      timeout: this.options.timeout,\n      headers: this.options.headers\n    });\n    await this.httpClient.initialize();\n    this.logger.info(\"HTTP client initialized\");\n  }\n  async connectWebSocket() {\n    this.logger.info({ url: this.options.url }, \"Connecting via WebSocket\");\n    this.wsClient = new SimpleWsClient({\n      url: this.options.url,\n      timeout: this.options.timeout,\n      reconnect: this.options.reconnect,\n      reconnectInterval: this.options.reconnectInterval,\n      maxReconnectAttempts: this.options.maxReconnectAttempts\n    });\n    await this.wsClient.connect();\n    this.logger.info(\"WebSocket client initialized\");\n  }\n  async handleReconnect() {\n    if (!this.shouldReconnect || this.options.transport !== \"websocket\") {\n      return;\n    }\n    const maxAttempts = this.options.maxReconnectAttempts ?? Infinity;\n    if (this.reconnectAttempts >= maxAttempts) {\n      this.logger.error({ attempts: this.reconnectAttempts }, \"Max reconnect attempts reached\");\n      return;\n    }\n    this.reconnectAttempts++;\n    const delay = this.options.reconnectInterval ?? 5e3;\n    this.logger.info(\n      { delay, attempt: this.reconnectAttempts, maxAttempts },\n      `Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`\n    );\n    setTimeout(() => {\n      this.connectWebSocket().catch((err) => {\n        this.logger.error({ error: err }, \"Reconnect failed\");\n      });\n    }, delay);\n  }\n  createNetronStub() {\n    return {\n      uuid: this.id,\n      logger: this.logger,\n      options: void 0,\n      services: /* @__PURE__ */ new Map(),\n      peer: null,\n      peers: /* @__PURE__ */ new Map(),\n      transportServers: /* @__PURE__ */ new Map(),\n      transportServer: void 0,\n      getLocalPeer: /* @__PURE__ */ __name(() => {\n        throw new Error(\"getLocalPeer() not available in browser\");\n      }, \"getLocalPeer\"),\n      findPeer: /* @__PURE__ */ __name(() => void 0, \"findPeer\"),\n      trackTask: /* @__PURE__ */ __name(async () => {\n        throw new Error(\"trackTask() not available in browser\");\n      }, \"trackTask\"),\n      runTask: void 0,\n      emitSpecial: /* @__PURE__ */ __name(() => {\n      }, \"emitSpecial\"),\n      getServiceNames: /* @__PURE__ */ __name(() => [], \"getServiceNames\"),\n      emit: /* @__PURE__ */ __name(() => false, \"emit\"),\n      on() {\n        return this;\n      },\n      off() {\n        return this;\n      },\n      removeListener() {\n        return this;\n      },\n      getPeerEventName: void 0\n    };\n  }\n};\nexport {\n  Netron\n};\n/*! Bundled license information:\n\nlong/index.js:\n  (**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n//# sourceMappingURL=netron-unified.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 398284,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__name",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 284,
            "endOffset": 359,
            "count": 324
          }
        ]
      },
      {
        "functionName": "__esm",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 373,
            "endOffset": 478,
            "count": 28
          }
        ]
      },
      {
        "functionName": "__init",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 386,
            "endOffset": 478,
            "count": 151
          },
          {
            "startOffset": 418,
            "endOffset": 470,
            "count": 28
          }
        ]
      },
      {
        "functionName": "__commonJS",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 497,
            "endOffset": 636,
            "count": 48
          }
        ]
      },
      {
        "functionName": "__require",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 510,
            "endOffset": 636,
            "count": 123
          },
          {
            "startOffset": 546,
            "endOffset": 620,
            "count": 48
          }
        ]
      },
      {
        "functionName": "__export",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 653,
            "endOffset": 764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__copyProps",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 784,
            "endOffset": 1130,
            "count": 3
          },
          {
            "startOffset": 853,
            "endOffset": 882,
            "count": 0
          },
          {
            "startOffset": 937,
            "endOffset": 1111,
            "count": 53
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1022,
            "endOffset": 1037,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__toESM",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1146,
            "endOffset": 1655,
            "count": 3
          },
          {
            "startOffset": 1227,
            "endOffset": 1231,
            "count": 0
          },
          {
            "startOffset": 1545,
            "endOffset": 1552,
            "count": 0
          },
          {
            "startOffset": 1553,
            "endOffset": 1571,
            "count": 0
          },
          {
            "startOffset": 1637,
            "endOffset": 1645,
            "count": 0
          }
        ]
      },
      {
        "functionName": "e2e/stubs/process-shim.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1764,
            "endOffset": 2441,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1956,
            "endOffset": 1965,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2014,
            "endOffset": 2048,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2111,
            "endOffset": 2182,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2154,
            "endOffset": 2171,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2245,
            "endOffset": 2291,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../common/dist/primitives.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2511,
            "endOffset": 2592,
            "count": 1
          }
        ]
      },
      {
        "functionName": "../common/dist/predicates.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2881,
            "endOffset": 4495,
            "count": 1
          },
          {
            "startOffset": 3558,
            "endOffset": 3561,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3652,
            "endOffset": 3811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3869,
            "endOffset": 4342,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../common/dist/omit.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4553,
            "endOffset": 4674,
            "count": 1
          }
        ]
      },
      {
        "functionName": "../common/dist/entries.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4758,
            "endOffset": 4935,
            "count": 1
          }
        ]
      },
      {
        "functionName": "../common/dist/promise.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4999,
            "endOffset": 5143,
            "count": 1
          }
        ]
      },
      {
        "functionName": "pLimit",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5178,
            "endOffset": 7508,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateConcurrency",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7509,
            "endOffset": 7745,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../common/dist/p-limit.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7786,
            "endOffset": 8727,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7887,
            "endOffset": 7934,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Queue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 7988,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7995,
            "endOffset": 8240,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dequeue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8247,
            "endOffset": 8488,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clear",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8495,
            "endOffset": 8576,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get size",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8583,
            "endOffset": 8630,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../common/dist/timed-map.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8795,
            "endOffset": 8875,
            "count": 1
          }
        ]
      },
      {
        "functionName": "../common/dist/list-buffer.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8947,
            "endOffset": 9029,
            "count": 1
          }
        ]
      },
      {
        "functionName": "../common/dist/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9088,
            "endOffset": 9333,
            "count": 1
          }
        ]
      },
      {
        "functionName": "src/netron/uid.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9406,
            "endOffset": 10212,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9497,
            "endOffset": 9542,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9549,
            "endOffset": 9555,
            "count": 2
          }
        ]
      },
      {
        "functionName": "next",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9657,
            "endOffset": 9699,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9843,
            "endOffset": 9908,
            "count": 0
          }
        ]
      },
      {
        "functionName": "randomUUID",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10061,
            "endOffset": 10119,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10167,
            "endOffset": 10192,
            "count": 0
          }
        ]
      },
      {
        "functionName": "src/netron/packet/types.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10330,
            "endOffset": 10484,
            "count": 1
          }
        ]
      },
      {
        "functionName": "src/netron/packet/packet.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10685,
            "endOffset": 17474,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10832,
            "endOffset": 10872,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10924,
            "endOffset": 11097,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11152,
            "endOffset": 11362,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11416,
            "endOffset": 11612,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Packet",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12149,
            "endOffset": 12196,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12203,
            "endOffset": 12251,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12340,
            "endOffset": 12560,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12967,
            "endOffset": 13099,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13346,
            "endOffset": 13426,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setImpulse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13841,
            "endOffset": 13948,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getImpulse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14117,
            "endOffset": 14190,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14572,
            "endOffset": 14673,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14831,
            "endOffset": 14900,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setStreamInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15618,
            "endOffset": 15872,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isStreamChunk",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16120,
            "endOffset": 16192,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isLastChunk",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16477,
            "endOffset": 16553,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isLive",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16803,
            "endOffset": 16875,
            "count": 0
          }
        ]
      },
      {
        "functionName": "nextId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17148,
            "endOffset": 17193,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17423,
            "endOffset": 17463,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/internal/constants.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17570,
            "endOffset": 18328,
            "count": 1
          },
          {
            "startOffset": 17798,
            "endOffset": 17848,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/internal/debug.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18416,
            "endOffset": 18751,
            "count": 1
          },
          {
            "startOffset": 18609,
            "endOffset": 18654,
            "count": 0
          },
          {
            "startOffset": 18655,
            "endOffset": 18702,
            "count": 0
          }
        ]
      },
      {
        "functionName": "debug",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18657,
            "endOffset": 18702,
            "count": 0
          }
        ]
      },
      {
        "functionName": "debug",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18705,
            "endOffset": 18718,
            "count": 49
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/internal/re.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18833,
            "endOffset": 24076,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 19531,
            "endOffset": 19750,
            "count": 43
          },
          {
            "startOffset": 19600,
            "endOffset": 19724,
            "count": 129
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 19815,
            "endOffset": 20153,
            "count": 43
          },
          {
            "startOffset": 20066,
            "endOffset": 20071,
            "count": 5
          },
          {
            "startOffset": 20072,
            "endOffset": 20080,
            "count": 38
          },
          {
            "startOffset": 20131,
            "endOffset": 20136,
            "count": 5
          },
          {
            "startOffset": 20137,
            "endOffset": 20145,
            "count": 38
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/internal/parse-options.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 24180,
            "endOffset": 24667,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 24435,
            "endOffset": 24610,
            "count": 4
          },
          {
            "startOffset": 24505,
            "endOffset": 24609,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/internal/identifiers.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 24767,
            "endOffset": 25425,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24963,
            "endOffset": 25202,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25280,
            "endOffset": 25314,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/classes/semver.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 25514,
            "endOffset": 34678,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 25904,
            "endOffset": 25952,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_SemVer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 25959,
            "endOffset": 27887,
            "count": 2
          },
          {
            "startOffset": 26072,
            "endOffset": 26293,
            "count": 0
          },
          {
            "startOffset": 26332,
            "endOffset": 26442,
            "count": 0
          },
          {
            "startOffset": 26484,
            "endOffset": 26601,
            "count": 0
          },
          {
            "startOffset": 26830,
            "endOffset": 26843,
            "count": 0
          },
          {
            "startOffset": 26875,
            "endOffset": 26948,
            "count": 0
          },
          {
            "startOffset": 27122,
            "endOffset": 27189,
            "count": 0
          },
          {
            "startOffset": 27251,
            "endOffset": 27318,
            "count": 0
          },
          {
            "startOffset": 27380,
            "endOffset": 27447,
            "count": 0
          },
          {
            "startOffset": 27467,
            "endOffset": 27806,
            "count": 1
          },
          {
            "startOffset": 27833,
            "endOffset": 27850,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 27566,
            "endOffset": 27794,
            "count": 1
          },
          {
            "startOffset": 27759,
            "endOffset": 27793,
            "count": 0
          }
        ]
      },
      {
        "functionName": "format",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 27894,
            "endOffset": 28116,
            "count": 2
          },
          {
            "startOffset": 28009,
            "endOffset": 28079,
            "count": 1
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28123,
            "endOffset": 28172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compare",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28179,
            "endOffset": 28621,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compareMain",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28628,
            "endOffset": 28915,
            "count": 0
          }
        ]
      },
      {
        "functionName": "comparePre",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28922,
            "endOffset": 29839,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compareBuild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29846,
            "endOffset": 30466,
            "count": 0
          }
        ]
      },
      {
        "functionName": "inc",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30630,
            "endOffset": 34638,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/parse.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 34767,
            "endOffset": 35279,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34950,
            "endOffset": 35236,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/valid.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 35368,
            "endOffset": 35697,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35549,
            "endOffset": 35654,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/clean.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 35786,
            "endOffset": 36144,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35967,
            "endOffset": 36101,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/inc.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 36229,
            "endOffset": 36887,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 36408,
            "endOffset": 36848,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/diff.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 36974,
            "endOffset": 38286,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37153,
            "endOffset": 38245,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/major.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 38375,
            "endOffset": 38641,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 38558,
            "endOffset": 38598,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/minor.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 38730,
            "endOffset": 38996,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 38913,
            "endOffset": 38953,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/patch.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 39085,
            "endOffset": 39351,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 39268,
            "endOffset": 39308,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/prerelease.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 39450,
            "endOffset": 39845,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 39641,
            "endOffset": 39792,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/compare.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 39938,
            "endOffset": 40241,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 40126,
            "endOffset": 40193,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/rcompare.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 40336,
            "endOffset": 40615,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 40528,
            "endOffset": 40566,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/compare-loose.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 40720,
            "endOffset": 41008,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 40921,
            "endOffset": 40951,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/compare-build.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 41113,
            "endOffset": 41558,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 41311,
            "endOffset": 41501,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/sort.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 41645,
            "endOffset": 41943,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 41839,
            "endOffset": 41902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/rsort.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42032,
            "endOffset": 42334,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42228,
            "endOffset": 42291,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/gt.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42417,
            "endOffset": 42676,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42597,
            "endOffset": 42639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/lt.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42759,
            "endOffset": 43018,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42939,
            "endOffset": 42981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/eq.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 43101,
            "endOffset": 43362,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43281,
            "endOffset": 43325,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/neq.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 43447,
            "endOffset": 43712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43629,
            "endOffset": 43673,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/gte.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 43797,
            "endOffset": 44061,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43979,
            "endOffset": 44022,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/lte.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 44146,
            "endOffset": 44410,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 44328,
            "endOffset": 44371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/cmp.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 44495,
            "endOffset": 45735,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 44807,
            "endOffset": 45696,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/coerce.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 45826,
            "endOffset": 47484,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 46086,
            "endOffset": 47439,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/internal/lrucache.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 47578,
            "endOffset": 48555,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 47722,
            "endOffset": 47772,
            "count": 1
          }
        ]
      },
      {
        "functionName": "LRUCache",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 47779,
            "endOffset": 47872,
            "count": 1
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 47879,
            "endOffset": 48114,
            "count": 0
          }
        ]
      },
      {
        "functionName": "delete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48121,
            "endOffset": 48179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48186,
            "endOffset": 48513,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/classes/range.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 48642,
            "endOffset": 61924,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 48821,
            "endOffset": 48868,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_Range",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48875,
            "endOffset": 50285,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get range",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50292,
            "endOffset": 50817,
            "count": 0
          }
        ]
      },
      {
        "functionName": "format",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50824,
            "endOffset": 50869,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50876,
            "endOffset": 50923,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseRange",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50930,
            "endOffset": 52709,
            "count": 0
          }
        ]
      },
      {
        "functionName": "intersects",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52716,
            "endOffset": 53319,
            "count": 0
          }
        ]
      },
      {
        "functionName": "test",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 53394,
            "endOffset": 53846,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 54351,
            "endOffset": 54380,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 54435,
            "endOffset": 54456,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 54515,
            "endOffset": 54969,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55038,
            "endOffset": 55405,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55464,
            "endOffset": 55517,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55574,
            "endOffset": 55686,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55752,
            "endOffset": 56432,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56498,
            "endOffset": 56610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56676,
            "endOffset": 58106,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58173,
            "endOffset": 58325,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58393,
            "endOffset": 59871,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 59937,
            "endOffset": 60057,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 60121,
            "endOffset": 60280,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 60345,
            "endOffset": 61127,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 61188,
            "endOffset": 61907,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/classes/comparator.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 62021,
            "endOffset": 65782,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 62216,
            "endOffset": 62268,
            "count": 1
          }
        ]
      },
      {
        "functionName": "get ANY",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 62282,
            "endOffset": 62321,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_Comparator",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 62328,
            "endOffset": 62962,
            "count": 2
          },
          {
            "startOffset": 62439,
            "endOffset": 62585,
            "count": 0
          },
          {
            "startOffset": 62810,
            "endOffset": 62848,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parse",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 62969,
            "endOffset": 63463,
            "count": 2
          },
          {
            "startOffset": 63020,
            "endOffset": 63043,
            "count": 0
          },
          {
            "startOffset": 63113,
            "endOffset": 63186,
            "count": 0
          },
          {
            "startOffset": 63234,
            "endOffset": 63238,
            "count": 0
          },
          {
            "startOffset": 63275,
            "endOffset": 63316,
            "count": 0
          },
          {
            "startOffset": 63336,
            "endOffset": 63376,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63470,
            "endOffset": 63517,
            "count": 0
          }
        ]
      },
      {
        "functionName": "test",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63524,
            "endOffset": 63957,
            "count": 0
          }
        ]
      },
      {
        "functionName": "intersects",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63964,
            "endOffset": 65518,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/functions/satisfies.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 65879,
            "endOffset": 66295,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66068,
            "endOffset": 66244,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/to-comparators.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 66399,
            "endOffset": 66770,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66594,
            "endOffset": 66711,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/max-satisfying.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 66874,
            "endOffset": 67611,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67104,
            "endOffset": 67552,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/min-satisfying.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 67715,
            "endOffset": 68451,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67945,
            "endOffset": 68392,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/min-version.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 68549,
            "endOffset": 70271,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68800,
            "endOffset": 70218,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/valid.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 70358,
            "endOffset": 70738,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70541,
            "endOffset": 70685,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/outside.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 70828,
            "endOffset": 72906,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 71271,
            "endOffset": 72859,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/gtr.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 72988,
            "endOffset": 73271,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73166,
            "endOffset": 73232,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/ltr.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 73353,
            "endOffset": 73636,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73531,
            "endOffset": 73597,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/intersects.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 73732,
            "endOffset": 74112,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73920,
            "endOffset": 74059,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/simplify.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 74204,
            "endOffset": 75609,
            "count": 1
          }
        ]
      },
      {
        "functionName": "module.exports",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74413,
            "endOffset": 75604,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/ranges/subset.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 75697,
            "endOffset": 81262,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 76029,
            "endOffset": 76595,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 76778,
            "endOffset": 80659,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 80720,
            "endOffset": 80940,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 80996,
            "endOffset": 81216,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/semver/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 81343,
            "endOffset": 83833,
            "count": 1
          }
        ]
      },
      {
        "functionName": "src/netron/reference.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 83912,
            "endOffset": 85016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Reference",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 84751,
            "endOffset": 84947,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 84954,
            "endOffset": 85005,
            "count": 1
          }
        ]
      },
      {
        "functionName": "e2e/stubs/stream.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 85097,
            "endOffset": 85403,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 85195,
            "endOffset": 85245,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Readable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 85252,
            "endOffset": 85275,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 85312,
            "endOffset": 85362,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Writable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 85369,
            "endOffset": 85392,
            "count": 0
          }
        ]
      },
      {
        "functionName": "src/netron/readable-stream.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 85522,
            "endOffset": 93898,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 85727,
            "endOffset": 85789,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 85856,
            "endOffset": 92588,
            "count": 0
          }
        ]
      },
      {
        "functionName": "destroy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 92918,
            "endOffset": 93291,
            "count": 0
          }
        ]
      },
      {
        "functionName": "create",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 93769,
            "endOffset": 93887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Long",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 93940,
            "endOffset": 94054,
            "count": 9
          }
        ]
      },
      {
        "functionName": "isLong",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94055,
            "endOffset": 94125,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ctz32",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94126,
            "endOffset": 94218,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromInt",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 94219,
            "endOffset": 94809,
            "count": 6
          },
          {
            "startOffset": 94300,
            "endOffset": 94542,
            "count": 2
          },
          {
            "startOffset": 94423,
            "endOffset": 94440,
            "count": 0
          },
          {
            "startOffset": 94542,
            "endOffset": 94807,
            "count": 4
          },
          {
            "startOffset": 94612,
            "endOffset": 94694,
            "count": 3
          },
          {
            "startOffset": 94671,
            "endOffset": 94688,
            "count": 0
          },
          {
            "startOffset": 94731,
            "endOffset": 94735,
            "count": 1
          },
          {
            "startOffset": 94736,
            "endOffset": 94739,
            "count": 3
          },
          {
            "startOffset": 94764,
            "endOffset": 94787,
            "count": 3
          }
        ]
      },
      {
        "functionName": "fromNumber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94810,
            "endOffset": 95296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromBits",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 95297,
            "endOffset": 95395,
            "count": 9
          }
        ]
      },
      {
        "functionName": "fromString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 95396,
            "endOffset": 96489,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 96490,
            "endOffset": 96768,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/long/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 97033,
            "endOffset": 123510,
            "count": 1
          },
          {
            "startOffset": 102641,
            "endOffset": 102654,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toInt",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 104158,
            "endOffset": 104238,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toNumber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 104302,
            "endOffset": 104484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 104551,
            "endOffset": 105484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHighBits",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 105554,
            "endOffset": 105608,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHighBitsUnsigned",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 105689,
            "endOffset": 105757,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getLowBits",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 105837,
            "endOffset": 105889,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getLowBitsUnsigned",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 105968,
            "endOffset": 106034,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNumBitsAbs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 106116,
            "endOffset": 106426,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isSafeInteger2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 106503,
            "endOffset": 106727,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isZero",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 106797,
            "endOffset": 106870,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNegative",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 106983,
            "endOffset": 107058,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isPositive",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 107129,
            "endOffset": 107204,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isOdd",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 107270,
            "endOffset": 107329,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isEven",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 107391,
            "endOffset": 107451,
            "count": 0
          }
        ]
      },
      {
        "functionName": "equals",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 107514,
            "endOffset": 107780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "notEquals",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 107891,
            "endOffset": 107994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lessThan",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 108159,
            "endOffset": 108266,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lessThanOrEqual",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 108387,
            "endOffset": 108502,
            "count": 0
          }
        ]
      },
      {
        "functionName": "greaterThan",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 108688,
            "endOffset": 108798,
            "count": 0
          }
        ]
      },
      {
        "functionName": "greaterThanOrEqual",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 108928,
            "endOffset": 109046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compare",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 109237,
            "endOffset": 109705,
            "count": 0
          }
        ]
      },
      {
        "functionName": "negate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 109817,
            "endOffset": 109942,
            "count": 0
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 110048,
            "endOffset": 110780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "subtract",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 110842,
            "endOffset": 110987,
            "count": 0
          }
        ]
      },
      {
        "functionName": "multiply",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 111102,
            "endOffset": 112937,
            "count": 0
          }
        ]
      },
      {
        "functionName": "divide",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 113050,
            "endOffset": 115455,
            "count": 0
          }
        ]
      },
      {
        "functionName": "modulo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 115564,
            "endOffset": 115965,
            "count": 0
          }
        ]
      },
      {
        "functionName": "not",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116117,
            "endOffset": 116200,
            "count": 0
          }
        ]
      },
      {
        "functionName": "countLeadingZeros",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116271,
            "endOffset": 116383,
            "count": 0
          }
        ]
      },
      {
        "functionName": "countTrailingZeros",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116526,
            "endOffset": 116628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "and",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116758,
            "endOffset": 116921,
            "count": 0
          }
        ]
      },
      {
        "functionName": "or",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116977,
            "endOffset": 117139,
            "count": 0
          }
        ]
      },
      {
        "functionName": "xor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 117195,
            "endOffset": 117358,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shiftLeft",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 117421,
            "endOffset": 117808,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shiftRight",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 117927,
            "endOffset": 118387,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shiftRightUnsigned",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 118516,
            "endOffset": 118978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "rotateLeft",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 119176,
            "endOffset": 119815,
            "count": 0
          }
        ]
      },
      {
        "functionName": "rotateRight",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 119938,
            "endOffset": 120578,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSigned",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120700,
            "endOffset": 120817,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toUnsigned",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120886,
            "endOffset": 121003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toBytes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121071,
            "endOffset": 121154,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toBytesLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121221,
            "endOffset": 121485,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toBytesBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121554,
            "endOffset": 121818,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromBytes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121878,
            "endOffset": 122014,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromBytesLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122076,
            "endOffset": 122306,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromBytesBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122370,
            "endOffset": 122600,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromBigInt",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122705,
            "endOffset": 122932,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromValueWithBigInt",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122995,
            "endOffset": 123173,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toBigInt",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 123253,
            "endOffset": 123461,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/base64-js/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 123596,
            "endOffset": 127557,
            "count": 1
          },
          {
            "startOffset": 123915,
            "endOffset": 123922,
            "count": 0
          },
          {
            "startOffset": 124056,
            "endOffset": 124131,
            "count": 64
          }
        ]
      },
      {
        "functionName": "getLens",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 124238,
            "endOffset": 124600,
            "count": 0
          }
        ]
      },
      {
        "functionName": "byteLength",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 124637,
            "endOffset": 124836,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_byteLength",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 124879,
            "endOffset": 125008,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toByteArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 125053,
            "endOffset": 126149,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tripletToBase64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 126194,
            "endOffset": 126336,
            "count": 0
          }
        ]
      },
      {
        "functionName": "encodeChunk",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 126389,
            "endOffset": 126702,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromByteArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 126747,
            "endOffset": 127509,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/ieee754/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 127639,
            "endOffset": 130100,
            "count": 1
          }
        ]
      },
      {
        "functionName": "exports.read",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 127732,
            "endOffset": 128624,
            "count": 0
          }
        ]
      },
      {
        "functionName": "exports.write",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128646,
            "endOffset": 130095,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/buffer/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 130180,
            "endOffset": 191980,
            "count": 1
          },
          {
            "startOffset": 130490,
            "endOffset": 130496,
            "count": 0
          },
          {
            "startOffset": 130767,
            "endOffset": 130800,
            "count": 0
          },
          {
            "startOffset": 130801,
            "endOffset": 130839,
            "count": 0
          },
          {
            "startOffset": 130841,
            "endOffset": 131030,
            "count": 0
          }
        ]
      },
      {
        "functionName": "typedArraySupport",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 131035,
            "endOffset": 131415,
            "count": 1
          },
          {
            "startOffset": 131368,
            "endOffset": 131409,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 131169,
            "endOffset": 131212,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 131583,
            "endOffset": 131683,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 131815,
            "endOffset": 131919,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createBuffer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 131940,
            "endOffset": 132222,
            "count": 1
          },
          {
            "startOffset": 132005,
            "endOffset": 132103,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Buffer4",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 132269,
            "endOffset": 132639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "from",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 132704,
            "endOffset": 134350,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Buffer4.from",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 134396,
            "endOffset": 134497,
            "count": 0
          }
        ]
      },
      {
        "functionName": "assertSize",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 134619,
            "endOffset": 134885,
            "count": 1
          },
          {
            "startOffset": 134683,
            "endOffset": 134763,
            "count": 0
          },
          {
            "startOffset": 134783,
            "endOffset": 134879,
            "count": 0
          }
        ]
      },
      {
        "functionName": "alloc",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 134928,
            "endOffset": 135251,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Buffer4.alloc",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135300,
            "endOffset": 135380,
            "count": 0
          }
        ]
      },
      {
        "functionName": "allocUnsafe",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 135386,
            "endOffset": 135505,
            "count": 1
          },
          {
            "startOffset": 135474,
            "endOffset": 135477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Buffer4.allocUnsafe",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 135572,
            "endOffset": 135626,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Buffer4.allocUnsafeSlow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135658,
            "endOffset": 135712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromString2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135718,
            "endOffset": 136209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromArrayLike",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 136253,
            "endOffset": 136504,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromArrayView",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 136553,
            "endOffset": 136815,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromArrayBuffer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 136864,
            "endOffset": 137545,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromObject",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 137598,
            "endOffset": 138180,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checked",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 138223,
            "endOffset": 138452,
            "count": 1
          },
          {
            "startOffset": 138284,
            "endOffset": 138421,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SlowBuffer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 138489,
            "endOffset": 138620,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isBuffer2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 138705,
            "endOffset": 138809,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compare2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 138869,
            "endOffset": 139564,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isEncoding",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 139626,
            "endOffset": 140029,
            "count": 0
          }
        ]
      },
      {
        "functionName": "concat",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 140090,
            "endOffset": 141197,
            "count": 0
          }
        ]
      },
      {
        "functionName": "byteLength",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 141214,
            "endOffset": 142564,
            "count": 0
          }
        ]
      },
      {
        "functionName": "slowToString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 142644,
            "endOffset": 143938,
            "count": 0
          }
        ]
      },
      {
        "functionName": "swap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 144025,
            "endOffset": 144112,
            "count": 0
          }
        ]
      },
      {
        "functionName": "swap16",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 144193,
            "endOffset": 144457,
            "count": 0
          }
        ]
      },
      {
        "functionName": "swap32",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 144524,
            "endOffset": 144822,
            "count": 0
          }
        ]
      },
      {
        "functionName": "swap64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 144889,
            "endOffset": 145255,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString3",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 145324,
            "endOffset": 145540,
            "count": 0
          }
        ]
      },
      {
        "functionName": "equals2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 145676,
            "endOffset": 145865,
            "count": 0
          }
        ]
      },
      {
        "functionName": "inspect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 145933,
            "endOffset": 146181,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compare2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 146361,
            "endOffset": 147921,
            "count": 0
          }
        ]
      },
      {
        "functionName": "bidirectionalIndexOf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 147939,
            "endOffset": 149489,
            "count": 0
          }
        ]
      },
      {
        "functionName": "arrayIndexOf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 149552,
            "endOffset": 151182,
            "count": 0
          }
        ]
      },
      {
        "functionName": "includes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 151281,
            "endOffset": 151394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "indexOf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 151464,
            "endOffset": 151589,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lastIndexOf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 151662,
            "endOffset": 151792,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hexWrite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 151814,
            "endOffset": 152447,
            "count": 0
          }
        ]
      },
      {
        "functionName": "utf8Write",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 152486,
            "endOffset": 152629,
            "count": 0
          }
        ]
      },
      {
        "functionName": "asciiWrite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 152670,
            "endOffset": 152794,
            "count": 0
          }
        ]
      },
      {
        "functionName": "base64Write",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 152837,
            "endOffset": 152963,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ucs2Write",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 153008,
            "endOffset": 153154,
            "count": 0
          }
        ]
      },
      {
        "functionName": "write",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 153244,
            "endOffset": 155142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toJSON",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 155208,
            "endOffset": 155344,
            "count": 0
          }
        ]
      },
      {
        "functionName": "base64Slice",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 155361,
            "endOffset": 155578,
            "count": 0
          }
        ]
      },
      {
        "functionName": "utf8Slice",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 155623,
            "endOffset": 157930,
            "count": 0
          }
        ]
      },
      {
        "functionName": "decodeCodePointsArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 158008,
            "endOffset": 158421,
            "count": 0
          }
        ]
      },
      {
        "functionName": "asciiSlice",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 158486,
            "endOffset": 158707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "latin1Slice",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 158750,
            "endOffset": 158966,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hexSlice",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159011,
            "endOffset": 159308,
            "count": 0
          }
        ]
      },
      {
        "functionName": "utf16leSlice",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159347,
            "endOffset": 159603,
            "count": 0
          }
        ]
      },
      {
        "functionName": "slice",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159699,
            "endOffset": 160258,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkOffset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 160274,
            "endOffset": 160505,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUIntLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 160635,
            "endOffset": 161010,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUIntBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 161116,
            "endOffset": 161518,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 161622,
            "endOffset": 161780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt16LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 161889,
            "endOffset": 162074,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt16BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 162186,
            "endOffset": 162371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt32LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 162483,
            "endOffset": 162725,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt32BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 162837,
            "endOffset": 163079,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readBigUInt64LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 163180,
            "endOffset": 163724,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readBigUInt64BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 163829,
            "endOffset": 164373,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readIntLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 164453,
            "endOffset": 164904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readIntBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 164977,
            "endOffset": 165434,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165506,
            "endOffset": 165734,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt16LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165808,
            "endOffset": 166048,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt16BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 166125,
            "endOffset": 166365,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt32LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 166442,
            "endOffset": 166676,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt32BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 166753,
            "endOffset": 166987,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readBigInt64LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 167086,
            "endOffset": 167614,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readBigInt64BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 167717,
            "endOffset": 168257,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readFloatLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 168338,
            "endOffset": 168525,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readFloatBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 168602,
            "endOffset": 168790,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readDoubleLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 168868,
            "endOffset": 169056,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readDoubleBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169135,
            "endOffset": 169324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkInt",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169347,
            "endOffset": 169687,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUIntLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169813,
            "endOffset": 170333,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUIntBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 170442,
            "endOffset": 170971,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 171078,
            "endOffset": 171303,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt16LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 171415,
            "endOffset": 171683,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt16BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 171798,
            "endOffset": 172066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt32LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 172181,
            "endOffset": 172532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt32BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 172647,
            "endOffset": 172998,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrtBigUInt64LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 173022,
            "endOffset": 173599,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrtBigUInt64BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 173650,
            "endOffset": 174243,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeBigUInt64LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 174373,
            "endOffset": 174516,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeBigUInt64BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 174623,
            "endOffset": 174766,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeIntLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 174848,
            "endOffset": 175460,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeIntBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 175535,
            "endOffset": 176156,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 176230,
            "endOffset": 176503,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt16LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 176579,
            "endOffset": 176851,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt16BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 176930,
            "endOffset": 177202,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt32LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 177281,
            "endOffset": 177641,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt32BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 177720,
            "endOffset": 178133,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeBigInt64LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178234,
            "endOffset": 178396,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeBigInt64BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178501,
            "endOffset": 178663,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkIEEE754",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178690,
            "endOffset": 178901,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeFloat",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178948,
            "endOffset": 179278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeFloatLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 179377,
            "endOffset": 179493,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeFloatBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 179572,
            "endOffset": 179689,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeDouble",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 179712,
            "endOffset": 180045,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeDoubleLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 180147,
            "endOffset": 180265,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeDoubleBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 180346,
            "endOffset": 180465,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 180537,
            "endOffset": 181761,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fill",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 181824,
            "endOffset": 183565,
            "count": 0
          }
        ]
      },
      {
        "functionName": "E",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 183601,
            "endOffset": 184443,
            "count": 3
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 183696,
            "endOffset": 183751,
            "count": 3
          }
        ]
      },
      {
        "functionName": "NodeError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 183760,
            "endOffset": 184079,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get code",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 184088,
            "endOffset": 184132,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set code",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 184141,
            "endOffset": 184338,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 184347,
            "endOffset": 184428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 184511,
            "endOffset": 184686,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 184755,
            "endOffset": 184883,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 184947,
            "endOffset": 185558,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addNumericalSeparator",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 185588,
            "endOffset": 185856,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkBounds",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 185921,
            "endOffset": 186160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkIntBI",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 186205,
            "endOffset": 186888,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateNumber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 186931,
            "endOffset": 187092,
            "count": 0
          }
        ]
      },
      {
        "functionName": "boundsError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187143,
            "endOffset": 187582,
            "count": 0
          }
        ]
      },
      {
        "functionName": "base64clean",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187676,
            "endOffset": 187920,
            "count": 0
          }
        ]
      },
      {
        "functionName": "utf8ToBytes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187965,
            "endOffset": 189924,
            "count": 0
          }
        ]
      },
      {
        "functionName": "asciiToBytes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 189969,
            "endOffset": 190157,
            "count": 0
          }
        ]
      },
      {
        "functionName": "utf16leToBytes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 190204,
            "endOffset": 190540,
            "count": 0
          }
        ]
      },
      {
        "functionName": "base64ToBytes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 190591,
            "endOffset": 190677,
            "count": 0
          }
        ]
      },
      {
        "functionName": "blitBuffer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 190726,
            "endOffset": 190951,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 190994,
            "endOffset": 191178,
            "count": 0
          }
        ]
      },
      {
        "functionName": "numberIsNaN",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 191221,
            "endOffset": 191280,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 191352,
            "endOffset": 191645,
            "count": 1
          },
          {
            "startOffset": 191479,
            "endOffset": 191619,
            "count": 16
          },
          {
            "startOffset": 191546,
            "endOffset": 191611,
            "count": 256
          }
        ]
      },
      {
        "functionName": "defineBigIntMethod",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 191654,
            "endOffset": 191767,
            "count": 8
          },
          {
            "startOffset": 191731,
            "endOffset": 191755,
            "count": 0
          }
        ]
      },
      {
        "functionName": "BufferBigIntNotDefined",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 191826,
            "endOffset": 191914,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../smartbuffer/dist/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 192117,
            "endOffset": 262354,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 192357,
            "endOffset": 192420,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 192479,
            "endOffset": 192514,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 192579,
            "endOffset": 193053,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_SmartBuffer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 193060,
            "endOffset": 193630,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get length",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 193637,
            "endOffset": 193703,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get capacity",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 193710,
            "endOffset": 193769,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readBitSet",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 193776,
            "endOffset": 194752,
            "count": 0
          }
        ]
      },
      {
        "functionName": "read",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 194759,
            "endOffset": 195405,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 195412,
            "endOffset": 195639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 195646,
            "endOffset": 195762,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt16LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 195769,
            "endOffset": 196072,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt16BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 196079,
            "endOffset": 196382,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt16LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 196389,
            "endOffset": 196602,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt16BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 196609,
            "endOffset": 196822,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt24BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 196829,
            "endOffset": 197111,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt32LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 197118,
            "endOffset": 197454,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt32BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 197461,
            "endOffset": 197797,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt32LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 197804,
            "endOffset": 198121,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt32BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 198128,
            "endOffset": 198445,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt64LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 198452,
            "endOffset": 198981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readInt64BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 198988,
            "endOffset": 199517,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt64LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 199524,
            "endOffset": 200053,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUInt64BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 200060,
            "endOffset": 200589,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readBigIntBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 200596,
            "endOffset": 201116,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUBigIntBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 201123,
            "endOffset": 201573,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readBigIntLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 201580,
            "endOffset": 202106,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readUBigIntLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202113,
            "endOffset": 202563,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readFloatLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202570,
            "endOffset": 202700,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readFloatBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202707,
            "endOffset": 202837,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readDoubleLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202844,
            "endOffset": 202976,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readDoubleBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202983,
            "endOffset": 203115,
            "count": 0
          }
        ]
      },
      {
        "functionName": "write",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 203122,
            "endOffset": 204582,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeBitSet",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 204589,
            "endOffset": 205969,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeBuffer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 205976,
            "endOffset": 206538,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206545,
            "endOffset": 206734,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206741,
            "endOffset": 206933,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt16LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206940,
            "endOffset": 207181,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt16BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 207188,
            "endOffset": 207429,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt16LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 207436,
            "endOffset": 207680,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt16BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 207687,
            "endOffset": 207931,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt24BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 207938,
            "endOffset": 208232,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt32LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 208239,
            "endOffset": 208580,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt32BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 208587,
            "endOffset": 208928,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt32LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 208935,
            "endOffset": 209268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt32BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 209275,
            "endOffset": 209608,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt64LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 209615,
            "endOffset": 210155,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeInt64BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 210162,
            "endOffset": 210702,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt64LE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 210709,
            "endOffset": 211250,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUInt64BE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 211257,
            "endOffset": 211798,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeBigIntBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 211805,
            "endOffset": 212668,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUBigIntBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 212675,
            "endOffset": 213423,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeBigIntLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 213430,
            "endOffset": 214237,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeUBigIntLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 214244,
            "endOffset": 214936,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeFloatLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 214943,
            "endOffset": 215117,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeFloatBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215124,
            "endOffset": 215298,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeDoubleLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215305,
            "endOffset": 215481,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeDoubleBE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215488,
            "endOffset": 215664,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_checkRead",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215671,
            "endOffset": 216238,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_checkWrite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 216245,
            "endOffset": 217216,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_checkWriteLong",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 217223,
            "endOffset": 218566,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeVarint32",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218573,
            "endOffset": 219839,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeVarint32ZigZag",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219846,
            "endOffset": 219969,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readVarint32",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219976,
            "endOffset": 221124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readVarint32ZigZag",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 221131,
            "endOffset": 221410,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeVarint64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 221417,
            "endOffset": 224177,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeVarint64ZigZag",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 224184,
            "endOffset": 224307,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readVarint64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 224314,
            "endOffset": 226904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readVarint64ZigZag",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 226911,
            "endOffset": 227227,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeCString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 227234,
            "endOffset": 228557,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readCString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 228564,
            "endOffset": 229567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 229574,
            "endOffset": 230547,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 230554,
            "endOffset": 233518,
            "count": 0
          }
        ]
      },
      {
        "functionName": "writeVString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 233525,
            "endOffset": 234724,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readVString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 234731,
            "endOffset": 235584,
            "count": 0
          }
        ]
      },
      {
        "functionName": "appendTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 235591,
            "endOffset": 235682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "assert",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 235689,
            "endOffset": 235767,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 235774,
            "endOffset": 235924,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clone",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 235931,
            "endOffset": 236331,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compact",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 236338,
            "endOffset": 237553,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 237560,
            "endOffset": 238564,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 238571,
            "endOffset": 239851,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ensureCapacity",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 239858,
            "endOffset": 240077,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fill",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 240084,
            "endOffset": 241274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prepend",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 241281,
            "endOffset": 242604,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prependTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242611,
            "endOffset": 242705,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242712,
            "endOffset": 243295,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reverse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 243302,
            "endOffset": 244160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "skipRead",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 244167,
            "endOffset": 244731,
            "count": 0
          }
        ]
      },
      {
        "functionName": "skipWrite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 244738,
            "endOffset": 245303,
            "count": 0
          }
        ]
      },
      {
        "functionName": "slice",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 245310,
            "endOffset": 246166,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toBuffer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 246173,
            "endOffset": 247224,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toArrayBuffer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247231,
            "endOffset": 248022,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 248029,
            "endOffset": 248681,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toBase64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 248688,
            "endOffset": 249065,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toBinary",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 249072,
            "endOffset": 249444,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toDebug",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 249451,
            "endOffset": 251228,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toHex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 251235,
            "endOffset": 251993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toUTF8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 252000,
            "endOffset": 252760,
            "count": 0
          }
        ]
      },
      {
        "functionName": "alloc",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 252774,
            "endOffset": 252894,
            "count": 0
          }
        ]
      },
      {
        "functionName": "concat",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 252908,
            "endOffset": 253882,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 253896,
            "endOffset": 255371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calculateVarint32",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 255385,
            "endOffset": 255700,
            "count": 0
          }
        ]
      },
      {
        "functionName": "zigZagEncode32",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 255714,
            "endOffset": 255789,
            "count": 0
          }
        ]
      },
      {
        "functionName": "zigZagDecode32",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 255803,
            "endOffset": 255869,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calculateVarint64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 255883,
            "endOffset": 256708,
            "count": 0
          }
        ]
      },
      {
        "functionName": "zigZagEncode64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 256722,
            "endOffset": 257169,
            "count": 0
          }
        ]
      },
      {
        "functionName": "zigZagDecode64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 257183,
            "endOffset": 257663,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calculateUTF8Chars",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 257677,
            "endOffset": 257742,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calculateString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 257756,
            "endOffset": 257954,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromBase64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 257968,
            "endOffset": 258069,
            "count": 0
          }
        ]
      },
      {
        "functionName": "btoa",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 258083,
            "endOffset": 258158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "atob",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 258172,
            "endOffset": 258247,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromBinary",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 258261,
            "endOffset": 258362,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromDebug",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 258376,
            "endOffset": 261445,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromHex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261459,
            "endOffset": 261954,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromUTF8",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261968,
            "endOffset": 262343,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../messagepack/dist/encoder.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 262489,
            "endOffset": 268627,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 262692,
            "endOffset": 263074,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 263130,
            "endOffset": 263593,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 263654,
            "endOffset": 264398,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 264445,
            "endOffset": 264494,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Encoder",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 264501,
            "endOffset": 264581,
            "count": 2
          }
        ]
      },
      {
        "functionName": "encode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 264588,
            "endOffset": 264712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_encode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 264719,
            "endOffset": 268616,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../messagepack/dist/decoder.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 268754,
            "endOffset": 278832,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 268889,
            "endOffset": 269928,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 269989,
            "endOffset": 270057,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270126,
            "endOffset": 270205,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 270255,
            "endOffset": 270304,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Decoder",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 270311,
            "endOffset": 270391,
            "count": 2
          }
        ]
      },
      {
        "functionName": "decode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270398,
            "endOffset": 270666,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tryDecode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270673,
            "endOffset": 276903,
            "count": 0
          }
        ]
      },
      {
        "functionName": "decodeMap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 276910,
            "endOffset": 277617,
            "count": 0
          }
        ]
      },
      {
        "functionName": "decodeArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 277624,
            "endOffset": 278110,
            "count": 0
          }
        ]
      },
      {
        "functionName": "decodeFixExt",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 278117,
            "endOffset": 278239,
            "count": 0
          }
        ]
      },
      {
        "functionName": "decodeExt",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 278246,
            "endOffset": 278821,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../messagepack/dist/serializer.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 278923,
            "endOffset": 280327,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 279095,
            "endOffset": 279147,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Serializer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 279154,
            "endOffset": 279469,
            "count": 2
          }
        ]
      },
      {
        "functionName": "registerEncoder",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 279476,
            "endOffset": 279600,
            "count": 16
          }
        ]
      },
      {
        "functionName": "registerDecoder",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 279607,
            "endOffset": 279713,
            "count": 16
          }
        ]
      },
      {
        "functionName": "register",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 279720,
            "endOffset": 280172,
            "count": 16
          },
          {
            "startOffset": 279802,
            "endOffset": 279878,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 279914,
            "endOffset": 279949,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 279951,
            "endOffset": 280097,
            "count": 0
          }
        ]
      },
      {
        "functionName": "encode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 280179,
            "endOffset": 280247,
            "count": 0
          }
        ]
      },
      {
        "functionName": "decode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 280254,
            "endOffset": 280316,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../messagepack/dist/errors.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 280477,
            "endOffset": 281404,
            "count": 1
          },
          {
            "startOffset": 280877,
            "endOffset": 281094,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 280823,
            "endOffset": 280832,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 281136,
            "endOffset": 281257,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 281318,
            "endOffset": 281381,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../messagepack/dist/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 281509,
            "endOffset": 284699,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 281698,
            "endOffset": 284592,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 281736,
            "endOffset": 282205,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 282207,
            "endOffset": 282704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 282735,
            "endOffset": 282800,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 282802,
            "endOffset": 282850,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 282880,
            "endOffset": 283060,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 283062,
            "endOffset": 283342,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 283372,
            "endOffset": 283514,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 283516,
            "endOffset": 283754,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 283787,
            "endOffset": 283879,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 283881,
            "endOffset": 284016,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 284049,
            "endOffset": 284136,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 284138,
            "endOffset": 284219,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 284258,
            "endOffset": 284448,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 284450,
            "endOffset": 284584,
            "count": 0
          }
        ]
      },
      {
        "functionName": "src/netron/definition.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 284781,
            "endOffset": 286730,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Definition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 285669,
            "endOffset": 285786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 285793,
            "endOffset": 285845,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 286122,
            "endOffset": 286135,
            "count": 0
          }
        ]
      },
      {
        "functionName": "nextId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 286672,
            "endOffset": 286719,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ensureStreamReferenceRegistered",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 286771,
            "endOffset": 288545,
            "count": 0
          }
        ]
      },
      {
        "functionName": "src/netron/packet/serializer.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 288677,
            "endOffset": 291743,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 289334,
            "endOffset": 289533,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 289921,
            "endOffset": 290234,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 290630,
            "endOffset": 290697,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 291018,
            "endOffset": 291065,
            "count": 0
          }
        ]
      },
      {
        "functionName": "serializer2.encode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 291368,
            "endOffset": 291650,
            "count": 0
          }
        ]
      },
      {
        "functionName": "serializer2.decode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 291677,
            "endOffset": 291738,
            "count": 0
          }
        ]
      },
      {
        "functionName": "src/netron/packet/index.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 291826,
            "endOffset": 292249,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 292041,
            "endOffset": 292227,
            "count": 0
          }
        ]
      },
      {
        "functionName": "src/netron/writable-stream.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 292357,
            "endOffset": 300193,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 292593,
            "endOffset": 292655,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 292718,
            "endOffset": 299361,
            "count": 0
          }
        ]
      },
      {
        "functionName": "create",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 299958,
            "endOffset": 300182,
            "count": 0
          }
        ]
      },
      {
        "functionName": "StreamReference",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 300324,
            "endOffset": 300345,
            "count": 0
          }
        ]
      },
      {
        "functionName": "src/netron/stream-reference.ts",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 300409,
            "endOffset": 302683,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_StreamReference",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 300978,
            "endOffset": 301151,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 301158,
            "endOffset": 301215,
            "count": 1
          }
        ]
      },
      {
        "functionName": "from",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 301628,
            "endOffset": 301845,
            "count": 0
          }
        ]
      },
      {
        "functionName": "to",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 302419,
            "endOffset": 302672,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 303069,
            "endOffset": 303115,
            "count": 1
          }
        ]
      },
      {
        "functionName": "EventEmitter",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 303118,
            "endOffset": 303366,
            "count": 1
          },
          {
            "startOffset": 303294,
            "endOffset": 303313,
            "count": 0
          },
          {
            "startOffset": 303315,
            "endOffset": 303362,
            "count": 0
          }
        ]
      },
      {
        "functionName": "eventNames",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 303369,
            "endOffset": 303431,
            "count": 0
          }
        ]
      },
      {
        "functionName": "listeners",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 303434,
            "endOffset": 303646,
            "count": 0
          }
        ]
      },
      {
        "functionName": "listenerCount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 303649,
            "endOffset": 303834,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emit",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 303837,
            "endOffset": 304484,
            "count": 2
          },
          {
            "startOffset": 303944,
            "endOffset": 304483,
            "count": 0
          }
        ]
      },
      {
        "functionName": "on",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 304487,
            "endOffset": 304571,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 304574,
            "endOffset": 305125,
            "count": 0
          }
        ]
      },
      {
        "functionName": "once",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 305128,
            "endOffset": 305636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 305639,
            "endOffset": 306405,
            "count": 0
          }
        ]
      },
      {
        "functionName": "off",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 306408,
            "endOffset": 306471,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeAllListeners",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 306474,
            "endOffset": 306725,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setConcurrency",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 306728,
            "endOffset": 306854,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emitParallel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 306857,
            "endOffset": 307026,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emitSerial",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 307029,
            "endOffset": 307283,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emitReduce",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 307286,
            "endOffset": 307363,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emitReduceRight",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 307366,
            "endOffset": 307454,
            "count": 0
          }
        ]
      },
      {
        "functionName": "subscribe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 307457,
            "endOffset": 307750,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_emitReduceRun",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 307753,
            "endOffset": 308138,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_executeListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 308141,
            "endOffset": 308386,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 308896,
            "endOffset": 309320,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 309381,
            "endOffset": 309425,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 309428,
            "endOffset": 309443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "TitanError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 309447,
            "endOffset": 309834,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isHttpResponseMessage",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 309898,
            "endOffset": 310205,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateRequestId",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 310262,
            "endOffset": 310367,
            "count": 3
          }
        ]
      },
      {
        "functionName": "createRequestMessage",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 310416,
            "endOffset": 310682,
            "count": 3
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 310833,
            "endOffset": 310881,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 310884,
            "endOffset": 311175,
            "count": 1
          }
        ]
      },
      {
        "functionName": "get state",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 311179,
            "endOffset": 311220,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get remoteAddress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 311223,
            "endOffset": 311273,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get localAddress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 311276,
            "endOffset": 311319,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HttpConnection",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 311322,
            "endOffset": 311545,
            "count": 1
          },
          {
            "startOffset": 311441,
            "endOffset": 311463,
            "count": 0
          },
          {
            "startOffset": 311502,
            "endOffset": 311507,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initializeConnection",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 311591,
            "endOffset": 311858,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 311686,
            "endOffset": 311852,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 311758,
            "endOffset": 311844,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateId",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 311908,
            "endOffset": 312012,
            "count": 1
          }
        ]
      },
      {
        "functionName": "discoverServices",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 312071,
            "endOffset": 312264,
            "count": 1
          },
          {
            "startOffset": 312129,
            "endOffset": 312172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_discoverServices",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 312267,
            "endOffset": 313555,
            "count": 1
          },
          {
            "startOffset": 313402,
            "endOffset": 313459,
            "count": 0
          },
          {
            "startOffset": 313474,
            "endOffset": 313551,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 312382,
            "endOffset": 312490,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 312418,
            "endOffset": 312462,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 312967,
            "endOffset": 313077,
            "count": 8
          }
        ]
      },
      {
        "functionName": "send",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 313613,
            "endOffset": 314282,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sendPacket",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 314440,
            "endOffset": 315182,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sendRequestMessage",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 315228,
            "endOffset": 315586,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sendHttpRequest",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 315624,
            "endOffset": 317230,
            "count": 1
          },
          {
            "startOffset": 316180,
            "endOffset": 316202,
            "count": 0
          },
          {
            "startOffset": 316322,
            "endOffset": 316907,
            "count": 0
          },
          {
            "startOffset": 316950,
            "endOffset": 317226,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 316014,
            "endOffset": 316064,
            "count": 0
          }
        ]
      },
      {
        "functionName": "close",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 317271,
            "endOffset": 317744,
            "count": 2
          },
          {
            "startOffset": 317358,
            "endOffset": 317561,
            "count": 1
          },
          {
            "startOffset": 317561,
            "endOffset": 317659,
            "count": 0
          },
          {
            "startOffset": 317659,
            "endOffset": 317743,
            "count": 1
          }
        ]
      },
      {
        "functionName": "reconnect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 317814,
            "endOffset": 318056,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isAlive",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 318105,
            "endOffset": 318176,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getMetrics",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 318219,
            "endOffset": 318430,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryInterface",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 318493,
            "endOffset": 319149,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createServiceProxy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 319190,
            "endOffset": 320046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 320184,
            "endOffset": 320230,
            "count": 1
          }
        ]
      },
      {
        "functionName": "EventEmitter2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 320233,
            "endOffset": 320297,
            "count": 1
          }
        ]
      },
      {
        "functionName": "on",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 320300,
            "endOffset": 320460,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emit",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 320463,
            "endOffset": 320676,
            "count": 1
          },
          {
            "startOffset": 320551,
            "endOffset": 320654,
            "count": 0
          }
        ]
      },
      {
        "functionName": "off",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 320679,
            "endOffset": 320914,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 320917,
            "endOffset": 320992,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321336,
            "endOffset": 321419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321664,
            "endOffset": 321824,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_Interface",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 322673,
            "endOffset": 326280,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 326283,
            "endOffset": 326326,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 326630,
            "endOffset": 326674,
            "count": 0
          }
        ]
      },
      {
        "functionName": "waitForAssigned",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 327133,
            "endOffset": 327395,
            "count": 0
          }
        ]
      },
      {
        "functionName": "$processValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 327893,
            "endOffset": 328361,
            "count": 0
          }
        ]
      },
      {
        "functionName": "$processArgs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 328721,
            "endOffset": 328800,
            "count": 0
          }
        ]
      },
      {
        "functionName": "create",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 329176,
            "endOffset": 329237,
            "count": 0
          }
        ]
      },
      {
        "functionName": "AbstractPeer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 329494,
            "endOffset": 329567,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 329570,
            "endOffset": 329616,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 329871,
            "endOffset": 330214,
            "count": 1
          }
        ]
      },
      {
        "functionName": "unexposeAllServices",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 330342,
            "endOffset": 330460,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryInterface",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 331042,
            "endOffset": 332133,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryInterfaceByDefId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 332484,
            "endOffset": 332869,
            "count": 0
          }
        ]
      },
      {
        "functionName": "releaseInterface",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 333316,
            "endOffset": 334098,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findLatestServiceVersion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 335067,
            "endOffset": 335756,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidateDefinitionCache",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 336545,
            "endOffset": 337084,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearDefinitionCache",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 337289,
            "endOffset": 337414,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesPattern",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 337731,
            "endOffset": 338073,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HttpInterface",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 338228,
            "endOffset": 339309,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 339312,
            "endOffset": 339359,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 339458,
            "endOffset": 339562,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_QueryBuilder",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 339749,
            "endOffset": 340009,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 340012,
            "endOffset": 340353,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 340061,
            "endOffset": 340121,
            "count": 0
          }
        ]
      },
      {
        "functionName": "method",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340397,
            "endOffset": 340460,
            "count": 0
          }
        ]
      },
      {
        "functionName": "input",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340509,
            "endOffset": 340572,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cache",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340610,
            "endOffset": 340789,
            "count": 0
          }
        ]
      },
      {
        "functionName": "retry",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340834,
            "endOffset": 341015,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidateOn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341063,
            "endOffset": 341144,
            "count": 0
          }
        ]
      },
      {
        "functionName": "optimistic",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341193,
            "endOffset": 341280,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dedupe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341322,
            "endOffset": 341390,
            "count": 0
          }
        ]
      },
      {
        "functionName": "background",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341439,
            "endOffset": 341529,
            "count": 0
          }
        ]
      },
      {
        "functionName": "timeout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341569,
            "endOffset": 341634,
            "count": 0
          }
        ]
      },
      {
        "functionName": "priority",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341675,
            "endOffset": 341748,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341792,
            "endOffset": 341861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341904,
            "endOffset": 341971,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342009,
            "endOffset": 342080,
            "count": 0
          }
        ]
      },
      {
        "functionName": "metrics",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342114,
            "endOffset": 342179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342236,
            "endOffset": 342284,
            "count": 0
          }
        ]
      },
      {
        "functionName": "execute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342322,
            "endOffset": 342992,
            "count": 0
          }
        ]
      },
      {
        "functionName": "executeInternal",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 343037,
            "endOffset": 346284,
            "count": 0
          }
        ]
      },
      {
        "functionName": "executeRequest",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 346331,
            "endOffset": 347199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCacheKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347238,
            "endOffset": 347440,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setupBackgroundRefetch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347494,
            "endOffset": 348235,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stopBackgroundRefetch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348304,
            "endOffset": 348537,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stopAllBackgroundRefetch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348659,
            "endOffset": 348848,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getActiveBackgroundRefetchCount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348935,
            "endOffset": 349025,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ConfigurableProxy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 349184,
            "endOffset": 350326,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 350329,
            "endOffset": 350380,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 350383,
            "endOffset": 350415,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cache",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 350462,
            "endOffset": 350602,
            "count": 0
          }
        ]
      },
      {
        "functionName": "retry",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 350648,
            "endOffset": 350790,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dedupe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 350834,
            "endOffset": 350919,
            "count": 0
          }
        ]
      },
      {
        "functionName": "timeout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 350953,
            "endOffset": 351035,
            "count": 0
          }
        ]
      },
      {
        "functionName": "priority",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351070,
            "endOffset": 351160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351196,
            "endOffset": 351282,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351317,
            "endOffset": 351401,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351436,
            "endOffset": 351524,
            "count": 0
          }
        ]
      },
      {
        "functionName": "optimistic",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351569,
            "endOffset": 351673,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidateOn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351723,
            "endOffset": 351821,
            "count": 0
          }
        ]
      },
      {
        "functionName": "background",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351866,
            "endOffset": 351973,
            "count": 0
          }
        ]
      },
      {
        "functionName": "metrics",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 352016,
            "endOffset": 352098,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 352162,
            "endOffset": 352986,
            "count": 0
          }
        ]
      },
      {
        "functionName": "FluentInterface",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 353072,
            "endOffset": 353370,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 353373,
            "endOffset": 353422,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 353512,
            "endOffset": 353607,
            "count": 0
          }
        ]
      },
      {
        "functionName": "globalCache",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 353731,
            "endOffset": 353882,
            "count": 0
          }
        ]
      },
      {
        "functionName": "globalRetry",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 354005,
            "endOffset": 354156,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cache",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 354271,
            "endOffset": 354563,
            "count": 0
          }
        ]
      },
      {
        "functionName": "retry",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 354685,
            "endOffset": 354977,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dedupe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 355097,
            "endOffset": 355339,
            "count": 0
          }
        ]
      },
      {
        "functionName": "timeout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 355439,
            "endOffset": 355678,
            "count": 0
          }
        ]
      },
      {
        "functionName": "priority",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 355774,
            "endOffset": 356021,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 356121,
            "endOffset": 356364,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 356464,
            "endOffset": 356705,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 356807,
            "endOffset": 357052,
            "count": 0
          }
        ]
      },
      {
        "functionName": "optimistic",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 357157,
            "endOffset": 357418,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidateOn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 357521,
            "endOffset": 357776,
            "count": 0
          }
        ]
      },
      {
        "functionName": "background",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 357890,
            "endOffset": 358154,
            "count": 0
          }
        ]
      },
      {
        "functionName": "metrics",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 358249,
            "endOffset": 358488,
            "count": 0
          }
        ]
      },
      {
        "functionName": "call",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 358668,
            "endOffset": 359038,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get api",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 359151,
            "endOffset": 359203,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createDirectProxy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 359284,
            "endOffset": 359664,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 359707,
            "endOffset": 359912,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearCache",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 359948,
            "endOffset": 359998,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalizeCacheOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 360021,
            "endOffset": 360129,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalizeRetryOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 360132,
            "endOffset": 360242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyGlobalOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 360245,
            "endOffset": 361075,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 361169,
            "endOffset": 361217,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 361220,
            "endOffset": 361965,
            "count": 1
          }
        ]
      },
      {
        "functionName": "HttpRemotePeer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 361969,
            "endOffset": 362412,
            "count": 1
          },
          {
            "startOffset": 362174,
            "endOffset": 362196,
            "count": 0
          }
        ]
      },
      {
        "functionName": "init",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 362620,
            "endOffset": 363081,
            "count": 1
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363141,
            "endOffset": 363466,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363528,
            "endOffset": 363865,
            "count": 0
          }
        ]
      },
      {
        "functionName": "call",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363918,
            "endOffset": 364545,
            "count": 0
          }
        ]
      },
      {
        "functionName": "subscribe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 364614,
            "endOffset": 364767,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unsubscribe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 364811,
            "endOffset": 364856,
            "count": 0
          }
        ]
      },
      {
        "functionName": "exposeService",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 364925,
            "endOffset": 365033,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unexposeService",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 365104,
            "endOffset": 365159,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getServiceNames",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 365197,
            "endOffset": 365262,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidateDefinitionCache",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 365357,
            "endOffset": 366237,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchServicePattern",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 366309,
            "endOffset": 366628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "executeTask",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 366682,
            "endOffset": 366963,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sendRequestMessage",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 367009,
            "endOffset": 367524,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sendHttpRequest",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 367562,
            "endOffset": 369142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createServiceProxy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369232,
            "endOffset": 370009,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildRequestContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 370051,
            "endOffset": 370145,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildRequestHints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 370185,
            "endOffset": 370293,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleCacheHints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 370346,
            "endOffset": 370494,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getServiceNameFromDefId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 370550,
            "endOffset": 370774,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createErrorFromResponse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 370821,
            "endOffset": 371206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addRequestInterceptor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 371250,
            "endOffset": 371338,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addResponseInterceptor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 371383,
            "endOffset": 371473,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emit",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 371532,
            "endOffset": 371603,
            "count": 1
          }
        ]
      },
      {
        "functionName": "close",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 371649,
            "endOffset": 371962,
            "count": 1
          }
        ]
      },
      {
        "functionName": "get isConnected",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 372009,
            "endOffset": 372049,
            "count": 0
          }
        ]
      },
      {
        "functionName": "releaseInterfaceInternal",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 372096,
            "endOffset": 372144,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDefinitionById",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 372185,
            "endOffset": 372354,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDefinitionByServiceName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 372405,
            "endOffset": 372574,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryInterfaceRemote",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 372977,
            "endOffset": 374287,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryInterface",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 375177,
            "endOffset": 375574,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryFluentInterface",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 376419,
            "endOffset": 376926,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getOrCreateHttpClient",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 376996,
            "endOffset": 377075,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setCacheManager",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 377506,
            "endOffset": 377586,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setRetryManager",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 378007,
            "endOffset": 378087,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setGlobalOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 378551,
            "endOffset": 378633,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCacheManager",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 378680,
            "endOffset": 378733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getRetryManager",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 378780,
            "endOffset": 378833,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getGlobalOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 378878,
            "endOffset": 378933,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HttpTransportClient",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 379013,
            "endOffset": 379213,
            "count": 1
          },
          {
            "startOffset": 379176,
            "endOffset": 379198,
            "count": 0
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 379216,
            "endOffset": 379269,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 379272,
            "endOffset": 379290,
            "count": 1
          }
        ]
      },
      {
        "functionName": "initialize",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 379333,
            "endOffset": 379644,
            "count": 4
          },
          {
            "startOffset": 379380,
            "endOffset": 379640,
            "count": 1
          }
        ]
      },
      {
        "functionName": "invoke",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 379688,
            "endOffset": 380095,
            "count": 3
          },
          {
            "startOffset": 379852,
            "endOffset": 379861,
            "count": 0
          },
          {
            "startOffset": 379883,
            "endOffset": 379890,
            "count": 0
          },
          {
            "startOffset": 379980,
            "endOffset": 380065,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sendRequest",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 380133,
            "endOffset": 381852,
            "count": 3
          },
          {
            "startOffset": 380244,
            "endOffset": 380253,
            "count": 0
          },
          {
            "startOffset": 380804,
            "endOffset": 381227,
            "count": 0
          },
          {
            "startOffset": 381270,
            "endOffset": 381848,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 380366,
            "endOffset": 380390,
            "count": 0
          }
        ]
      },
      {
        "functionName": "close",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 381900,
            "endOffset": 382047,
            "count": 1
          }
        ]
      },
      {
        "functionName": "getMetrics",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 382090,
            "endOffset": 382352,
            "count": 1
          },
          {
            "startOffset": 382211,
            "endOffset": 382223,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SimpleWsClient",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 382453,
            "endOffset": 382507,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 382510,
            "endOffset": 382558,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 382561,
            "endOffset": 382726,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 382775,
            "endOffset": 384024,
            "count": 1
          },
          {
            "startOffset": 382817,
            "endOffset": 382824,
            "count": 0
          },
          {
            "startOffset": 382850,
            "endOffset": 383226,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connecting",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 382877,
            "endOffset": 383218,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 383278,
            "endOffset": 384018,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 383394,
            "endOffset": 383732,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 383790,
            "endOffset": 383901,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setupListeners",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 384076,
            "endOffset": 384883,
            "count": 1
          },
          {
            "startOffset": 384113,
            "endOffset": 384120,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 384161,
            "endOffset": 384376,
            "count": 2
          },
          {
            "startOffset": 384279,
            "endOffset": 384370,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 384417,
            "endOffset": 384770,
            "count": 1
          },
          {
            "startOffset": 384549,
            "endOffset": 384690,
            "count": 0
          },
          {
            "startOffset": 384723,
            "endOffset": 384764,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 384811,
            "endOffset": 384877,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleMessage",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 384927,
            "endOffset": 385574,
            "count": 2
          },
          {
            "startOffset": 385208,
            "endOffset": 385570,
            "count": 0
          }
        ]
      },
      {
        "functionName": "call",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 385613,
            "endOffset": 386325,
            "count": 2
          },
          {
            "startOffset": 385677,
            "endOffset": 385734,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 385856,
            "endOffset": 386319,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 385918,
            "endOffset": 386036,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleReconnect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 386365,
            "endOffset": 386928,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isConnected",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 386967,
            "endOffset": 387055,
            "count": 2
          }
        ]
      },
      {
        "functionName": "close",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 387092,
            "endOffset": 387245,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_BrowserLogger",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 387340,
            "endOffset": 387399,
            "count": 3
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 387402,
            "endOffset": 387449,
            "count": 1
          }
        ]
      },
      {
        "functionName": "formatMessage",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 387547,
            "endOffset": 387690,
            "count": 17
          },
          {
            "startOffset": 387606,
            "endOffset": 387633,
            "count": 8
          },
          {
            "startOffset": 387633,
            "endOffset": 387650,
            "count": 9
          },
          {
            "startOffset": 387650,
            "endOffset": 387655,
            "count": 0
          }
        ]
      },
      {
        "functionName": "debug",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 387693,
            "endOffset": 387897,
            "count": 11
          },
          {
            "startOffset": 387783,
            "endOffset": 387838,
            "count": 7
          },
          {
            "startOffset": 387838,
            "endOffset": 387893,
            "count": 4
          }
        ]
      },
      {
        "functionName": "info",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 387900,
            "endOffset": 388101,
            "count": 6
          },
          {
            "startOffset": 387989,
            "endOffset": 388043,
            "count": 2
          },
          {
            "startOffset": 388043,
            "endOffset": 388097,
            "count": 4
          }
        ]
      },
      {
        "functionName": "warn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 388104,
            "endOffset": 388305,
            "count": 0
          }
        ]
      },
      {
        "functionName": "error",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 388308,
            "endOffset": 388512,
            "count": 0
          }
        ]
      },
      {
        "functionName": "child",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 388627,
            "endOffset": 388711,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Netron",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 388763,
            "endOffset": 388976,
            "count": 2
          }
        ]
      },
      {
        "functionName": "<static_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 388979,
            "endOffset": 389019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "<instance_members_initializer>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 389022,
            "endOffset": 389228,
            "count": 2
          }
        ]
      },
      {
        "functionName": "connect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 389348,
            "endOffset": 389504,
            "count": 2
          },
          {
            "startOffset": 389409,
            "endOffset": 389500,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryInterface",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 389904,
            "endOffset": 392356,
            "count": 2
          },
          {
            "startOffset": 389977,
            "endOffset": 391247,
            "count": 1
          },
          {
            "startOffset": 390007,
            "endOffset": 390081,
            "count": 0
          },
          {
            "startOffset": 391247,
            "endOffset": 392352,
            "count": 1
          },
          {
            "startOffset": 391281,
            "endOffset": 391355,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 390679,
            "endOffset": 391223,
            "count": 4
          },
          {
            "startOffset": 390749,
            "endOffset": 390789,
            "count": 1
          },
          {
            "startOffset": 390789,
            "endOffset": 390830,
            "count": 3
          },
          {
            "startOffset": 390830,
            "endOffset": 390870,
            "count": 0
          },
          {
            "startOffset": 390870,
            "endOffset": 390960,
            "count": 3
          },
          {
            "startOffset": 390962,
            "endOffset": 391002,
            "count": 0
          },
          {
            "startOffset": 391002,
            "endOffset": 391222,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 391020,
            "endOffset": 391212,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 391780,
            "endOffset": 392328,
            "count": 3
          },
          {
            "startOffset": 391850,
            "endOffset": 391890,
            "count": 1
          },
          {
            "startOffset": 391890,
            "endOffset": 391931,
            "count": 2
          },
          {
            "startOffset": 391931,
            "endOffset": 391971,
            "count": 0
          },
          {
            "startOffset": 391971,
            "endOffset": 392061,
            "count": 2
          },
          {
            "startOffset": 392063,
            "endOffset": 392103,
            "count": 0
          },
          {
            "startOffset": 392103,
            "endOffset": 392327,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 392121,
            "endOffset": 392317,
            "count": 2
          }
        ]
      },
      {
        "functionName": "subscribe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 392561,
            "endOffset": 392879,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unsubscribe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 393029,
            "endOffset": 393327,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 393417,
            "endOffset": 393800,
            "count": 2
          },
          {
            "startOffset": 393566,
            "endOffset": 393796,
            "count": 1
          }
        ]
      },
      {
        "functionName": "isConnected",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 393849,
            "endOffset": 394023,
            "count": 3
          },
          {
            "startOffset": 393908,
            "endOffset": 393954,
            "count": 1
          },
          {
            "startOffset": 393954,
            "endOffset": 394019,
            "count": 2
          },
          {
            "startOffset": 394004,
            "endOffset": 394012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTransport",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 394070,
            "endOffset": 394125,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getMetrics",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 394164,
            "endOffset": 394440,
            "count": 2
          },
          {
            "startOffset": 394221,
            "endOffset": 394239,
            "count": 1
          },
          {
            "startOffset": 394241,
            "endOffset": 394439,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectHttp",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 394472,
            "endOffset": 394827,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectWebSocket",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 394830,
            "endOffset": 395301,
            "count": 1
          }
        ]
      },
      {
        "functionName": "handleReconnect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 395304,
            "endOffset": 396073,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createNetronStub",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 396076,
            "endOffset": 397131,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 396407,
            "endOffset": 396490,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 396548,
            "endOffset": 396560,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 396615,
            "endOffset": 396701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 396782,
            "endOffset": 396797,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 396861,
            "endOffset": 396869,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 396926,
            "endOffset": 396937,
            "count": 0
          }
        ]
      },
      {
        "functionName": "on",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 396954,
            "endOffset": 396989,
            "count": 0
          }
        ]
      },
      {
        "functionName": "off",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 396997,
            "endOffset": 397033,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 397041,
            "endOffset": 397088,
            "count": 0
          }
        ]
      }
    ]
  }
]